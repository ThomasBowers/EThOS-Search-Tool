Virtual Prototyping of Embedded Real-Time 
Systems 
Vincenzo Trignano 
A theses submitted in fulfilment of 
the requirements for the degree of 
Doctor of Philosophy 
at the University of Sussex 
School of Science 
and Technology 
University of Sussex 
Brighton 
BN19QH 
IMAGING SERVICES NORTH 
Boston Spa, Wetherby 
West Yorkshire, LS23 7BQ 
www.bl.uk 
DECLARATION PAGE NOT 
SCANNED AT THE 
REQUEST OF THE 
UNIVERSITY 
Acknowledgements 
This thesis would have not been possible without the help and support of my supervisor 
Professor Paul Lister and my fellow researchers at the Centre/or VLSI and Computer Graphics. 
I must also thank my family and friends for their continued support in the production of this 
thesis. 
University of Sussex 
VINCENZO TRIGNANO 
Submitted for the degree of Doctor of Philosophy 
VIRTUAL PROTOTYPING OF EMBEDDED REAL-
TIME SYSTEMS 
ABSTRACT 
This thesis presents the ViPERS (Virtual Prototyping of Embedded Real-time Systems) virtual 
prototyping methodology. The concepts, the implementation, and the experiments presented in 
this thesis were developed at the University of Sussex (UoS) in the Centre for VLSI and 
Computer Graphics and were part of an EU funded project. 
ViPERS refers to a design methodology which links the graphical and interactive features of 
virtual prototyping techniques with key design trends for SoCs. System level design is a widely 
adopted approach to deal with the complexity, short time-to-market, and heterogeneous nature 
of today's electronic systems. The integration of virtual prototyping with the SystemC design 
methodology is proposed to deal with issues such as the modelling of the interfaces and the 
exploration of user-machine interaction which are becoming of vital importance in embedded 
handheld devices. An exploration of virtual prototyping and SOC design is illustrated in the 
thesis to provide an understanding of the objectives of the ViPERS methodology. The ViPERS 
approach is assisted by a framework which provides the necessary tools needed for the 
implementation and simulation of virtual prototypes in the different phases of the suggested 
design flow. After illustrating the ViPERS methodology and environment the focus of this 
thesis will be on the links provided within the ViPERS framework to allow communication 
between the graphical models and the underlying functional counterparts. 
A key contribution includes the development of a design flow for SoCs, with special focus on 
the communication infrastructure which enables the graphical and functional models to interact 
at simulation time. Another contribution in this thesis is the illustrative case study where 
interactive photorealistic models of electronic handheld devices are combined with their 
respective functional models implemented in SystemC and UML. The case study presents the 
design of an RF-based remote control for home automation. 
Glossary 
Glossary 
ASIC Application Specific Signal Processor 
BCA Bus Cycle Accurate 
CA Cycle Accurate 
DSL Domain Specific Language 
EDA Electronic Design Automation 
FPGA Field Programmable Gate Array 
FSM Finite State Machine 
HCI Human Computer Interaction 
IC Integrated Circuit 
IP Intellectual Property 
LCCS Local Communication Control Service 
MDA Model Driven Architecture 
MOC Modelo/Computation 
OMG Object Management Group 
OSCI Open SystemC Initiative 
PIM Platform Independent Model 
PSM Platform Specific Model 
RT Real-Time 
RTL Register Transfer Level 
RTOS Real-Time Operating System 
RUP Rational Unified Process 
SDL System Design Language 
SLD System Level Design 
SLDL System Level Design Language 
SLL System Level Language 
SoC System-On-Chip 
TF Timed Functional 
TLM Transaction Level Model 
TIM Time-to-Market 
UML Unified Modelling Language 
VoS, Vs University of Sussex 
UTF Un Timed Functional 
VDM Virtual Device Modeller 
ViPERS Virtual Prototyping of Embedded Real-Time Systems 
VIPERS VirtualIP Environment for Rapid Silicon 
VLSI Very Large Scale Integration 
Contents 
2.3.1 
2.3.2 
2.3.3 
2.3.4 
2.3.5 
2.3.6 
2.6.1 
2.6.2 
2.7.1 
2.7.2 
2.7.3 
2.7.4 
4.2.1 
4.2.2 
4.2.3 
4.3.1 
4.3.2 
4.3.3 
4.3.4 
4.3.5 
Chapter 1 
Introduction 
Chapter 1 Introduction 
INTRODUCTION 
he embedded systems market and in particular that of handheld electronic devices has 
been through a series of changes in the last decade. Their relatively small market saw 
a shift from a limited variety of extremely simple products to the mass market 
production of a numerous variety of highly technological and complex devices such as mobile 
phones, PDAs and remote controls [I]. 
In the past, the simple nature and ease of manufacture in a small sized product, made remote 
controls a common handheld electronic device. Those simple one-way infrared-based remote 
controls performed only basic tasks and comprised a very limited functionality. Today's 
technology (2004), allows the manufacturing of sophisticated radio-based, two-way remote 
controls which can offer far greater functionality in even smaller sized products. The nature of 
some of today's handheld devices is very different. They are small computers with enough 
processing power to comprise operating systems with which elaborate applications can be 
developed. New products are constantly being produced and new technologies exploited. 
Even common electronic devices that we make use of every day can be very complex. Behind a 
product which might appear basic, months of designing and development work might be hidden. 
The design of embedded systems [2] in fact, needs to deal with several issues of critical 
importance such as real-time constraints, power consumption, hardware/software partitioning 
and integration, software failure implications etc. All these issues need to be taken into 
consideration from the early stages of design, and upon them other decisions have to be taken, 
such as the target processor, the operating system, the memory to use, the drivers and so on. 
Chapter 1 Introduction 
1.1 SoC Challellges 
The decrease in product size and the increase in complexity are traceable to the developments in 
silicon technology, which enabled manufacturers to place on a single chip the complete 
functionality of an electronic product (System-On-a-Chip - SoC). 
' .. . A SoC is a complex IC which integrates the major functional elements of a complete end-
product into a single chip or chipset. It incorporates. programmable processor. on chip 
memory and acceleratingfunction units implemented in hardware ... . Chang et al [3] 
A consequence of the advancements in silicon technology is the increase of the number of 
transistors which can be placed on a single chip. Today this number is very large and it was 
predicted in 1965 by Intel's Gordon Moore [4] with Moore ' s Law shown in Figure 1-1 and 
more recently confirmed by the International Technology Roadmap for Semiconductors (ITRS) 
[5] to keep on growing at this very high pace for the forthcoming years. The number of 
transistors on a chip influences the complexity of the system. The greater this number the 
greater is the likely functionality which can be incorporated into a device. 
Moore'S Law 
Transistors 
10000000 1------1-----t----+----+--iil-~._::;...;~-_I 
1000000 1-------r-------~------+--~~+_------+_---__4 
100000 1-------r--~-~~~-~----+_----+_---__4 
1000~----~------~--------------~------~------~ 
1970 1975 1980 1985 1990 1995 2000 
Year of Introduction 
Source: Inlel Corp .. hllp:/lwww.inlel.comlresearch/silicon/mooreslaw.hlm 
Figure 1-1 Moore's law for Intel processors 
But while silicon technology is evolving so fast, design methodologies have not kept up with 
this advancement. This means that designers have to use cumbersome methodologies and tools 
geared to deal with simpler systems for the design of much more complex devices. 
- 3 -
Chapter 1 Introduction 
Another phenomenon characterising the embedded systems market is the shortening of the time-
to-market. Technologies, as well as consumer needs, are evolving and changing so fast that 
products need to reach the market before the market for that particular product is saturated. The 
fast technological advance implies that delays in releasing a product on the market can cause its 
failure with the consequent losses for the manufacturing company. The so called window of 
opportunity determines the time gap in which a product needs to be released on the market in 
order to succeed and manufacturing companies need to strictly adhere to those times in order to 
avoid losses. The design for production of an electronic product might be longer than its 
window of opportunity, which means that products often need to be designed anticipating future 
technologies and market trends [6]. 
Design methodologies have been proposed over the past years and efforts are currently being 
made to close this existing gap. These methodologies provide new concepts. tools and design 
flows to deal with the complexity and short time-to-market of SoC design. But these 
methodologies ignore a number of issues and concerns which are becoming increasingly 
important. The extensive functionality of products for example. needs to be accessible to users; 
this cannot be achieved without the detailed design and testing of interfaces. Traditional 
methods need to be replaced or integrated with innovative processes to deal with and to fully 
exploit the technological advancement in silicon-based embedded systems technology. 
The design of complex graphical user interfaces. the studying of human-machine interactions, 
the exploration of the usability of a product, the marketing of products, user-centred design 
techniques and team collaboration are becoming of vital importance in determining the success 
of an electronic product. 
All these issues underline different needs which have so far been dealt with through separate 
processes. On one side there are the issues related with the design and implementation of the 
underlying electronics which can be dealt with the use of an appropriate design methodology for 
SoCs. On the other side the design and testing of interfaces and user interaction issues. the 
marketing of products and the communication of teams can be successfully dealt with virtual 
prototyping techniques. 
The remaining part of this introduction will lightly explore the different needs and solutions 
which virtual prototyping techniques and SOC design methodologies need to incorporate. Some 
of the issues related with each field are shown in Figure 1-2. 
Automated Processes ~ """'r' Requirements 
Coherence In Models Anajysis 
Executable Specification V System level Design 
IP Reuse : 
Model Refinement SOC 
Mixed languages 
Design 
Methodology , , 
Mixed Abstraction levels 
Support Standards : , 
I",  M .. ~  _ M' _ ~ M .. --Hardware Software Codesign 
Chapter 1 Introduction 
Virtual 
Prototyplng 
GUI Design 
Human-Machine Interaction Exploration 
User-Centred Design 
Market Research 
Usability Testing 
Team Communication and collaboration 
Product Conceptualisation 
. .. -----------.----------------------------------
Figure 1-2 - Methodology Requirements 
For handheld electronic devices interfaces are very important. The physical interface, from the 
display to the buttons, occupies a very limited area. The functionality of these devices is very 
complex, and the access of the user to this is achieved via the interfaces. On electronic systems 
where size is not an issue, large displays and areas where to place buttons and other interaction 
components can ease the design of interfaces. For handheld devices only a limited amount of 
resources is employed to interface the user with the device. Both graphical and the physical 
user interfaces need to be accurately designed and tested prior to any real implementation. 
Graphical user interfaces will depend on the software development, but high level models 
should be employed to simulate the behaviour of the interfaces. Usability tests need to be 
carried out to analyse issues related to the interaction of the user with the device. Users with 
different background knowledge need to test the interfaces in order to determine its usability. 
Physical user interfaces need to be modelled and explored in conjunction with the graphical user 
interfaces. The choice of a touch screen over a button can, for instance, determine an easier 
access to the functionally of a device and therefore result in a more friendly transaction. 
The use of user-centred design techniques is becoming widely accepted. Interfaces and 
functionality need to be designed with the potential user in mind. This is achieved by 
undertaking market studies and getting user feedback through, for example, user trials. 
Valuable feedback can be obtained by the user before and during the design and implementation 
stages. Interaction of the user with prototypes of the device needs to be studied and possibly 
enhanced. 
- 5 -
Chapter 1 Introduction 
Other less traditional issues are related with global markets. Design teams are often 
geographically dispersed, speak different languages and have different background knowledge. 
All the members related with a project from marketing teams to hardware engineers, from 
investors to system engineers, need an effective way to communicate and take part in the design 
of the electronic product. 
The highly competitive nature of the embedded system market also forces the quality of 
products to be kept high. This means that all aspects of a device need to be appropriately 
designed. Among these features we need to include the look of the product. The aesthetic 
qualities need to be modelled and designed from the early stages of the design of the device and 
in conjunction with the design of the physical and graphical user interfaces. It is not uncommon 
nowadays for the success of an electronic product to be significant contributed to by its aesthetic 
qualities. 
The discussion presented above illustrates that the design of today's handheld electronic 
systems has more to be modelled than solely the implementation details of the SOC. Being able 
to implement a huge amount of functionality into a small handheld device would not alone 
determine its success. Other issues need to be dealt with, and the work presented in this thesis 
suggests the integration of virtual prototyping as the solution. 
The remaining part of this section will present some of the requirements which an appropriate 
design methodology for SoCs should posses. Generally, a methodology is employed to provide 
designers with the optimal design flow and tools which should be employed when designing 
SoCs. Methodologies advise designers on when and how steps of the design should be taken. 
Chang et al [3] describe some of the market forces which are pushing for new methodologies 
and toolsets. Architectural design needs to be precise and correct from the early stages of 
design. Failure to detect architectural issues early determines costly and lengthy modification in 
later stages. Berger [2] shows (see Figure 1-3) how the cost of fixing errors grows 
exponentially depending on when in the design life cycle they are found. Errors found early in 
the design can easily be changed. The process of modification at that stage is fast and the costs 
are limited. Errors found in later stages of the design, for example when hardware and software 
blocks have been implemented, translate in a much slower, complex and costly process. 
A solution for dealing with growing functional complexity and early exploration and testing of 
complex architectures is to adopt system level design (SLD). 
Chapter 1 Introduction 
System Specification 
And Design 
Cost to fix 
Hardware & 
Software 
Design/Debug 
Prototype 
Debug 
Maintenance and upgrade 
Filure 1-3 - Project time in eaeb pbase of embedded desiln 
life eyele witb aSloeiated eost for Oxinl errors. 
Source: Berger (1). 
System 
The principle behind system level design is to raise the level of abstraction to the system level. 
The level of abstraction refers to the amount of detail present in the design or how close the 
design is to the final implementation of the target product. Designers start by designing very 
high level designs of the system. High levels designs contain fewer details than a corresponding 
low level design and are therefore easier to implement and modify, and faster to run and debug .. 
Once a model is completed, independently of its abstraction level, it can be verified. Each time 
the system is tested and approved, designers add details and go down in the levels of 
abstraction. SoCs can be very complex systems made up of different parts with very different 
nature. Hardware and software blocks are placed on the same chip and communicate with each 
other; all of this has to be modelled for SoCs. 
The advantage of system level design is that high level models do not usually deal with issues 
such as partitioning and timing, but they provide the means for designers to take decisions about 
later stages. To support programming at different levels of abstraction, languages have emerged 
and tools have been developed, to provide a more efficient design environment for designers. 
Chapter 3 will outline the difference, with associated advantages and disadvantages, between 
some of the proposed languages. 
Chllpttr 1 Introduction 
Another key aspect to deal with the complexity of today's mix systems is reuse. Reusing 
existing components helps design teams to accelerate the design process. The implementation 
of a SoC is typically a combination of software and hardware blocks. Rarely are these complex 
systems designed from scratch. More often new designs are based on existing ones which need 
to be improved or new technologies need to be integrated within them. In this case blocks from 
previous designs can be reused in the new design. In other cases one or more blocks can be 
bought from external IP vendors. Reuse should apply to software as well as hardware blocks. 
Since the SoC is designed from the system level, different models will be implemented and 
modelled during the refinement process to the low level implementation. A framework should 
provide designers with a high degree of freedom for combining together hardware and software 
blocks as well as blocks implemented at different abstraction levels. Designers should be 
provided with a common language for both hardware and software implementation. 
Additionally the framework should provide the capability of simulating components written in 
different languages together. This can be important for example when reusing components 
which are bought or were previously developed in different languages. By mixing components 
implemented in different languages considerable time can be saved. The framework should also 
provide the capability of simulating components implemented at different levels of abstraction 
together. When the system level model has been tested and verified, hardware and software 
engineers start working on the low level implementation. Since the time of implementation can 
be considerably different and the integration of a low level system can be quite tedious, 
hardware/software engineers should be able to test their low level implementations within the 
system level model. This should be done by replacing the high level block with the low level 
correspondent. Where different languages or abstraction levels are used, automated processes 
should be provided to speed up the translation or re-adaptation of the code. Coherence between 
different models should be kept in a way that when changes are made in low level models those 
should quickly be feed up the refinement flow to the high level models. This would enhance the 
reuse of these models if successive products are based on them. Finally implementations and 
descriptions should conform to standards. Conformance to standards allows interoperability 
and reuse. 
The next section identifies the issues which the methodology proposed in this thesis should 
embrace for both virtual prototyping and SOC design: 
Within high level designs, designers should be able to design and test systems at the system 
level. 
Chapter 1 Introduction 
IP reuse should be supported. Major efforts have been made in SoC design to improve and 
extend the use of IPs. Large systems like today's are rarely built from scratch. To speed design 
time and productivity, IP reuse needs to be employed as much as possible. 
Designs should have the capability of being verified as a composition of blocks implemented at 
different levels of abstraction. A designer should be able to test the block he/she is 
implementing by integrating it in the system at any time, without having to wait for the other 
low level blocks to be ready. Systems should be also able to be composed of blocks 
implemented in different languages. This would enhance IP reuse, maximise possible expertise 
and take advantage of the benefits of some languages over others in specific designs. 
Modelling environments should provide designers with the capability to design and verify the 
hardware and software blocks together in a common framework. Additionally support for 
hardware and software should be provided. This should be achieved wherever possible to 
improve interoperability and reuse. 
The framework should allow automated processes between different phases. Tools should 
automate the progression between different stages of the design to maximise the reuse of 
previous stages in the later ones. This should include support for conversions from written to 
executable specifications. 
Models implemented at different levels of abstraction should be coherent. High level models 
should contain the changes made in lower level implementations. 
The design flow should be based on a refinement process. Models should be refined from high 
level models to lower levels through a precise design flow. 
The framework should include support for graphical and physical user interface (GUI and PUI) 
design. Designing and testing graphical and physical user interfaces should be integrated in the 
design flow. 
Support should be provided for Human-Machine interaction exploration and user-centred 
design. The methodology should include features for exploring issues related with the 
interaction of the user with the device. Users should be the focus of the design process. 
Tools should provide support for marketing teams. 
Chapter 1 Introduction 
Usability testing should be conducted where possible and especially in the early stages of the 
design. 
Tools should be provided to enable teams with different background knowledge to 
communicate and collaborate through a common visual reference. 
The approach presented in this thesis addresses some of the issues identified above and 
proposes solutions for others. The principle behind the methodology presented is the linking of 
a SoC design methodology with virtual prototyping. The approach goes under the acronym of 
ViPERS (Virtual Prototyping of embedded real-time systems) and was partly based on the work 
conducted during a European funded project (VIPERS [7]). 
1.2 VIPERS - Virtual IP Environment/or Rapid Silicon 
In this section the VIPERS project will briefly be outlined since it represented one of the driving 
forces for the research discussed in this thesis. 
VIPERS is an EU funded project part of the 1ST framework 5. 
'VIPERS will develop new solutions for RF-based embedded systems for control application. 
These are based on two developments: a set of ASIC macrocells for RF links and related 
functions and a novel virtual prototyping environment that supports rapid design and IP reuse' 
The centre for VLSI and computer graphics involvement in the VIPERS project was 'to 
generate a framework that supports the design flow of low-cost low-complexity RF-based 
embedded systems, providing a flow that gathers virtual modelling concepts, hardware-
emulation and specific detailed design issues, like power estimation, testing or validation. This 
framework is based on existing tools, whenever possible, and new tools to be developed.' [8]. 
Figure 1-4 illustrates the structure of the VIPERS project. 
 The Centre for VLSI and Computer Graphics is a research group in the School of Science and 
Technology in the Department of Informatics at the University of Sussex 
- 10-
Chapter 1 Illtroductioll 
VIPERS: Virtual IP Environment for Rapid Silicon 
Method and design HWandSWIP Application 
environment development prototypes 
System modeJling and Hardware IPs for RF--
concept visualisation based communications 
t-bme automation 
Refinement, emulation, Ir Digital hardware IPs 
application 
testing, performance and software IPs for 
estimation protocol and encryption 
Figure 1-4 - Structure of VIPERS. 
Source: VIPERS project, Description of Work 181 
'The virtual prototyping environment will support conceptual modelling. enabling a VIPERS 
technology customer to rapidly visualise a proposed product and incorporate high-level 
behavioural models of previously designed IP blocks (both hardware and software). In addition 
to reuse of existing JP, the user will be able to simply incorporate new models of additional 
functionality. The resulting high-level model will constitute an executable specification of the 
candidate application. The high-level modelling environment will link to other stages in the 
embedded system development tool-chain. including system hardware emulation, assessment of 
design f eatures such as implementation reusability. power consumption, gate count etc. 
Refined designs will be suitable for System-On-Chip ASIC or FPGA plus RF components 
implementation. Final systems will include test and debug hardware elements' [8]. 
The device conceptualisation tool is connected with a detailed design flow, which can be 
divided into two parts: IP design and SoC integration as shown in Figure 1-5. Both parts should 
have a link with the product conceptualisation toolset by means of design files and test benches 
written in a formal design language such as SystemC [9,10, 11, 12 and 13] or C++. 
- 11 -
Chapter 1 Introduction 
Q) -C/) Simulation II Synthesis >. 
IP Design ( ) Power Estimation 
IP Quality Assessment 
Device t 
Conceptualisation () 
Simulation II Floorplan 
Q) -C/) >. 
( ) SoC Integration 
Power Estimation 
Emulation 
<.) --() 
HW Configuration & Debug 
Figure 1-5 - General view of the VIPERS design environment. 
Source: VIPERS project, Description of Work [81 
Figure 1-6 shows a close up of the device conceptualisation tools. The different tools for the 
modelling and the design environment are shown. The diagram shows the three main 
components used for the conceptualisation of the device. These are : 
1. Functional Behaviour. It includes the implementation of a functional description of the 
target electronic device. The language of implementation is not important as long as the 
communication protocol is satisfied and the description can be executed. The model 
created in this tool needs to communicate with both the visualisation tool and with the 
Physical model generation tool. 
2. Visualisation. It includes the visualisation of the graphical model during a simulation 
of the virtual prototype. The visualisation tool requires a framework to communicate to 
both the functional and physical model. 
3. Physical Model Generation. The physical model is the graphical model. This model 
must contain the interaction mechanism as well as the graphical features of the target 
device. The tool provides an easy to use interface which designers can use to quickly 
put together photorealistic models of the target device. At simulation time the user 
interacts with the physical model which is driven by the functional model. 
The outcome of the interaction of these tools is an executable system model which is then 
fed into the toochain for SoC implementation and design. 
- 12 -
Ch apter 1 Introduction 
Device Conc eptualisation Tools 
Functional 
~ Behaviour ~ 
t'----------' t 
Physical Interaction 
Model ( ) Visualisation 
Generation 
Executable System Model 
Specification D Compliance i Check 
Toolchaln for SoC Implementation 
Simulation II Synthesis 
IP Design Power Estimation 
IP Quality Assessment 
Simulation II Floorplan 
Power Estimation 
SoC Integration 
Emulation 
HW Configuration & Debug 
Figure 1-6 - Components and Design Flow for the VIPERS modelling and design environment. 
Source: VIPERS project, Description of Work 18) 
1.3 ViPERS - Virtual Prototypil'g of Embedded Real-Time Systems 
While major interest and work is being done on proposing design methodologies and toolsets to 
deal with the fast complexity growth of SoCs, it is the contention of this thesis that virtual 
prototyping has to be linked to such methodologies to provide further means for the designers to 
- 13 -
Chupter 1 Introduction 
develop and test their systems. Previous research [14, 15, 16, 17, 18, 19] on virtual prototyping 
had demonstrated the benefits especially in the field of requirements analysis, interfaces design, 
team collaboration and marketing of the target products. We considered that the graphical and 
interactive features of virtual prototyping could be integrated into a design methodology for 
SoCs. The ViPERS approach integrates in parallel a design methodology for SoCs and virtual 
prototyping techniques. The adopted design methodology for the design of SoCs is the one 
based on SystemC and therefore based on system level design. For the virtual prototyping we 
developed tools, applications and services to overcome some of the limitations present in 
existing tools. The tools developed for the virtual prototyping, existing tools for SoC design, 
and the processes and applications used to link them together represent the ViPERS framework 
or environment. 
A virtual prototype in the ViPERS approach is seen as the combination of a functional 
behavioural model with its graphical counterpart. ~uring the simulation of a virtual prototype 
the user interacts with the graphical model, which is driven by the underlying functional model. 
Virtual prototyping in the context of the ViPERS methodology is seen as a visual layer on top of 
the modelling of the electronic systems. The graphical model is created through the use of an 
IDE called Virtual Device Modeller (VOM). YOM is also used to add interactivity to the 
model. VOM is described in details in Chapter 4. High level functional behavioural models are 
implemented and then refined to lower levels while the design proceeds. A case study is 
presented in this thesis. This was the result of a collaboration between the University of Sussex 
and an industrial partner for the design of an RF-based remote control for intelligent home 
appliances. The case study allowed the exploration of the methodology and validated some of 
the concepts. 
1.4 Outline of the Thesis 
In this thesis the link between SoC design and virtual prototyping is explored. An exploration 
of both fields is presented in the first part of this thesis to illustrate key trends, previous and 
ongoing research, as well as commercial products and their allocation in the design flows. After 
the examination of the research literature, the ViPERS environment and methodology is 
outlined. The tools, the libraries and the services that make up the environment are described 
and the design flow associated with the methodology is outlined. A case study is then 
illustrated to show a practical experiment with an industrial partner that demonstrated the 
benefits of using the environment and the methodology. Finally conclusions on the results are 
given and possible future work illustrated. 
- 14-
Chapter 1 Introduction 
The thesis is divided into six main chapters and five appendices. The six chapters are: 
1. Virtual prototyping. This chapter presents an overview on virtual prototyping and then 
concentrates on an examination of research literature. The fundamentals of the work 
presented in this thesis can be found in this chapter. 
2. SoC Modelling. This chapter explores the SystemC methodology for SoCs and outlines 
its design flow. The chapter also explores issues related with requirements analysis 
with UML (Unified Modelling Language) [20] and its connection to SystemC. 
3. The ViPERS methodology and environment. The design flow for the approach is 
described and the different tools and processes which make up the environment are 
outlined. The work presented in this chapter has also been published by Lister et al [21, 
22, and 23] 
4. Executable Functional Models (EFM). This chapter defines EFM and their connectivity 
to the main framework. It includes the description of libraries, packages and tools used 
to connect the functional models to their graphical counterparts. The work presented in 
this chapter has also been published by Lister et al [24, 25, and 26] 
5. Case Study. This chapter describes a case study of a practical experiment using the 
ViPERS approach and environment. It is based on a design effort which saw the 
University of Sussex collaborating with an industrial partner for the design of an RF-
based remote control. The design process, the problems encountered, the benefits noted 
and the lessons learned from the experience are explored. The work presented in this 
chapter has also been published by Lister et al [27,28, and 29] 
6. Conclusions and Future Work. This chapter discusses the conclusions drawn from the 
research and the ongoing and future work related with the ViPERS methodology. 
The five appendices are: 
a. Standard UML description of the remote control (Appendix I). This appendix 
outlines the description of the remote control described in chapter 6 with the 
use of standard UML diagrams. 
- 15 -
Chapter 1 Introduction 
b. SxUMLSocket Package (Appendix 2). This appendix explores in more detail 
the UML package described in chapter 5. 
c. Remote control in Rational Rose RealTime (Appendix 3). This appendix 
describes in details the UML model of the remote control modelled in Rational 
Rose RealTime [30] and illustrated in chapter 6. 
d. Remote control in CoCentric (Appendix 4). This appendix describes in details 
the SystemC implementation of the remote control modelled in CoCentric 
System Studio from Synopsys [31] and illustrated in chapter 6. 
e. Overheads in Rational Rose and CoCentric (Appendix 5). This appendix shows 
the overheads created by Rational Rose RealTime and CoCentric System Studio 
when automatically generating code. 
- 16 -
Chapter 2 
Virtual Prototyping 
Chapter 2 Virtual Prototyplng 
VIRTUAL PROTOTYPING 
he definition of virtual prototyping can vary depending on its applications. A general 
definition of a virtual prototype is given by Garcia et al [32]. They define a virtual 
prototype as ' ... a computer-based simulation of a system or subsystem with a degree 
process of USing a virtual prototype. in lieu of a physical prototype, for test and evaluation of 
specific characteristics of a candidate design ... '. 
This thesis concentrates on the virtual prototyping of embedded real-time systems, with a 
special focus on wireless handheld devices such as remote controls. Among other attempts to 
define virtual prototyping [33 and 34], the definition which is closest to the concepts expressed 
in the ViPERS project is given by Kerttula and Salmela [35, 36, and 37]; they envisage virtual 
prototyping as a combination of virtual reality, advance modelling, simulation and user interface 
techniques. They define VRP, Virtual Reality Prototyping as 'a prototyping process in which a 
product or product concept. its behaviour and usage situation is simulated as realistically as 
possible using computer models and virtual reality techniques'. The VRP concept was 
developed as part ofa research project [14], which, as ViPERS, focused on electronic consumer 
products. 
The definitions of virtual prototyping by Hodgson [33] and Thorn [34] restrict its possible 
applications and therefore do not conform to the concept of virtual prototyping used here. 
Hodgson, for example, restricts the use of virtual prototyping to three dimensional models. In 
the ViPERS environment both two and three dimensional models are employed. 
- 18 -
Chapter 2 Virtual Prototyplng 
A brief history of virtual reality and CAD is given by McLeod [38] in the attempt to illustrate 
the roots of virtual prototyping. For several years CAD tools have been employed for the 
design and testing of products since they eliminate the need for hand drawings and provide a 
means of standardising the drawing process. Computer based three dimensional models are 
widely used when mechanical attributes of a prototype need to be modelled. The electronic 
consumer products analysed in this thesis, usually have a limited number of mechanical 
properties, and so focus is on interfaces and hardware/software related issues. 
McLeod [38] believes that virtual prototyping can revolutionise design and production planning, 
but not before issues with technological prejudice and affordability are overcome. Many 
companies are not aware of what virtual prototyping really has to offer and tend to consider it to 
be too expensive and too complex. The ViPERS approach is intended to diminish both the 
complexity and costs related to virtual prototyping by providing tools and design flows to aid 
designers throughout the entire process. 
The biggest research input in the field of virtual prototyping of electronic consumer products 
can be credited to the research conducted in a number of projects [14, 15, 16, 17, 18, and 19] in 
Finland between 1996 and 2001. These projects saw the collaboration of research companies, 
universities and industrial partners. Among the various project partners, were the research 
company VTf electronics [39], InfoTech research centre at the University ofOulu [40] and the 
telecommunications company Nokia [41]. The outcome of this extended research is covered in 
a large number of publications, thesis, journal articles, and the production of a software tool 
[42]. Some of this work was conducted at the same time as the research detailed here. In this 
chapter of the thesis a selection of papers, books, and presentations related to virtual prototyping 
will be explored and their relevance to the ViPERS environment discussed. 
2.1 Degrees 0/ Realism in Virtual Prototyping 
From the definitions given above, virtual prototypes can have different degrees of functional 
realism. The degree of realism of a virtual prototype is determined by the features or the 
properties of the target product which are modelled and simulated. This section will illustrate 
three different approaches which provide a very different degree of realism. 
A non-interactive graphical model which can roughly resemble the looks of a product can be 
seen as the simplest form of virtual prototyping. A common approach for example, is to use 
visua//anguages such as visual basic or visual C++, to create crude graphical models of the 
target product as shown in Figure 2-1. 
- 19 -
C" apte r 2 Vi rt u a I P rototypi IIg 
G-U-I-XAM--P-l----------------------------------------~- ~ 
0ptJ0n I OptIOn 2 J 
VoIumoDOWN 
ON/OFF UP J  
LEFT RIGHT -=:J DOWN 
Figure 2-1 Basic interface for a virtual prototype using Visual C++ 
The mechanics of the buttons are automatically implemented by the software framework. In 
addition the programmer only needs to add in the code inside the Event Handler segments 
which are processed when a button is pressed. A sample code fragment is shown in Figure 2-2 . 
. .;. ' ~" .. 
Figure 2-2 Coding Crude Prototypes in Visual C++ 
- 20 -
ell apter 2 Vi rt u al Prototypi IIg 
The main benefit of this approach is the speed of implementation which can provide mock-up 
prototypes for the conceptualisation phase. The drawbacks are the poor quality of the graphics 
and the limited functionality which do not provide a precise visual reference between designers. 
This approach ignores two of the key issues which the ViPERS approach addresses. One is the 
desire to accurately model the graphics in order to provide an interactive virtual prototype which 
leaves no room for misconceptions about the design. The other is the modelling of the system 
electronics. The combination of the underlying electronic model with the virtual prototype is 
used in the ViPERS approach to provide an executable speci fication of the target device. 
A much more complex virtual prototype may be made up of a detailed three dimensional model 
with audio and force feedback where hardware/software simulations control the functionality of 
the virtual prototype. The simulation of the virtual prototype may be part of a rich virtual 
environment where the user is immersed and the prototype is interacting with other virtual 
devices. A similar approach is described by Lister et al [23] and will be discussed in more 
detai Is in following sections of this thesis. 
101 .. 1 
[ ,,~ -- J "...,..., ComoKIIOI'I s)'t&IWIC PeA. ~ VOroI OMit" . ~ I '00" o-cro 1'0" 
Figure 2-3 DPX for High Level Models 
~ U, IU(If'I 
:I "-&AM 
.l Lt1&.aJf1 
.J fl:1lf4&Aoro 
OIldlltLCD 
,J ""~ 
:.1 " -
.l o.,.-. 
0rI 1t .. -., tuI) 
~ .. c.~rt. _ ... 
An intermediate approach, compared to the two mentioned earlier in this section, is to combine 
a two dimensional photorealistic graphical model with a high level behavioural model. The 
behavioural model can be implemented as reported by Watten [43] using a software tool (DPX), 
to create an ad-hoc high level C++ model. Figure 2-3 shows the combination of the two models 
- 21 -
Chapt e r 2 Virtual Prototypill g 
during a simulation. The behaviour of the system is described by high level hierarchical blocks 
implemented in C++. A major drawback of this approach is the missing link from high level to 
low level modelling. The C++ models might have no resemblance with the low level hardware 
and software correspondent implementations, and even the partitioning of the system might be 
completely di fferent. Once the system has been verified as a high leve l model a new 
implementation needs to be started from scratch for the hardware and software blocks. The 
route to implementation is weak, and the implementation of a model which can be used only for 
the conceptualisation phase, and has no links to lower level implementations, can be time 
consuming. The benefits of high level behavioural models implemented in ad-hoc 
environments such as DPX, are the speed and ease of implementation . 
Additionally, the means of interaction of the user with the virtual prototype can increase the 
degree of realism of the virtual prototype. In a simple simulation environment the user interacts 
with the virtual prototype via a computer monitor, a keyboard and a mouse; this is a simple, 
fast, and low-cost solution. More sophisticated interaction means include VR tools such as data 
gloves and head mounted di splays (as demonstrated by Salmela and Pulli [36] and shown in 
Figure 2-4), or even a CAVE [44] or immersive experience. 
Figure 2-4 Head-tracked stereo shutter glasses with the 3D stereoscopic 
image of a virtual prototype though a haptic interface device. 
Source: Salmela and Pulli (36) 
- 22 -
Chllpter 2 VlrtulIl Prototyplng 
2.2 Features of a Virtual Prototype 
A target electronic product has a number of properties or features which can be modelled and 
simulated using virtual prototyping techniques. Some of these properties are intrinsic to the 
device and others are associated with its relationship to the outside world. A first attempt to list 
the different features which might be included in a virtual prototype of an electronic consumer 
product was made by Kerttula and Salmela [35, 36, and 3'7]. In addition to those features the 
ViPERS approach is concerned with modelling and simulating features which relate to the 
interaction of the virtual prototype with other devices and with its environment. 
Shown in Figure 2-7 and listed below is a list of the features of a target product, which can be 
modelled and simulated in a virtual prototype. The list combines the features outlined by 
Kerttula and Salmela and the ones included in the ViPERS approach. 
 Graphical Qualities: the virtual prototype must resemble the appearance of the target 
product. The first distinction between graphical prototypes is in the graphical 
dimensionality of the model. Models can be two or three dimensional. Both types are 
widely supported by commercial software tools such as Adobe PhotoShop [45] for two 
dimensional graphics and 3D Studio Max [46] for three dimensional graphics. Another 
distinction between graphical models lies in the photorealism2 of the graphics. 
Photorealism is the process of creating images that are close to photographic quality. The 
quality of the graphics and how real the model appears determine its degree of 
photorealism. 
 Mechanical Properties. The virtual prototype will have a number of mechanical properties 
that can be modelled. Push buttons are an example of a very ordinary mechanical 
component widely used in consumer electronics products. The mechanical property of a 
button is, for instance, its behaviour when pressed. Some buttons return to their original 
position while others stay pushed-in until pressed again. Other common mechanical 
components of handheld devices are switches, knobs, joy pads, etc ... 
 Functional Behaviour: The functional behaviour of the virtual prototype can be modelled 
by implementing a functional description of the target product. The level of abstraction of 
the functional model is the key issue. The functionality can be implemented from a very 
high level of abstraction by simple scripts to low level descriptions in VHDL or SystemC. 
2 The term derives from a painting movement of the mid-twentieth century in which artist painted from 
photographs, or made the paintings so real that would look like photographs. 
- 23-
Chapter 2 Jllrtual Prototyplng 
In the latter case the behaviour of the virtual prototype is driven by hardware and software 
simulations. Other implementations of the functional model might be for example in C++ 
or UML state charts. One of the key aspects highlighted by the ViPERS methodology is the 
route to hardware and software implementations. These concepts were mentioned by 
Kerttula and Salmela [35, 36, and 37] when depicting a full-digital front-end product 
development as the final aim of the VRP project. As described by Kerttula and Tokkonen 
[47] the VRP environment was built with an open architecture to allow hardware and 
software simulation to connect to the main framework. Their research diverted from that 
initial intent and the connection to hardware and software simulations was never 
demonstrated. In contrast the ViPERS approach integrates virtual prototyping techniques to 
hardware and software implementations and simulations making it one of its key aspects. 
Libraries, tools, services and experiments will be presented in subsequent chapters of this 
thesis to illustrate the commitment of the ViPERS methodology to link hardware/software 
simulations to virtual prototyping. 
 Graphical User Interfaces. Electronic consumer products and especially handheld devices 
rely heavily on graphical user interfaces. The modelling of the graphical user interfaces is 
closely related with a combination of both graphical and functional modelling. The 
graphical modelling of the display determines how the interface will be seen by the user, 
while the functional modelling will determine how this will react and change in response to 
the actions of the user. The graphical user interface differs from the graphical qualities 
mentioned above because it only relates to the graphics shown in the display, which in the 
target device will be driven by the software. For example the display may be showing 
moving images and need special rendering because of its key visual importance to the 
device. 
 Audio Properties. A virtual prototype can have a number of audio properties. Audio can 
be both an input and an output means. Sounds can be generated when a button is pressed or 
an event occurs, and they are an important way of providing feedback and cues for 
interaction. Voice recognition is an example of audio input; this can provide powerful 
interaction but it is beyond the scope of this research. 
 Haptic Feedback. As outlined by Burdea in [48] haptic includes both force feedback and 
, tactile feedback. These two types of feedback include simulating object hardness, weight, 
inertia, surface contact geometry, smoothness, slippage and temperature. This type of 
sensorial data requires haptic interfaces. Burdea groups haptic feedback in three groups, 
force feedback, tactile feedback and proprioceptive feedback and illustrates some examples 
- 24-
C h apfer 2 Vi rtll al Prototyp i IIg 
of feedback interfaces for both force, for example the PHANTOM family of arms, 
manufactured by SensAble Technologies [49], shown in Figure 2-5, and tactile feedback, 
for example the TouchSense-enabled peripherals, mice and trackballs, by immersion 
Corporation [50]. As described by Burdea, though, modelling physical interactions (precise 
collision detection, real-time force computation, and high control-loop bandwidth) results in 
a large computational load which requires multi-processor parallel processing on networked 
computers [48]. For handheld electronic devices, force feedback, for example, can be 
applied to a user pressing a button and tactil e feedback to simulate the smoothness of the 
case of the device. Experiments conducted by Salmela and Pulli [36] which applied haptic 
feedback to virtual prototypes of handheld devices showed the limitations of this approach. 
Applying haptic feedback to virtual prototypes of electronic devices is still costly, lengthy, 
complex, not readily accessible to users on the Web and it only provides limited 
enhancements during simulations. At present haptic feedback is ignored in the ViPERS 
framework. Haptic feedback will be considered in the ViPERS framework if further 
developments in haptic interfaces technology, decrease their cost and complexity. 
Figure 2-5 PHANTOM arm 
 Virtual environment. A virtual prototype can be placed in a virtual environment which 
resembles its typical environment. For example, if the virtual prototype is a remote control 
which controls the appliances in a house then the virtual environment would be a computer-
based three dimensional virtual house which contains interactive three dimensional models 
of the appliances. The virtual environment should react in sympathy with the virtual 
prototype and it can be made up of several virtual devices which the virtual prototype will 
- 25 -
C" apter 2 Virtu a I Prototypi "g 
interact with at simulation time. Virtual environments such as the one shown in Figure 2-6 
can increase the user experience and the sense of reality. The ViPERS environment 
provides the necessary tools and services to link virtual environments with simulations of 
prototypes. The need to use virtual environments as the context for virtual prototypes was 
previously expressed by Manninen [51], where he states that ' .. . one important aspect not 
directly discussed or answered within this field is the prototyping oj the environment where 
the product is supposed to be used .. . '. 
Figure 2-6 Virtual Environmene. 
Source: Watten /43/ 
 Interaction with other devices. Designers can model the interaction of a virtual prototype 
with one or more, virtual or real, devices. The types of interactions can vary. Two virtual 
prototypes interacting with each other at simulation time might be running as separate 
applications or different instances of the same application. A number of virtual prototypes 
might also be interacting with each other within the same virtual environment. Finally, one 
or more virtual prototypes might be interacting with real devices. 
3 The interactive virtual environment was created by Dr. Phil Watten, Centre for VLSI and Computer 
Graphics, University of Sussex 
- 26 -
Chapter 2 Virtual Prototlpl", 
The quality of a virtual prototype is dependent on its degree of realism, and furthermore, 
dependent on the realism perceived by the user during a simulation, i.e. taking into account the 
interaction means and the context of the virtual prototype. Today's technology, developed 
throughout years of research in the field of virtual reality, allows the creation of immersive 
virtual reality environments where users can ideally interact with a virtual prototype in a virtual 
context and simulate most of the features associated with that product. However all this comes 
with a related cost. If virtual prototyping is placed in the context of designing and 
implementing electronic products, then compromises need to be made. 
Filure 17 Possible features of virtual prototypes 
Two of the main advantages of employing virtual prototypes over physical prototypes are the 
speed and cost of their implementation; a virtual prototype can be built in less time and with 
lower cost. Physical prototypes instead are very costly and implementation times can be 
considerably longer. Components need to be built and decisions, which cost time and money, 
need to be made. Similarly, a simple virtual prototype can easily be built and tested while a 
sophisticated one, which is part of a complex simulation, can present similar disadvantages to 
those introduced by physical prototypes. In a complex virtual prototype, for example, time and 
effort are needed to model the three dimensional graphical model, the three dimensional 
environment, add interactivity to them, set the haptic engine to work in sympathy with the 
models and implement the hardware/software blocks. Considerable costs might also be 
introduced by the hardware necessary to run this type of simulations. Another issue that needs 
to be taken into consideration is the simulation speed which, may be detrimentally affected in a 
complex simulation. The trade off between the degree of realism and the complexity of the 
C" apter 2 Vi rill a I Prototypi "g 
simulation is therefore entirely dependent on the purpose of the virtual prototype and the related 
advantages it can provide. 
Attempts to extend virtual prototyping to immersive virtual experiences [35, 36, 37 and 47] 
through head mounted displays, data gloves, haptic interface devices, etc., demonstrated that the 
approach can be expensive, time consuming and hard to construct. 
Other attempts to apply special techniques in conjunction with virtual prototyping are described 
by Halttunen and Tuikka in [52]. The aim was to augment virtual prototyping with physical 
objects since virtual prototypes lack tangibility. Through a flat panel display, data gloves and a 
position tracking sensor, a virtual prototype may be linked to a physical object so that the latter 
is covered by the former, as shown in Figure 2-8 . The virtual prototype displayed on the flat 
panel responds to the actions that the user imposes on the physical object. Other issues arose, 
such as ease of use, which the authors explained could compromise usability tests . 
Figure 2-8 WebShaman DigiJoop System. 
Source: Halttunen and Tuikka (521 
Tools available on the market seem to indicate that the graphical and functional modelling of 
virtual prototypes is enough to provide the degree of realism needed to exploit most of the 
advantages provided by virtual prototyping. Other interface mechanisms, sllch as force 
- 28 -
Chapter 2 Virtual Prototyplng 
feedback, are likely to be adopted in future modelling techniques when the technologies have 
matured further and therefore do not add excessive costs and time to the design of the virtual 
prototype. 
McLeod [38] explores the availability and capabilities of low-end virtual prototyping and argues 
that virtual reality failed to deliver the over-hyped promises. As regards the three types of 
virtual reality - immersive, projection, and desktop - McLeod believes that the biggest 
innovations are to be found in the desktop field. In the approach presented here, the importance 
of low-end simulations as the basis for the prototyping process to maintain speed, low cost and 
ease of implementation are recognised. In addition, though, the ViPERS environment provides 
tools, services and design flows to facilitate the inclusion of projections and immersive 
simulations, where a more complete virtual experience is needed. The principle is to provide 
models which can be viewed via any rendering machine (monitor, projector, or head mounted 
display), depending on the resources and the mission of the designers using the environment. 
2.3 The Applications 0/ Virtual Prototyping 
This section explores some of the main applications of virtual prototyping. 
2.3.1 Conceptualisation Phase 
Virtual prototypes can be used in the conceptualisation phase of product development. 
Specifically in this phase the visual and functional nature of virtual prototyping can be defined 
to help eliminate the ambiguity that natural languages specifications can introduce. Tuikka [53] 
defines the three main phases in product development - concept development, product design 
and production. The concept development is the product specification and therefore should 
leave no place for misinterpretation. This led Tuikka. to believe that in this phase there is a 
clear need for virtual prototyping. Additionally, in the ViPERS approach, the importance 
underlined by Tuikka of clear specifications is combined with providing the capability to 
implement and modify virtual prototypes quickly and easily. In the conceptualisation phase 
designers need to be able to rapidly modify both the appearance and the behaviour of the target 
device. Designers can then explore different options in order to provide the best solution for the 
virtual device. The selected virtual prototype can then be used to define accurate requirements 
and specifications of the target product. 
Schaaf and Thompson [54] illustrate two system configuration developments that benefited 
from a virtual prototyping approach in the conceptualisation phase. The examples presented are 
the development of an electric gun concept for a ballistic missile defence application and of a 
Chapter 2 Virtual Prototyping 
small waste remediation facility. Virtual prototyping provided, in those applications, the means 
for rapidly developing system concepts and analysing them for general feasibility. In the above 
mentioned examples the expensive construction of physical mockups was replaced by virtual 
prototypes. The authors show, for example, how the combination of a graphical model, created 
in about twenty hours by an engineer working on a desktop computer, and technical data sheets, 
are used to demonstrate the feasibility of the electric gun. The capability of incrementally 
adding details into virtual prototypes as required to support the immediate needs. 
2.3.2 Virtual Prototype as a Form of Communication 
A virtual prototype is a form of communication that can reduce the ambiguity of natural 
languages and overcome possible language barriers. It facilitates communication between 
different engineering disciplines. Simulation and debugging of components, as indispensable 
ways to test systems or subsystems, are understood by people with technical backgrounds. It 
would be extremely tedious for an art designer or a marketing person to understand a VHDL 
simulation. This lack of communication can cause misunderstandings inside a team, but 
especially among the wide range of people that are involved in the manufacturing of an 
electronic product. There are a large number of people that contribute to the development and 
marketing of an embedded system, and they have their expertise in very different fields, 
including hardware engineers, software engineers, designers, systems engineers, architectural 
engineers, marketing teams, manufacturing companies, investors, and other stakeholders. 
Figure 2-9 Virtual Prototyping actors 
- 30 -
C" apter 2 Virtu a I Prototypillg 
Figure 2-9 shows the heterogeneous nature of the people involved in the design of an electronic 
device. The virtual prototype in the centre of the picture represents the common visual 
reference provided to the stakeholders. Without the aid of virtual prototyping, communication 
between the people involved is achieved by drawings and WTitten documents in a natural 
language. As described in [55, and 56], languages though can be very ambiguous. Virtual 
prototyping with its graphical and interactive nature allows the visualisation of the virtual 
device without the use of natural languages or technical si mulation data. Users can understand 
the target device by interacting with the virtual prototype, by pressing buttons and viewing 
changes on the display, without the need to read documents or view simulation results. The 
virtual prototype can therefore be used to facilitate communication between different 
disciplines. 
In addition to enhancing communication between different disciplines, the research work 
conducted by Tuikka and Salmela [57] in the development of WebS ham an [14] explored the use 
of virtual prototypes in the collaboration of dispersed teams or individuals over the Lntemet. 
Figure 2-10 WebShaman Interface [s8[ 
Figure 2-10 shoWS a Screens hot of the WebShaman interface. This tool allows the same three 
dimensional virtual prototype (a virtual pen-phone in the picture) to be viewed simultaneously 
by multiple users who are geographically disper ed. The window on the left of the interface is 
used to visualise the nodes and modify the virtual prototype. Modifications made by a user are 
- 31 -
Chapter 2 Virtual Prototyplng 
instantaneously seen by other users. This allows the collaboration of users on the design of a 
product or concept. 
Tuikka and Salmela [57] examine modern product development processes and the difficulties of 
communicating a design over distance. Cooperation between product designers with different 
background knowledge and expertise is necessary. The difficulties when trying to communicate 
a design are summed up by the authors in four basic questions: 
 What will it be? (design object). 
 What is it? (designers understanding), 
 What has been done? (design process). 
 Why? (rationale design). 
Web Shaman is a server/client application that uses Java applets and VRML format for the 
virtual prototypes. The application enables designers to work synchronously on the same 
virtual prototype and publish different versions of the same prototype which can later be used 
for reference or comparison. 
The ViPERS environment does not provide tools to enable designers to work synchronously on 
the same virtual prototype but considers the option as a future enhancement for the 
environment. In the context of ViPERS. the synchronous communication of designers is 
considered as an interesting but not essential part. Models can be distributed and modified 
separately by designers and changes can be easily tracked for this purpose. 
2.3.3 Interface Design 
Today's handheld electronic devices rely heavily on interfaces. Complexity is growing as well 
as the variety of users that buy these products. The people using these products can vary from 
experts to people with no technical knowledge. Especially for the latter category certain 
products need to hide their functional complexity behind friendly interfaces. Mobile phones can 
be used as an example. The use of mobile phones has become so wide that certain 
manufacturing companies have built their success on their easy-to-use interfaces. A large 
number of people use mobile phones. many of whom are not willing to read a user manual in 
order to learn how to use the device or control certain functions. Friendly interfaces enable the 
users to exploit the possible functions offered by the device without a steep learning curve. 
- 32-
Chapter 2 Virtual Prototyplng 
Complex interfaces do not allow the user to easily access all the functionality provided by the 
device; this leads to a loss in the value of the product. As outlined by Preece et al [59] video 
recorders are a common example of devices which often offer a considerable amount of 
functionality which is badly interfaced with the user. Consequences have been that users only 
rely on the traditional and basic use of the device (play, rewind, record, etc.). 
Virtual prototypes can be used to test the product before any detailed implementation has 
started. Teams with different backgrounds can join efforts to work on the design of the product. 
Interfaces, functionality and physical design can be discussed and modified. Changes can be 
introduced quickly in the design. The added value is that almost immediately designers and 
engineers can modify the model and test different options. 
2.3.4 Performance Analysis 
Performance analysis is possible where the syntax of the language describing the functional 
behavioural model provides the possibility of inserting parameters such as delay. Designers can 
set time delays in the system and subsystems and test the usability of the virtual prototype. 
From analysing the interaction of the user with a device it is clear that certain delays for 
performing an operation are unacceptable while others are not. 
An important issue related to performance analysis is explored by Thorn in [34]. The study 
relates to the speed at which the display updates when a user interacts with a virtual prototype 
during a simulation. As shown in Figure 2-11, delays from event to response in the order of 300 
milliseconds or less, appear to the user to be instant. If these delays increase to 500 
milliseconds or more the user will be aware of the delay, which would affect the user 
impression of the behaviour of the product. The material explored by Thorn enforces the need 
for speed during the simulation of a virtual prototype. 
- 33 -
'sluggish' 
Delay as 
perceived 
by user 
'Instant' 
..aOO ms 
Chapter 2 Virtual Prototyplng 
Actual 
Response 
Delay 
Figure 2-11 Relation between perceived and response time for event processina. 
Source: Thorn (34) 
2.3.5 Usability tests 
Usability tests are supported by HeI techniques and involve the exploration of the interaction of 
a potential user with a device in order to understand issues related with the product and its 
usability. The applicability of virtual prototyping to usability testing is widely discussed by 
Kuutti et al [60]. Kuutti et al describe how three dimensional virtual prototypes can be applied 
to usability testing and concept validation over the Internet. A set of concerns and issues are 
taken into consideration since obvious physical differences are present when testing a product 
over a network. The traditional approach usually envisages a user testing a product in the 
presence of another person gathering information about the test or while being filmed on a 
camcorder that records the actions and responses of the user. The aim for Kuutti was to 
establish if virtual prototyping is fit for usability testing over the Internet. A case study is 
presented where three ways of gathering user input during a simulation test were set up; the log 
of the manipulation of the VRML file, the log of action on the Web page, and the comments and 
answers of the users. Based on the test, Kuutti established for what purposes virtual prototypes 
can best be applied in usability testing. Kuutti outlines the advantages and disadvantages of 
using virtual models over traditional models; some of the advantages are: 
- 34-
Chapter 2 Virtual Prototlplng 
 The traditional approaches uses two separate models, one for the physical prototype and 
one for the interaction. The virtual prototype, instead, is one model that describes the 
entire system 
 Photorealistic images can be used in virtual prototypes to make them look very 
authentic 
 Virtual prototypes can be distributed around the world through the Internet 
 Large numbers of test subjects can be used for eliciting feedback 
Some of the drawbacks however, are: 
 Virtual prototypes cannot be touched and therefore features such as the real shape and 
its weight cannot be estimated 
 Virtual prototypes have limited capabilities with respect to evaluate physical 
ergonomics 
 The user does not operate the model directly but does it though a computer. 
 Virtual prototypes distributed on the Internet provide no interaction between the users 
and evaluators and therefore there is a limited control over the test situations. 
As explored by Kuutti, usability tests can be applied to virtual prototypes with considerable 
success. The material presented demonstrates the feasibility and the possible utilisations of 
virtual prototypes in usability testing. The ViPERS approach takes into consideration the 
discussion presented in this section and adopts techniques such as recording user's actions for 
usability testing. Further details of usability tests in the ViPERS context are given in the next 
section. 
2.3.6 Marketing 
One of the possible applications of virtual prototyping is to enhance the marketing of a product. 
A very comprehensive exploration of the relation between virtual prototyping and marketing is 
given by Leppala et al [61]. Leppala et al investigate and discuss how virtual prototyping can 
be used to explore product features, predict the market response, enhance creativity of 
individuals and teams, and be used for the sharing of knowledge. They present some 
considerations that need to be taken into account when designing new products or modifying 
- 35 -
Chapter 2 Virtual Prototyplng 
existing ones and show how virtual design can be used to improve it. Finally they explore how 
the different applications of virtual prototyping can benefit the marketing and business side of 
electronic product development. The work presented by Leppala et al is considerably linked to 
the analysis made by Kerttula and Tokkonen [47] on the changes in the electronics market 
which have caused three main trends in the business demand: 
1. A need for user satisfaction in order to stay competitive in the market 
2. The adoption of effective communications for a multi-domain development 
3. An effective approach for dispersed development teams in organizations and product 
development. 
One way that virtual prototypes can be used to enhance the marketing of a product is by being 
capable of being distributed through the Internet to stakeholders or potential users; instant 
feedback can be obtained and evaluated by marketing teams and engineers. Feedback can be 
related to any feature of the virtual prototype, including appearance, functionality, GUI, etc ... 
Feedback from customers can be obtained directly or indirectly. A direct way involves for 
example the user testing the virtual prototype and then answering questions about its 
functionality or appearance. An indirect approach could be set up by recording into a log file 
the actions of the user interacting with a virtual prototyping as described by Kuutti et al [60]. 
Designers and He experts can then analyse the log file and evaluate human-machine 
interaction issues. At present the ViPERS approach provides support to distribute the virtual 
prototypes over the Internet for usability testing. Based on the feedback gathered from the tests, 
alternative models can be easily implemented but no tool is provided to allow users to 
dynamically modify the appearance or behaviour of the virtual device. Manuals for the virtual 
device could be obtained in the ViPERS framework by recording clips of simulations of the 
virtual prototype. 
2.4 Requirements lor Virtual Prototyping Environments 
This section explores a list of requirements for virtual prototyping environments which were 
defined in previous research efforts [62, 63]. A virtual prototyping environment is a framework 
which allows the implementation and simulation of virtual prototypes through software tools 
and services. Each requirement will be discussed and put in the context of the ViPERS 
approach. Finally other requirements will be outlined which were taken into consideration for 
the design of the ViPERS virtual prototyping environment. The requirements are: 
- 36-
Chapter 2 Virtual Prototypl", 
1. Functional and behavioural simulation. The amount of software in embedded handheld 
electronic systems is relentlessly increasing thus providing more and more functionality 
to the systems. To deal with the large amount of software development, simulations of 
the functionality and behaviour need to be made. The ViPERS framework allows the 
modelling of the functionality and behaviour at different levels of abstraction. High 
abstraction levels allow early evaluation of the behaviour of the system. Connection to 
UML modelling tools is provided to allow a possible route to embedded software. 
2. Simulation of user interface logic. Salmela and KyllOnen predict [62] that future 
electronic devices may have multimodal user interfaces in order deal with the extended 
functionality provided by the devices. Means need to be provided in order to design 
and test users interfaces and possibly enable designers to implement several candidate 
solutions. In the ViPERS approach graphical user interfaces are implemented and 
modelled like any other graphical component belonging to the virtual device and their 
behaviour is driven by the underlying functional model. The ViPERS framework 
provides the capability to easily put together virtual prototypes and modify their 
interfaces to test different solutions. 
3. Rapid construction of simulation models based on reusable components. One of the 
main benefits of virtual prototyping is the ability to quickly create several candidate 
solutions in search of the optimal design. In order to maximise this process the virtual 
prototyping framework must provide the capability to reuse components as much as 
possible. In the ViPERS framework the reuse of components applies to both the 
graphical and the functional models. Graphical components are stored in libraries and 
can be dragged and dropped in the workspace to create graphical models. Elements that 
make up the functional models are also stored in libraries and can therefore be reused 
and modified for different designs. 
4. Distributed simulations. The distribution of simulations is needed for several reasons. 
Complex functional models might require too much processing power and would slow 
down the simulation of the virtual prototype to non realtime performance. Distribution 
can be applied to speed up the simulation. Distribution allows spreading the processing 
power over several machines and improves the overall performance of the simulations. 
Functional models might require simulation engines which might not be available on 
the client side. Additionally, complex functional models might require long times to 
download on the client side and it might be desirable to hide their implementations from 
the client. Distributed simulations allow the functional model to run on the secure 
- 37 -
Chapter 2 Virtual ProtolYp'''' 
server while the graphical model is displayed on the client side. This improves the 
security of the distribution. For example, it can be used to allow a third party to test the 
functionality of the product without releasing details of the implementation of the 
system or subsystems. The components of the ViPERS environment communicate 
through TCP/IP sockets and conform to an XML-style communication protocol. A 
different approach for distributed simulations is described by Salmela and KyllOnen 
[62] where virtual components are used as interfaces or wrappers for external 
simulations or tools, through the use of Java classes and the Java Native Interface (JNI). 
5. Platform Independence. Salmela considers a necessity the ability to download and use 
the virtual prototyping tools on different workstations. In the ViPERS framework the 
platform independence was not considered a requirement. The tools were implemented 
using UML thus allowing easy reimplementation for different platforms. Further 
considerations are explored later in this section. 
6. Networked development. Salmela believed that networked virtual prototypes are 
needed to support the communication and collaboration between people involved in the 
design of a product. The ViPERS framework allows the collaboration of designers in 
an asynchronous way. This means that designers can use the virtual prototype to 
communicate changes and collaborate with each other but cannot work simultaneously 
on the same virtual prototype on different machines. Either designers use the same 
machine and work on the same prototype or they have to work on the virtual prototype 
separately and pass it to one other. 
7. Layered architecture. By layered architecture Salmela refers to the separation of the 
representation of the user interfaces of the product from the representation of its 
functionality and behaviour. In the ViPERS framework the layered architecture is 
applied between functional and graphical models and internally. Both graphical and 
functional models can be implemented hierarchically in the ViPERS framework. 
Some of the requirements mentioned above constituted guidelines for the design of the ViPERS 
environment. The only requirement which was not satisfied is the platform independence. The 
central application (VDM) is Microsoft Windows based. The accurate design of the application 
in UML allows easy reimplementation for different platforms. The requirement was not 
satisfied because of the desire to use C++ as the principal implementation language. C++ was 
preferred over platform independent languages such as Java because of its considerably better 
performance. 
- 38-
Chapter 2 Virtual Prototyplng 
In addition to the requirements mentioned above, and explored in past research efforts, other 
requirements such as the open architecture, the photorealism of graphical model and the route to 
hardware, were considered in ViPERS. 
The ViPERS framework provides an open architecture which allows external tools to connect to 
the framework. In a virtual prototyping environment both the graphical and behavioural model 
need to be modelled and simulated. A combination of several tools needs to be employed in 
order to achieve this. Developing proprietary tools can be very time consuming. In the ViPERS 
framework external tools, employed for modelling and simulating models can be connected to 
the main framework and communicate with other models during simulations. This reduces the 
need to develop proprietary tools if commercial offerings are available. 
In the ViPERS approach different options for the modelling and simulation of models are 
offered to designers in different stages of the design flow. The designer is provided with the 
capability to choose different approaches in order to maximise hislher expertise. The choice in 
the approach applies to both the graphical and the behavioural modelling. For the graphics, 
designers can choose whether to implement two dimensional or three dimensional models and 
whether to implement virtual worlds or not. For the behavioural modelling the ViPERS 
framework provides support for different abstraction levels and different programming 
languages. In addition designers can create their own links to connect other external tools to the 
main framework. 
In previous research efforts virtual prototyping has been treated as a separate process and used 
mainly to validate concepts. In the ViPERS approach virtual prototyping is integrated into a 
design methodology for SoC development (based on SystemC). For this reason the framework 
is required to support the entire process and not just the implementation and simulation of high 
level virtual prototypes. 
The ViPERS framework provides the capability to implement photorealistic models. In the 
ViPERS approach, the photorealism of graphical models is considered a requirement rather than 
a preference, even after considering the possible overheads introduced. One of the main aims of 
virtual prototyping is to eliminate or at least reduce to a minimum the imagination gap between 
stakeholders. This can be achieved by photorealistic models and not by crude graphical models. 
Another advantage of photorealistic models is that they provide the means to accurately model 
the appearance of a target device. The accurate modelling of the graphical qualities of a device 
can help sell that product more effectively. 
- 39-
___________________________________________________ ~C~h~a~p~t~e'~2~V~/r~t~u~a~/~P~r~o~t~o~tyuP~/~n~g 
2.5 Benefits of Virtual Prototyping Tools 
Virtual Prototyping tools provide a considerable number of benefits, some of which will be 
discussed in details and demonstrated in this thesis. This section will present the benefits of 
virtual prototyping tools for rapid what-if evaluation expressed by McLeod in [38]. The work is 
based on two industrial case studies, with Chrysler and Boeing, which used virtual prototyping 
to advantage. McLeod explores the trend towards consumer demand for products with low 
prices but high quality and the consequent increase in consumer demand for customisation. Old 
products are constantly being replaced by new or modified versions in order to deal with the 
shrinking of the life cycles of products. As explored in the introduction of this thesis one of the 
challenges in the SoC world is the constant tightening of the time-to-market. Virtual 
prototyping can be applied to the design of target products to explore user needs and provide 
accurate requirements. Without the adoption of virtual prototyping, products might not be 
specified accurately from the early stages and this usually results in consequent modifications to 
the specifications of the system. This can heavily affect the time-to-market. The ViPERS 
approach involves the risk that the implementation of virtual prototypes could potentially 
increase the time-to-market of a product. But we consider this is rarely likely to be the case 
since it is only likely to apply if, in a traditional approach, the requirements of the product 
would not be modified during the design and development of the product. In contrast, virtual 
prototyping provides the tools to design better products which would therefore have more 
chances of having success in the competitive electronics market. 
Another benefit discussed by McLeod is that a virtual prototyping approach allows early testing 
of the target product. CAD models can provide kinematic and mechanical simulations of the 
target products. These models can be used to test the behaviour of the products in conditions 
which are not feasible or difficult and costly in laboratories. In the ViPERS framework, which 
focuses on electronic handheld devices, physical and graphical interfaces, as well as functional 
and aesthetic qualities can be tested from the earliest stages of the design. In those stages no 
implementation of the device has been done and the features of the target product can easily be 
changed or modified in order to test alternative solutions. 
As described by Zorriassatine et al [64] for mechanical product development usually more than 
one physical prototype is needed in order to find an optimal solution. Physical prototyping is a 
lengthy and costly process but it is, in most cases, a necessity. Virtual prototyping does not 
eliminate the need for physical prototypes but reduces it. Virtual prototypes can be cheaply 
constructed and multiple solutions can be tested in order to minimise the risk associated with 
physical prototypes. Ideally, when the optimal solution is found through the use of virtual 
- 40-
Chapter 2 Virtual Prototyplng 
prototyping only one physical prototype will be constructed. In the ViPERS framework the 
desire is to accurately model the physical and behavioural features of the target products, in 
order to obtain a solution which is as real as possible. The process of creating virtual prototypes 
in the ViPERS framework is fast and inexpensive. 
McLeod additionally underlines the benefits of distributing virtual prototypes over the Web. 
This allows their distribution around the world. Customers and stakeholders can view and test 
the design before or after its production. Team members who might be geographically 
dispersed usually communicate and discuss a product through written and spoken languages, 
sketches and physical prototypes. All these approaches can present issues when there are 
geographic distances. Virtual prototyping allows real-time interaction of team members and 
certain software tools [42] also allow multiple designers to work concurrently on the design ofa 
virtual device. 
McLeod also explores arguments such as the loss of 50% to 70% loss in profit margin in late 
release on the market of products and the rule of J(I [38] law applied to the cost of fixing an 
error late. Virtual prototyping tools can be applied to protect the profit margin by reducing 
time-to-market and development costs through an accurate testing of the target device. 
Other benefits of virtual prototyping mentioned by McLeod [38] are 
o They unravel design complexity. 
o They reduce the scope and scale of engineering changes 
o The help to engender a right-first-time attitude 
o They enables full participation by all interested parties in the product 
development area 
In ViPERS the concern is to provide designers with a methodology and tools which support 
enhanced modelling of behaviour and appearance of handheld devices. Enabling designers to 
design better products is the key issue. 
4 The cost of fixing a problem increases 10 times when it is found in the physical layout stage, 100 on the 
shop floor, and 1000 times if it is found by a customer. 
- 41 -
Chapter 2 Virtual Prototypin8 
2.6 Non-Commercial Virtual Prototyping Environments 
This section will explore non-commercial virtual prototyping environments which were the 
result of research efforts in the field of virtual prototyping. The environments will be discussed 
and compared to the ViPERS framework. 
With exclusion of commercial virtual prototyping tools, which will be discussed in the next 
section, there are two non-commercial prototyping environments which will be explored in this 
section. They are: 
 VRP [14] 
 The Virtual Instrument Toolkit 
2.6.1 VRP 
The VRP environment was built as part of the research in the VRP project and it is described by 
Salmela and KyllOnen in [62]. 
The VRP environment is made up of four main components and it is shown in Figure 2-12. The 
components of the VRP environment are: 
 VRP builder 
 VRP engine 
 VRPviewer 
 VRP creator. 
VRP creator is used to model the graphical prototype. Graphical prototypes are created as CAD 
models and then converted to VRML. The VRML file does not include dynamic features at this 
stage. The file is then loaded into the VRP creator where the various nodes of the VRML file 
are given its dynamic features where needed. 
- 42-
Chapter 1 Virtual Prototyping 
30 CAD Tool 
Virtual 
Components 
(J va) 
Figure 2-12 Smart virtual prototypes with VRP. 
Source: Salmela and Kyllonen 162) 
Web Page for Virtual 
Prototype ~HTML) 
Virtual Prototype 
Model (VRML 2 . 0) 
VRM L Prototype 
Activator (Applet) 
mtplOY Simulation 
Model (Java Objects) 
The VRP environment is based on Java while the ViPERS framework is based on C++. 
Another main difference with the ViPERS environment is in the graphics. CAD models 
implemented using graphical tools are translated in VRML. Translation to VRML models can 
cause a considerable increase in the size of the polygons and therefore the size of the file 
containing the mode\. Usually the code generated needs to be cleaned up. Designers need to 
add interactivity to those nodes of the VRML model which the user will interact with at 
simulation time. In the ViPERS approach it was mandatory to enable quick and clean 
construction of models, which would be small in size and easily understood. The choice was to 
use two dimensional graphical components which can be created using any graphical editor and 
then simply imported into the VDM too\. An XML-style file is generated from VDM which 
describes both the graphical model and its interactivity. This allows easy assembling of the 
graphical model. 
2.6.2 The Virtual Instrument Toolkit 
The Virtual Instrument Toolkit is a toolkit developed from the research conducted in the 
University of Newcastle upon Tyne to demonstrate the relation between virtual prototyping and 
the Web. Zubillaga and Allen [65] describe how the toolkit is used to design a portable 
appliance tester. The toolkit is divided into four main components: 
- 43 -
Chapter 1 Virtual Prototyplng 
1. VRWorkspace. This is an environment where an instrument can be placed. wired and 
tested. 
2. Clipboard. This is an FSM programmable multimedia aid system 
3. Device Editor. This is a graphical tool. The designer can drag and drop buttons and 
change attributes of basic graphical objects. 
4. FSM Editor. This is a tool for the development of finite state machines used to control 
the functionality ofthe virtual prototype. 
In [65] the author compares a typical prototype design sequence used in instrument design and 
development with a new virtual product prototype design where the instrument can be simulated 
early in the cycle without having to wait for later stages. 
In the ViPERS environment there is a clear desire to reuse existing tools and maximise user 
expertise wherever possible. The open architecture of VDM allows connection to external 
software. In the ViPERS environment the role of the FSM Editor is indirectly provided by 
libraries which are used to link to state machines. The state machines can be implemented using 
any state machine editor. Another main difference lies in the quality of the graphics. The VDM 
employs high quality photorealistic models. 
2.7 Industrial Virtual Prototyping Environments 
This section presents an overview of the virtual prototyping tools and environments available in 
on the market. Each tool will be described and features outlined. 
Virtual Prototyping can have a major role in the design and development of handheld electronic 
products but still not many prototyping tools have been developed. This section of the thesis 
will discuss those tools which enable users to prototype at least the functionality and the 
physical design of the product, and were developed specifically for virtual prototyping. 
2.7.1 Cybelius {42J: 
Cybelius Software [42] is a virtual prototyping environment for the design and display of 
electronic and telecommunications products. Cybelius is the result of several years of 
collaborative research between the research company VTT, the manufacturing company Nokia, 
and other partners. Cybelius was developed for the design of smart virtual prototypes. 
-44 -
Chapter 2 Virtual Prototyplng 
Cybelius Software is composed of two main components: Cybelius Maestro and Cybelius 
Server. Cybelius Maestro is a Java-based platform for the development, simulation and testing 
of electronic products. It has an open architecture that provides connectivity and a plug-in 
framework; both external applications and custom plug-ins can communicate with the Cybelius 
environment. Even though Maestro is a Java-focused platform, software components written in 
C/C++ can be integrated into its simulation models. The behaviour of the models is described 
through hierarchical, component-based state machines, based on UML. The appearance of the 
product instead is a combination of the GUI (graphical user interface) and the PUI (physical 
user interface). The GUI is implemented through an editor which allows the modelling of the 
display (pixel, segment, and colour displays). The PUI models are bitmap-based 2D models of 
functional components such as the buttons. 
There is also a wizard for generating code for the creation of executable simulation models for 
selected target platforms. By default it supports J2SE and JDK 1.1 Applets but extensions can 
be made. 
Cybelius Conductor is a server platform which allows the sharing of 3D content among 
designers. 
2.7.2 A/tia [66J: 
The prototyping environment by Altia provides a graphical tool for the development of 
graphical models of the target electronic products. It does not provide tools for the development 
of functional models but it provides the means to communicate with them. 
Altia environment consists of three main components: 
1. Altia Design: this is an environment for the development of interactive graphics and 
embedded GUIs. 
2. Connections: they are modules to connect the graphical model to external applications 
or simulation models. Examples of external applications supported by Connections are: 
Simulink, Rhapsody, Rational Rose RealTime, etc ... 
3. DeepScreen: this is a code generator that turns the proto typed GUI into deployable code 
for the target real-time operating system (RTOS). 
-45 -
Chapter 2 Virtual Prototyplng 
2.7.3 And [67J: 
CodeFrames from And provides a virtual prototyping environment for graphics manipulation. 
Component drivers and a graphics library provide the means for the designer to create the 
virtual prototype and add functionality to it. Designers can create graphical components using 
any graphics software that generates .BMP files. Automatic code generation in ANSI Censures 
that the application code can be ported to the target hardware. The virtual prototype can be built 
in an executable .EXE file and distributed for marketing purposes. CodeFrames currently 
includes drivers for keypads, buttons, ADCs, UARTS, EEPROM and FLASH memories, 
temperature sensors and many common LED and LCD displays. 
2.7.4 E-sim [68J: 
This is a graphical editor that allows designers to create graphical components or reuse existing 
ones from its library. Graphical components are parameterised and can therefore be modified 
by the user. The physical model of the virtual prototype is achieved by the composition of 
several graphical components together. A logic editor allows the addition of functionality and 
interactivity to the graphical model, which can be viewed and modified through its state chart. 
The prototype development tool is used to create virtual prototypes of embedded systems, with 
an emphasis on modelling the man-machine interfaces of the system. It runs in a Windows 
environment and can provide automatic code generation (C code). The generated C code and an 
embedded microkemel provided by the tool allow the application code to be run on a real 
embedded system platform. 
A comparison between the ViPERS environment and the different tools described above is 
given later in this thesis. The intention is to provide details of the ViPERS approach and 
environment before exploring the differences. 
Chapter 3 
Modelling Embedded Real-
Time SoCs 
Chapter 3 Modelling Embedded Real-Time SoCs 
MODELLING EMBEDDED REAL-TIME SaCs 
his section explores the proposed design flow for embedded real-time SoCs. It will 
focus on two modelling languages, SystemC and UML. Both will be discussed in the 
context of a design flow that models electronic systems from their requirements 
analysis to their final implementation. The chapter is divided into two main sections, one 
dedicated to SystemC and one to UML. This chapter will describe SystemC and its related 
methodology for the design and implementation of SoCs, and then outline how UML can be 
used in the requirements analysis phase in order to provide an accurate functional specification 
of the system to be implemented in SystemC. Consideration will also be given to the possible 
link between UML and SystemC models. 
3.1 Languages to Model SoCs 
The need for fast development of SoCs is creating new challenges for designers, which involves 
a re-evaluation of how the system is specified, partitioned and verified at the system level. In a 
traditional approach hardware and software engineers adopt different languages and tools to 
implement the system. This approach is inadequate and will eventually become impractical to 
deal with the complexity of the systems increasing so fast. One solution is the use of a single 
modelling language that can be used at different levels of abstraction and for both hardware and 
software development. 
Arnout [69] explores system level design languages and defines the driving forces for a 
common design language as: 
-48 -
Chapter 3 Modelling Embedded Real-Time SoCs 
1. SoC designs combine hardware and software components; as shown in Figure 3-1 in 
contemporary (2004) electronic systems there is more software than hardware and therefore 
there is a need for a language that can describe the functionality of both hardware and 
software components. 
2. SoC designs are increasingly incorporating hardware and software intellectual property (IP); 
as shown in Figure 3-1 the amount of IP-reuse in today's systems is considerable and these 
sources need to use a common system level language for modelling. Interfacing IPs 
implemented in different modelling languages can be very tedious and time consuming. 
3. Designs are becoming too complex to simulate in a RTL; the simulation of an entire system 
implemented at the register transfer level can be very slow and errors detected at this stage 
can cause considerable development delays and require extensive effort to fix. System level 
simulations allow faster simulations and behavioural testing of the system before low level 
implementation. 
4. System level design is a necessity; multimillion-gate designs need to be implemented 
successfully the first time and this requires accurate system level planning. 
 Software 
I-- ~r~~o- - .1 
i 66 0/0  Reuse 
I Memory I 
I I 6% Glue 
i I 6% New 
i I Hardware 
Figure 3-1 Hardware and Software partitioning percentages. 
Source: Arnout (691 
Several languages have been, and are, competing to provide designers and engineers with 
languages that can provide support from system level to RTL level. 
- 49 -
Chapter 3 Modellillg Embedded Real-Time SoCs 
As suggested by Amout in [69] and Habibi and Tahar in [70] system level languages (SLL) can 
be divided into three main categories; those based on developing an entirely new language 
(Rosetta [7\], SuperLog [72]), those based on hardware description languages (HOL) such as 
VHOL and Verilog (System Verilog [73], VSPEC[74]) and those based on software languages 
and methodologies such as C, C++, Java and UML (CynLib [75] , SpecC [76], Handle-C [77] , 
HardwareC [78] , SystemC, JHOL[79]). Figure 3-2 shows the capability of three languages, one 
from each category (SystemC, Verilog and Superlog), to provide system level design, 
verification and RTL design. 
SystemC Verilog SuperLog 
~ - -
System Level design Excellent Very poor Good 
fit fit fit 
Limited use - I-- -- I-- -
Verification Excellent Poor 
fit fit Good 
fit - I-- -
- I-- -
RTL Design OK Excellent SUDerset 
fit fit Excellent fit - I-- -
Figure 3-2 Language comparison. 
Source: Baird 180) 
Habibi and Tahar suggest in [70] that short term solutions will come from languages that push 
up from, or extend, HOL methodologies such as Verilog and VHDL because they do not require 
a radical shift in methodologies and allow the retention of legacy code. Medium range solutions 
instead, will be the result of high level languages, such as C++, which provide hardware 
capabilities. Languages such as C++ which were intended for software design can take two 
approaches to providing hardware support [8\] . One is by syntax extension which requires the 
development of separate compilers, simulators, and synthesis tools. The second approach, such 
as the one adopted by SystemC, relies on class libraries to model the hardware aspects; this can 
be achieved by languages that are extensible such as C++ and Java. Finally, long term solutions 
will come from languages which were specifically designed for system level design. The 
problems inherent with new languages designed for system level is that they need to overcome 
significant challenges to move designers to new languages. Additionally design tools, including 
simulators, will need to be developed specifically for those languages. 
Kogel and Bussaglia [82] explore a set of requirements for system level design which the 
language of choice will need to satisfy. The requirements are: 
- 50-
Chapter 3 Modelling Embedded Real-Time SoCs 
 High simulation speed and modelling efficiency 
 Separation of timing and behaviour 
 Separation of interfaces and behaviour 
 Incorporation of hardware semantics 
 Seamless transition from system level to gates level 
 Intuitive visualisation 
From the analysis presented above and the diagram shown in Figure 3-2 it is clear that both 
approaches, extending HOL languages and developing new languages for system level present 
major concerns. System level languages which are based on HOL, provide limited advantages, 
and compared to other approaches, they offer limited support for system level design and 
software development. In relation to the discussion of Figure 3-1, the choice of a hardware 
description language to describe systems which are mainly software would have been very 
limiting in the ViPERS framework. Other drawbacks of this approach are that HOLs provide a 
very low level view of the system. This implies that by the time a system is described in a HOL 
its design is already committed to a specific architecture. The use of a new language specific to 
system level design instead could provide considerable advantages compared to other 
approaches but no solution has been widely adopted to date (2004). This implies limited tool 
support, which is made worse by the fact that design tools and simulators need to be developed 
specifically for these languages. Another major drawback of this approach is that designers 
must be convinced to move to a completely different language and methodology. A slight 
modification to this approach is the one suggested by SuperLog (a superset of Veri log), which 
combines Verilog with C and does not require a shift in methodologies and allows groups to 
retain legacy code. SuperLog holds promises for the future but it still does not have wide 
industry support as outlined by Habibi and Tahar [70]. 
From the above considerations, the approach adopted in the ViPERS methodology is based on 
software languages which rely on class libraries to model the hardware aspects of the systems. 
As previously discussed, this can be achieved by languages such as c++ and Java, which are 
extensible. As outlined by Arnout in [69], compared to Java, CtC++ offers a greater simulation 
speed, and unlike Java it does not prevent access to hardware which makes it suitable for 
writing initialisation code and device drivers. 
- 51 -
Chapter 3 Modelling Embedded Real-Time SoCs 
The language chosen for the modelling ofSoCs in the ViPERS approach is SystemC. SystemC 
is based on C++ which is already used by many software designers and therefore fits with the 
nature of to day's (2004) electronic systems. C++ is a widely used language and benefits from a 
very wide industry support. As shown in Figure 3-2, SystemC is excellent for system level 
design and verification and also provides good support for RTL design. Additionally as 
identified by Sanguinetti [83], 'C++ design environment can be made familiar to Verilog or 
VHDL designers' . SystemC RTL level code closely resembles RTL level VHDL but with C 
syntax. Hence hardware designers can readily adapt to it. Other factors which encouraged the 
use ofSystemC are that it is freely downloadable and it is widely supported by industry. 
Further details of SystemC are given in the next section while section 3.2.3 explores the 
comparison of the SystemC approach with a traditional approach to system level design. 
3.2 SystemC Basics 
SystemC is a C++ class library and a methodology. It can be applied for system level modelling 
and executable specifications. SystemC is currently being supported and advanced by an 
independent not-for-profit organisation known as the Open SystemC Initiative (OSCI). The 
OSCI consists of a number of major Electronic Design Automation (EDA) companies, 
universities and individuals. As is shown in Figure 3-3, SystemC is built on C++ which is a 
widely used programming language. The SystemC core language provides a set of modelling 
constructs for structural description, concurrency, communication, and synchronisation. 
Standard Channels Methodology-Specific 
For Various MoCs Channels 
Kahn ProaIss Network, Master/Slav. Ubrary, etc. 
StatiC Data Row, etc. 
Elementary Channels 
Sional , Timer, Mut  , Semaphore, fifo, etc. 
Core language Data Types 
Modules Logic Type (OlXZ) 
Ports Logic Vectors 
Processes Bits and Bit Vectors 
Interfaces Arbitrary Predslon Inteoers 
Channels fixed Point Inteoers Intaoers 
Events 
C++ language Standard 
Figure 3-3 SystemC Language Architecture. 
Source: SystemC-Language Reference Manual (12) 
- 52 -
Chapter 3 ModellillG Embedded Real-Time SoCs 
SystemC is a C++ based modelling platform that supports different levels of abstraction, from 
system level, through behavioural to register transfer level. As described by Grotker et al. [10] 
SystemC consists of a class library and a simulation kernel which provide a series of 
advantages, the most important being the common environment for co-design, IP reuse, and test 
bench reuse across different levels of modelling abstraction. 
Panda [84] illustrates which constructs of SystemC make it suitable for both hardware and 
system level design. These constructs are shown in Figure 3-4. 
Modules 
Signals and Ports j 
Methods 
Threads 
4-state logic 
Bit and Bit Vector I 
Fixed and Arbitrary 
PreCision 
Figure 3-4 Hardware and System Level Modelling Constructs in SystemC 
3.2.1 SystemC Design Flow 
Figure 3-5 shows a simplified diagram of the SystemC design flow [85]. The first step of the 
design flow involves the creation of a SystemC model. This model provides an executable 
specification that can be used to explore and examine the system. The level of abstraction of 
this model should be kept high. High levels of abstraction imply that the model is easier to 
implement and faster to simulate than a corresponding HDL-based model. 
- 53 -
Chapter 3 Modelling Embedded Retll-Time SoCs 
SystemC model 
Simulation 
Refinement 
Synthesis 
Rest of Procels 
Figure 3-5 SystemC Design Methodology. 
Source: SystemC-User's Guide (13) 
The refinement process, described in more detail in the next section, is achieved by using the 
facilities provided by SystemC such as signals, ports, clocks, etc. The final step in the SystemC 
design flow is the synthesis of code. The advantages that this design flow brings to hardware-
software co-design are multiple. Hardware and software engineers can work in parallel. 
Software engineers do not need to wait for an RTL model of the hardware to verify their 
implementations. The software blocks can be verified by replacing their corresponding high 
level block in the system model. Higher simulation speeds are obtained since both hardware 
and software blocks are implemented and modelled in the same language and use the same 
simulator. The typical simulation methodology for SystemC is shown in Figure 3-6. 
- 54-
SystemC Models 
-System Level 
-Behavioural Level 
-RTL Level 
Chapter 3 Modellillg Embedded Real-Time SoCs 
c++ Compiler 
Figure 3-6 A typical simulation methodology in the SystemC environment. 
Source: Panda 1841 
3.2.2 The Refinement Process 
The refinement processes associated with both the hardware and software components of a 
SystemC model are shown in Figure 3-7. 
The hardware blocks refined during the design flow are implemented in several models. These 
models are: 
 UnTimed Functional (UTF) Models. These have no representation of time, but focus 
on transactions and operation order. 
 Timed Functional (TF) Models. These are useful for performance modelling and time 
budgeting. Time is modelled as execution time and clocks are not used to synchronise 
but only to keep the time. 
 Bus Cycle Accurate (BCA) Models. Processes may still contain behavioural code, but 
communication links are cycle accurate, implemented with a bus protocol. 
- 55 -
Chapter 3 Modelllllg Embedded Real-Time SoCs 
 Cycle Accurate (CA) Models or RTL Models. These are clock cycle accurate, and the 
code is synthesisable. 
SystemC 
Abstr. 
Software 
Hardware 
Design Exploration 
Performance Analysis 
HW/SW Partitioning 
Figure 3-7 SystemC Design Flow showing differcnt Icvels of abstraction. 
Source: Holloway ct al(85) 
3.2.3 A Traditional Approach to System Level Design 
As described in [13] a traditional approach to system level design begins with writing a C or 
C++ model of the system to verify the concepts and algorithms at the system level. Once they 
are validated, the parts of the system that need to be implemented in hardware are manually 
converted to a VHDL or Veri log. The approach is shown in Figure 3-8. 
A number ofprob\ems with this approach are outlined in [13]: 
- 56 -
Chapter 3 Modelling Embedded Real-Time SoCs 
 The conversion from C to HDL can introduce errors. The designer writes and verifies 
the C model and then manually translates it into an HDL model. This process can be 
very tedious and error prone. 
 Coherence between system models and HDL models. Once the HDL model has been 
implemented developers only focus on this model. Changes to the HDL model are not 
fed back to the C model. 
 Multiple system tests. Testbenches implemented to validate the functionality of the C 
model cannot be reused for the HDL model without conversion. Designers have to 
convert the C model to HDL, as well as the testbenches. 
 Software refinement. The blocks of the system model which have to be implemented in 
software need to be modified with calls to an as. The refined model is simulated and 
verified with an as emulator. Parts of the code can be reused, but the change in 
abstraction from the system model to an RTOS-based model requires significant manual 
recoding. 
Refine 
C/C++ 
System Level Model 
Verification 
Simulation 
Synthesis 
Instantiation of 
SoC system 
Figure 3-8 System on a Chip design flow. 
Source: SystemC-User's Guide 1131 
C and C++ are the languages of choice for software algorithms and interface specifications 
because they provide the control and data abstractions necessary to develop compact and 
efficient system descriptions. Additionally they are broadly used languages which are widely 
supported by commercial tools. The SystemC Class Library provides the necessary constructs 
- 57 -
Chapter 3 Modelling Embedded Real-Time SoCs 
to model system architecture including hardware timing. concurrency. and reactive behaviour 
that are missing in standard C++. This allows designers to continue to use the familiar C++ 
language and development tools. 
The SystemC design approach offers many advantages over the traditional approach for system 
level design explored earlier in this section. Some of the advantages outlined in [13] are as 
follows: 
 SystemC provides a refinement methodology. With the SystemC approach. the design 
is not converted from C to HDL in one effort but slowly refined in small sections to add 
the necessary hardware and timing constructs to produce a good design. Using this 
refinement methodology. the designer can more easily implement design changes and 
detect bugs. 
 Only a single language is used. The SystemC design flow for SoCs allows modelling 
from system level to RTL in a single language. Models can be implemented at a high 
level of abstraction. Writing at a higher level of abstraction results in simpler code that 
is easier to write and faster to simulate. Testbenches can be reused from the system 
level model with the RTL model. Reusing testbenches gives designers higher 
confidence on the coherence of the refined models. 
3.2.4 Models and Abstraction Levels in SystemC 
SystemC can be used to describe a system at different abstraction levels: untimed functional, 
timed functional, hierarchical, RTL, etc. Furthermore these levels can be mixed: a system can 
contain RTL and untimed blocks in the same design. for instance. Figure 3-9 shows the models 
obtained at the end of each refinement process in a SystemC design flow. Each step is 
discussed below. 
- 58 -
Chapter 3 Modelli"g Embedded Real-Time SoCs 
Untimed 
Functional 
Model 
Timed Functional 
Model 
RTL Model 
Synthesisable 
Model 
Figure 3-9 System Design Flow with SystcmC. 
Untimed and Functional Model - This is the highest level of abstraction that can be 
represented in a SystemC model. It consists of purely C++ algorithms that define the 
functionality of the system. The system is not made of sub-blocks nor is a clock considered. 
The whole system is made of one block that implements all the functionality. This model is 
used by the designer to verify that the system functions as expected. 
Timed and Functional Model - [n this case, an added clock governs the internal sequencing 
of the model. 
Behavioural Model - In this model the sequential algorithms are refined to concurrent 
processes. This refinement process determines the number of lower level modules present in 
the system. For example if the low level modules are small, designers would have more 
partitioning options but there would be more blocks in the system to implement. In the 
behavioural model the system is customarily partitioned in sub-blocks. Usually, object-oriented 
techniques are used to make an optimum partition. The result is a model which implements the 
required functionality by distributing it among different blocks. 
Hierarchical Model- This model is similar to the behavioural model but the communication 
among internal blocks is now implemented. This process is referred to as communication 
refinement. SystemC offers the capability to refine communication mechanisms with the help 
of signals, channels, ports and interfaces. 
- 59-
Chapter 3 Modelling Embedded Real-Time SoCs 
RTL Model - In a register transfer level model every instruction inside an internal block is 
executed in accordance with a clock. These instructions involve data transfer and data 
operations through registers or gates. 
Synthesisable Model- This model is ready to be synthesised. If the designer used instructions 
other than SystemC then these have to be modified to Systemc. The translation from SystemC 
to gates is performed by synthesis programs. 
The different models can be allocated at different levels of abstraction. Figure 3-10 indicates 
the levels of abstraction to which each model belongs. 
3.2.5 Type of Refinement 
System 
Level 
.--__ -..JI~ __ --, Behavioural 
Figure 3-10 SystemC design levels. 
Source: Panda (84) 
Level 
Level 
The refinement process associated with SystemC is described by Holloway et al [85] and shown 
in Figure 3-11. The types of refinement they discuss are: 
- 60-
Chapter 3 Model/i"g Embedded Real-Time SoCs 
 Atomicity Refinement. The first SystemC implementation is typically an algorithm 
which executes sequentially. Atomicity refinement refers to the process of converting a 
sequential program into one that contains concurrently executing processes. As 
described by Holloway et al [85] atomicity refinement should be used to set the size of 
the lowest level modules to balance the complexity of the design and optimisation 
possibilities. 
 Algorithmic Refinement. This is the process of breaking complex tasks into sequences 
of smaller and simpler tasks. The aim is to substitute high level functions with simple 
functions which can be executed by a microprocessor or implemented in hardware. 
 Communication Refinement. This is the process of replacing a primitive channel with a 
refined channel. The interfaces of the refined channel will be more complex than the 
primitive correspondent and will also need refinement. Refinement of interfaces is 
achieved through adapters; by connecting them between the original module and the 
refined channel. 
 Data Refinement. This is the process of replacing abstract data types with data 
structures that can be directly implemented in the target hardware/software. 
c++ Algorithm 
Figure 3-11 Refinement process associated with the SystemC design flow. 
Source: Holloway et al1851 
Figure 3-11 shows the refinement processes which occur when refining a SystemC model. It 
starts from a C++ algorithm which is wrapped into an SC_MODULE (SystemC module) and 
finishes with a cycle accurate model. The same type of refinement process can take place 
- 61 -
Chllpter J Modelling Embedded Red-Time SoCs 
between SystemC models at different levels of abstraction. For example communication 
refinement is applied when transforming the untimed functional model into a timed functional 
model. Equally this refinement is applied when transforming the timed functional model to a 
bus cycle accurate model, and bus cycle accurate to cycle accurate model. Even though the 
concept behind this type of refinement is the same, it is implemented differently in different 
stages. For example the communication refinement applied to a timed functional model adds 
details to an abstract bus model. Communication refinement applied to a bus cycle accurate 
model instead is to add hardware bus details. Another example is the atomicity refinement 
between untimed functional and time functional models which involves breaking the system 
down into several modules. The same refinement when applied between bus cycle accurate and 
cycle accurate models involves separating the control path and the data paths in the hardware 
modules. 
3.2.6 Future ofSystemC 
As illustrated by Swan [86] future directions for SystemC can be divided into two main 
categories. One direction involves the inclusion of new features in the core language and the 
other requires new features to be provided as libraries on top of the core language. The features 
outlined by Swan [86] are: 
1. New features in the core language: 
a. 'Ability to fork and join threads. and automatic thread creation' [86] 
b. 'Ability to interrupt or abort a thread and its children'[86] 
c.  Specification and checking of timing constraints'[86] 
d. 'Support for abstract RTOS modelling and scheduler modelling' [86] 
e. 'Possible support for analogue mixed signal modelling'[86] 
2. New features as libraries: 
a. 'Standardised channels of various models of computation ... ' [86] 
b. 'Libraries to facilitate the development of Testbenches ... ' [86] 
c. 'System level modelling guidelines and library code to help users ... ' [86] 
- 62-
Chapter 3 Modelling Embedded Real-Time SoCs 
d. 'Standard APls for interfacing SystemC with other simulators. emulators. etc.' 
Although SystemC is very powerful for system level design it lacks features desirable for 
modelling software execution. Kunkel [87] underlines the fact that, in modelling software 
execution, SystemC does not define a standard method for dynamically creating processes or 
channels, nor does it support pausing, resuming and terminating processes or indicating that a 
process is idle waiting as opposed to busy. 
Commercial software tools have been developed to assist designers with the design, 
implementation and debugging of SystemC models. In the ViPERS approach, the link to the 
software tool CoCentric System Studio is provided as an alternative to the freely downloadable 
SystemC library. 
3.2.7 eo Centric System Studio 
CoCentric System Studio from Synopsys is a system-level design environment to assist in the 
design and simulation of SoCs. The graphical user interface allows designers to build SystemC 
models graphically while automatically generating the corresponding SystemC. It consists of 
tools, methodologies and libraries that support design abstraction, system-level reuse, and 
hardware-software co-design [88]. CoCentric is a SystemC simulator and specification 
environment for joint verification and analysis of algorithms, architecture, hardware and 
software at multiple levels of abstraction. A described by Kogel and Bussaglia [82], it is a 
unified tool that effectively addresses the following important aspects of SoC design and 
verification: 
 Design capture and management 
 The verification of algorithms and of architectures 
 Fast simulation 
 Powerful debugging and analysis 
 A path to implementation 
System Studio offers an environment which can be used to model a complete system. This 
environment allows models to be organised into hierarchical libraries which can be shared 
among different design projects. CoCentric System Studio provides three different views of 
- 63 -
Modell/IIC E",bedded R 'al-Tlme So s 
co h m del. The ymb I i \ ( . i ur - 12) , input und utput 
p rt . Thl un b" If1 tuntiuted int fi h'm Th' int rru  ic\ d fine find 
d urn nt th p rt nd pommet ' r p ifi bl k. The impl"mentution vi"w 
ntoin ' the implemcntutl n th' m dule . Th' s 'h 'muti bl 'k stru tur' allow ' Ih' lI ~er to 
Jmphi 'oily In d'l the 'IN ' tur' r Ih' m del. 'I hi i ' II 'I' intui ti C find qui k \ uy f' 
m difyin I th' tru 'tur' of' u . SI'rn. In ldditi n, th ' too l uutomuti 'u lly 'llel1l t " the ' Ul'" 
d' f, r th' interfl1 ' Ind purum 'I 'rs, so d 'U' on the impl 'm 'ntuti n of the 
behu vi ur. th r u ure utlin '0 b on'le 
I' the f,'l1tur" ur ' : '11 'ntion of hIm I d 'ull'l'ntution ; , or 
'11' r \ 111 Ih ' 'rror m ' . , '\ In h \. : impl 'm 'n lul10n und inl'rfu ' . , i 'W ' ; illl' ruled u 'C "s to 
r'vi ion 
o cnlrlc yslcllI ' Imllo - rlll)hlcllllnlcrflicc 
I-i Jur' - 12 f Ihe gruphi ulu ' 'r inlerfuce I' enlri' ySl'm tlldio. 
cntrie pre ' 'nl ' 0 nllmb'r of udditionul b 'n 'fils c mpurcd \ ilh Ih' f'reely 
do\ nl adable y I'm libl1lry. Ab ull, is Ih' po ' ' ibilily of ruphicully modelling the 
' Iru lur ' of u y ' lern \ hil' uUlomuli ally en'rulin Ih' corr' pondelll Y' lem code. The 
- 64 -
Chapter 3 Modelling Embedded Real-Time SoCs 
possibility of graphically modelling complex structures hierarchically and saving them in a 
library can reduce design times while increasing the ease of implementation. In contrast 
licensing costs and platform dependence (Linux) are major drawbacks. In consideration of the 
benefits and drawbacks of each approach the ViPERS methodology was designed to support 
both of them. The integration of SystemC models is described in chapter 5 of this thesis. 
3.3 UML 
The previous section explored SystemC and its use for the design and implementation of SoCs. 
The desire in the ViPERS approach is to further raise the level of abstraction of the first 
SystemC high level model in order to describe the system independently from its 
implementation. This would help to accurately analyse the requirements of the system without 
committing to any specific implementation. This can be achieved using a descriptive language 
such as UML. UML is 'a widely adopted, widely supported, and customisable industry 
standard' [89]. 
UML is a modelling language for specifying, visualizing, and documenting a system. It uses 
diagrams for classes and objects for capturing the system structure. Early behavioural analysis 
is achieved through use-cases and sequence diagrams, while the full constructive specification 
of the behaviour is done with statecharts. As described by Lavagno et al [89], UML adopts an 
extensibility mechanism by including the means by which additional semantics can be added to 
general concepts. Examples are stereotypes and custom tags which can be included into a 
profile to define a UML variant. 
The functional specification of a system is a vital stage in the design of an electronic product. 
Before the system is specified though, its requirements need to be defined. UML provides the 
semantics to describe a system independently from the language of implementation. The 
independence from implementation is one of the features of UML which makes it so powerful 
in the analysis of the requirements. This phase in fact needs to be abstracted from 
implementation details so that the system requirements can be understood by hardware and 
software engineers, and also by other, non-technical, stakeholders. On the other hand, a 
SystemC description of a system can only be understood by people who have knowledge of the 
language. Especially in the early stages of requirements analysis, it is important to allow 
technical and non-technical individuals to understand the system and collaborate on 
requirements definitions. 
The next section will explore requirements analysis, what it involves, its purpose, and the 
different type of requirements. 
- 65-
Chllpter 3 Modelling Embedded RelllTlme SoCs 
3.3.1 Requirements Analysis 
The requirements analysis phase is generally the first phase of the engineering life cycle model. 
Holt [90] defines requirements engineering as' ... the discipline of engineering that is concerned 
with capturing, analysing and modelling requirements ... ' 
Virtual prototyping can have a considerable impact in supporting the analysis of the 
requirements of a target product. In fact in the early stages of the life cycle model virtual 
prototyping can be used to capture, analyse and model some of the requirements associated with 
the product. 
The requirements phase is vital in the development of a system since any subsequent 
development in the design cycle should confonn to the initial requirements of the system. 
Requirements for a system usually need to be captured. Capturing requirements can be done in 
several ways. Commonly adopted techniques include interviews with potential users, by 
considering comparable systems, and by prototyping. Christel and Kang [91] cite the definition 
of requirement given in the IEEE standard Glossary of Software Engineering Tenninology. 
This definition states that a requirement should be: '(1) a condition or capability needed by a 
user to solve a problem or achieve an objective; (2) a condition or capability that must be met 
or possessed by a system or system component to satisfy a contract, standard. specification. or 
other formally imposed document; (3) a documented representation of a condition or capability 
as in (1) and (2).' 
The activities associated with the requirements process suggested in the Rational Unified 
Process (RUP) [92] are shown in Figure 3-13 and are discussed below: 
 Problem Analysis. This means that all the parties involved agree with what problem the 
system is going to solve. Stakeholders need to be identified and the boundaries of the 
system need to be defined. 
 Understanding the needs of stakeholders. This involves gathering and processing all the 
information from the stakeholders in order to understand what their needs are. 
 Defining the system. This involves identifying actors and use cases more completely 
and expanding the non-functional requirements. 
 Managing the scope of the systems. This involves adapting available resources, such as 
time, people and money. This is a continuous activity that requires iterative and 
incremental development. 
- 66-
Ch"pter J Modelling Embedded Re,,/-Tlme SoCs 
 Refining the system definition. This includes detailing the existing use case and 
describing the actors. 
 Managing changing requirements. This impacts the models created in all the other 
stages of the development chain. It is therefore important to identify the relationship 
between requirements and other artefacts. 
New System Existing System 
I-------~ Understand Stakeholders 
'-----:..--r----.J Needs 
Incorrect Problem 
Addressing Correct 
I--___ ~ Menege the Scope 1--_+< 
'--____ .-J of the System 
New Input 
Menege Chenglng 
Requirements 
Cen't do ell 
the Work 
Work In Scope 
Filure 3-13 Requirements analYIII. 
Source: Rational Unified Procesl-RUP (91) 
In the ViPERS approach, UML is applied to define the system, to refine the system definition 
and to manage changing requirements. In addition to identifying actors and use cases, as 
described in [92], state machines are employed in ViPERS, to add behaviour to the system and 
tum it into an executable model. This implies that some code needs to be written, but this 
process adds accuracy to derming the requirements, especially when integrated into a virtual 
prototyping context. Further details are explored in Chapter S. 
- 67-
ChGpter 3 Modelling Embedded ReG/-Time SoCs 
The purposes of the requirements analysis according to RUP [92] are: 
 To have a common understanding with the various stakeholders and the customers on 
what the system should do 
 To enable developers to understand what to implement as clearly as possible. This 
point and the previous one are satisfied by UML which describes systems through 
diagrams which can be intuitively understood. 
 To define the constraints of the system. UML provides constructs to enable designers 
to impose constraints on a system or subsystem. 
 To estimate the cost and time to develop the system 
 To define the interfaces based on the needs of users 
 To plan the technical content of iterations 
Requirements should fully describe what the system should do ensuring that all stakeholders, 
including customers and potential users, which are considered as very important sources of 
information, understand it. As illustrated by Christel and Kang [91] one of the three main 
problems with requirements elicitation is with fostering understanding among the different 
communities affected by the development of a given system. A Savant Institute study described 
by Goodrich and Olfman [93] states that' 56% of errors in installed systems were due to poor 
communication between user and analyst in defining requirements and that these types of errors 
were the most expensive to correct using up to 82% of available staff time'. Christel and Kang 
[91] illustrate how the problems of understanding related to requirements elicitation can be 
divided into three categories. Their first category is related to communities with different 
backgrounds and experience levels, where common knowledge for one group may be 
completely unknown for another. The second category relates to the language used to express 
the requirements which, depending on the audience, might appear too formal or too informal. 
Finally, the third category refers to the structuring of the information gathered during the 
requirements analysis. In the ViPERS approach the UML description is used as a first step 
towards a common understanding for stakeholders, and its combination with virtual prototypes 
is a further step towards that same aim. UML can be applied to structure the information and to 
provide a common understanding between most stakeholders without appearing too informal or 
too formal. The combination of an executable model with a virtual prototype enhances the 
benefits introduced by the UML model by providing an added visualisation layer which 
- 68-
Chapter 3 Modelling Embedded Real-Time SoCs 
provides an even more intuitive understanding for stakeholders. The combination of the UML 
model with the virtual prototype also satisfies the form in which requirements should be 
expressed. This is illustrated by Christel and Kang [91], where they state that the form of the 
requirements should promote communication and understanding between customers and users. 
Additionally, it should allow developers to determine whether the requirements are 
implementable and allow quality assurance teams to verify that an implementation meets these 
requirements. 
As described in [92], the nature of a specific requirement can vary depending on what feature of 
the system it is describing. Some types of requirements are listed below: 
1. Functionality (feature sets, security, capabilities, etc.) 
2. Usability (human factors, aesthetics, user documentation, etc.) 
3. Reliability (recoverability, predictability, accuracy, etc.) 
4. Performance (speed, efficiency, response time, power consumption, etc.) 
5. Supportability (compatibility, configurability, extensibility, etc.) 
UML provides the semantics to describe most of the different types of requirements listed 
above. The combination of the UML model with a virtual prototype enhances requirements 
elicitation, especially for human factors and aesthetic qualities of the target product. The 
combination of the behavioural model implemented in UML with the virtual prototype also 
allows more accurate definition of performance requirements. The virtual prototype, for 
example, can be used to test, how the response time of the display affects the user experience 
during a simulation of the device. 
Holt [90] further grouped the requirements into three categories. These are: 
1. Business requirements. As implied business requirements are concerned with the 
business side of the product development such as the costs or schedules and are not 
directly concerned with development per se. 
2. Functional requirements. They are typical user requirements that define the 
functionality of the product. Implementation details and low level details need to be 
avoided in this stage. The requirements should only define how the user will interact 
with the system. 
- 69-
Chapter 3 Modelling Embedded Real-Time SoCs 
3. Non-functional requirements. These are usually represented by the constraints made on 
functional requirements. Typical non-functional requirements can be, for example, life 
cycle issues. 
UML can be applied to all the different categories of requirements but in the ViPERS approach 
it is used for functional and some non-functional requirements (usability, aesthetics). 
The ViPERS approach and in particular the requirements analysis phase takes into consideration 
the IEEE Guide to Software Requirements Specifications as cited by Christel and Kang [91]. 
This defines good requirements to be unambiguous, complete. verifiable, consistent. modifiable. 
traceable. and usable during operation and maintenance. 
Since the ViPERS approach is designed specifically for embedded real-time systems, so the 
UML profile. UML profile for schedulability, performance and lime [94], often referred to as 
RealTime UML (UML-RT), which provides constructs for modelling real-time systems is used. 
3.3.2 UMLfor Real-Time Embedded Systems 
This section will explore the use of UML-RT for real-time systems. Real-time UML refers to a 
specification defined by the OMG (Object Management Group) for the modelling of real-time 
systems using UML [20]. This specification is defined in the UML profile for schedulability, 
performance and lime, which defines the rules, markings and constraints imposed on standard 
UML [20]. In this profile, time is represented as a physical quantity and supports two forms of 
time-based analysis: schedulability analysis and performance analysis [95]. This allows 
calculation of the key system properties though the addition of quantitative properties to a 
standard UML model. 
Lavagno et al [89] refer to the inherent ambiguities of informal specifications which prevent 
meaningful analysis of the system: 
'A key ingredient in a well defined methodology is a specification language with formally 
defined semantics that allow designers to describe the structure and the behaviour of an 
embedded system at multiple levels of abstraction starting from a purely conceptual level ...  
Lavagno et al [89] 
UML can deal with the heterogeneous nature of modem embedded systems which integrate sub-
systems reflecting different models of computation (MOC). Martin [96] outlines the features of 
UML which are important to embedded systems: 
-70 -
Chapter 3 Modelling Embedded Real-Time SoCs 
 it is a meta-language 
 its extension mechanism 
 it is promoted by a large standards organization 
 it supports object oriented specifications. 
Some of the features outlined by Martin [96] which are missing in UML are the platform model, 
the mapping and refinement to move from one platform level to another, and a budgeting 
methodology to complement the movement of design from requirements to implementation. 
UML notations can be applied to model both the qualitative (concurrency, communication, 
behavioural, action) and quantitative (i.e. time- related such as deadlines and priorities) features 
of real-time systems [89]. Examples are state machines, procedures, operations, operation-
based messaging, signal based messaging, active objects, activity and sequence diagrams, and 
data types such as Time and TimeExpression. Selic and Rumbaugh [97] outline the modelling 
constructs needed to represent real-time systems. They can be divided into two main categories; 
one is used to model the structure and the other one for the behaviour. The modelling of the 
structure is achieved through the use of: 
 Capsules;' ... They are complex. physical. distributed architectural objects that interact 
with the surroundings through one or more Signal-based boundary objects called 
ports ... ' Selic and Rumbaugh [97] 
 Ports;' ... are a physical part of the implementation of a capsule that mediates the 
interaction of the capsule with the outside world ... ' Selic and Rumbaugh [97] 
 Connectors;' ... are abstract views of signal-based communication channels that 
interconnect two or more ports ... ' Selic and Rumbaugh [97] 
The modelling of the behaviour is achieved through the use of: 
 Protocols;' ... the specification of desired behaviour that can take place over a 
connector ... ' Selic and Rumbaugh [97] 
 State Machines 
- 71 -
Chapter J Modelling Embedded Real-Time SoCs 
 A Time Service. This is a ' ... time service which has the ability to trigger events at a 
particular time or after a certain interval has expired from some point in time ... ' Selic 
and Rumbaugh [97] 
In the ViPERS approach UML is used in the requirements analysis phase. First, a standard 
UML description of the system provided by class, use-case and sequences diagrams is built to 
initiate understanding and communication between designer teams. This description is then 
enhanced by adding behaviour though the use of state machines. The description of the system 
then becomes executable and it is used in conjunction with graphical models to accurately 
explore the functional requirements of the system. 
3.4 UML and SystemC 
In the ViPERS methodology UML and SystemC are used in a complimentary fashion. The 
UML description constructed in the requirements analysis phase is used to design the first high 
level model in SystemC. Currently the design of the SystemC model is based on the UML 
description but there is no automated process between the two languages. The possibility of 
using UML and SystemC in conjunction was demonstrated by Vanderperren et al [98] for the 
development of complex System-On-a-Chip, a Wireless LAN chipset. UML was there used to 
provide visual, structured models and documentation of the architecture and design as the SOC 
was developed. The paper outlines the methodology, from the early stages when a vision 
document is produced [92]. As described by Vanderperren et al [98] UML is then used for the 
implementation of an architectural model in order to: 
1. provide a common environment for the specification of high level architectural 
decisions across disciplines 
2. specify the black-box requirements for each major subsystem 
3. specify the detailed requirements for inter-subsystem interfaces 
4. provide a documented framework for the SystemC model. 
The authors used UML stereotypes to define SystemC components in the UML framework. For 
example a class is stereotyped as a sc_module. Even though a considerable synergy was 
demonstrated between SystemC and UML, some problems and issues were highlighted: 
-72 -
Chapter 3 Modelling Embedded Real-Time SoCs 
 If the architecture is later modified, the models and the documentation need to 
be manually brought into line 
 There is no direct link between the SystemC and the UML model. 
 Engineers with no modelling background need to be introduced to the 
modelling concepts, process and notations. 
As it will be described later in this thesis, the ViPERS approach encountered similar problems 
to the ones highlighted by Vanderperren et al [98]. The two approaches are similar, although in 
the ViPERS framework UML models are made executable and tested through virtual 
prototypes. Other similar approaches which advocate the use the combination of SystemC and 
UML, but do not apply executable UML modelling, are described elsewhere [99, 100, 101, 102, 
103 and 104]. 
Future work on the ViPERS methodology involves the creation of a meta-model of SystemC 
using MOF and UML. Another unresolved option for the ViPERS methodology resides in the 
future release of a SystemC profile [lOS] for UML, which is likely to enable an easier 
translation process. 
-73 -
Chapter 4 
The ViPERS Methodology 
and Environment 
Chapter 4 The ViPERS Methodology and Environment 
THE VIPERS METHODOLOGY AND 
ENVIRONMENT 
his chapter presents the ViPERS virtual prototyping design methodology and its 
environment. The design of this methodology is built on the desire to integrate the 
graphical and interactive features of virtual prototyping into a contemporary design 
flow for SoCs. The ViPERS methodology relies on a framework. referred to in this thesis. as 
the ViPERS environment or framework, which provides the necessary tools, libraries and 
services required in the different phases of this methodology to implement and simulate virtual 
prototypes. The design of the ViPERS methodology was based on the analysis presented in the 
previous chapters of this thesis. This analysis examined strengths, weaknesses, and missing 
features of previous research efforts in the field of virtual prototyping and explored the use of a 
system level design methodology for SoCs. Considerations made from this analysis are the 
foundations of this novel approach. 
The material presented in this chapter has also been published by the ViPERS team, Lister et al 
[21.22, and 23]. 
My contributions in this chapter are the concepts of the ViPERS design flow including the 
modification of the ROPES process, the definition of the executable functional models, and the 
communication infrastructure including the communication protocol, the server application 
(LCCS) and the design and implementation of the socket library (SxSocket Library) and 
package (SxUMLSocket Package) in UML and SystemC. The ViPERS environment also 
comprises of other tools which were developed within the Centre for VLSI and Computer 
Graphics (YDM, the System Container application and the Win32 3D Visualisation QUI) and 
other off-the-shelf tools (Rational Rose RealTime, CoCentric System Studio and Visual 
Studio.NET). 
-75 -
Chapter 4 The ViPERS Methodology and Environment 
4.1 Introduction 
The ViPERS approach includes aspects of virtual prototyping which were beneficial in previous 
research efforts and commercial tools. These aspects are: 
 Graphical modelling. The ViPERS environment includes, as well as other virtual 
prototyping tools, an editor, which enables designers to implement and simulate the 
interactive graphical model of a virtual prototype. 
 Behavioural Modelling. Existing virtual prototyping tools have adopted different 
approaches. Some [42 and 68] provide their own tools to model the functional 
behaviour of a target device while others [66] provide the links to existing commercial 
tools. The ViPERS framework adopts the second approach and provides the means to 
link to ad-hoc external tools such as Rational Rose RealTime and CoCentric System 
Studio. 
 Distributed simulations. Distribution allows a better utilisation of processing power 
and can also be used to deal with platform issues. The communication framework 
supporting the ViPERS tools is built around a communication protocol. The protocol 
defines the rules which control the exchange of messages between simulating models. 
A benefit of this approach is that models of a different nature can communicate with 
each other, independently of their implementation language. 
 Open architecture and Plugin structure. The ViPERS environment, provides an open 
architecture which allows linking to external tools. VDM also provides a plugin 
structure explored in detail later in this chapter. 
 Usability tests and Web distribution. Virtual prototypes implemented in the ViPERS 
framework can be used for usability tests. Usability tests involve the interaction of 
users with a virtual prototype in order to obtain feedback from potential users of the 
target product and other stakeholders. In a typical usability test the user interacts with 
a graphical interactive model trying to perform some functions of the virtual device. 
After having tested the virtual device, users are able to provide feedback to the 
designers about certain features of the target device such as issues related to its 
behaviour, its interaction, its interfaces and its aesthetic qualities. Usability tests of the 
virtual device can be enhanced by distribution of a virtual prototype over the Internet. 
Currently in the ViPERS framework, the distribution of virtual prototypes over the 
-76 -
Chapter 4 The ViPERS Methodology and Environment 
Web is achieved by distributing simulations or by packaging a virtual prototype into an 
independent executable. 
The ViPERS approach improves weak features and implements nonexistent features of past 
research efforts and existing virtual prototyping tools. These features are: 
 Graphical Photorealism. A key aspect of the ViPERS approach is the focus on 
graphical realism. The appearance of the virtual prototype is accurately modelled 
within the ViPERS methodology. Using techniques such as alpha-blending [43], the 
motion of a button being pressed during a simulation is made graphically more 
realistic. Special graphics techniques are employed to ensure that the photorealistic 
nature of the graphics is achieved when, at simulation time, the physical form, position, 
and angle of the virtual prototype are modified. Special algorithms [106] for the 
rendering of the displays can be applied, when for example, its viewing angle changes 
during a simulation as shown in Figure 4-1. 
Garage Door 
... .. 
I' . I' 
II 0% 
III Light 1 Ligtrt 2 
Figure 4-1 Display special rendering. 
 Additional support for the requirements analysis phase. Another key concern in the 
ViPERS methodology is the early detection of errors through an accurate requirements 
analysis phase. To reduce the high financial risks that late detection of errors can 
bring, designs need to be tested and verified prior to any implementation. Testing and 
verification need to be continued though out implementation at different stages. The 
- 77 -
Ch"pter 4 The VIPERS Methodology lind Environment 
rule of 10 [38] can govern the relation between fmanciallosses and late detection of 
errors throughout the design and development process of a product. 
 Route to hardware. The ViPERS framework allows the combination of graphical 
models with simulations of the low level implementation of the underlying electronics 
of the target device. One of the main differentiations between the ViPERS approach 
and the existing approaches is the possibility to link the graphical interactive models 
with the digital implementation of the target device. Existing approaches implement a 
functional description to drive the behaviour of the virtual prototype. This functional 
model is implemented only for this purpose and it is not used for the implementation of 
the underlying electronics. This implies that both the graphical and functional models 
are no longer used once hardware, software and systems engineers start designing and 
implementing the target device. In the ViPERS approach the graphical model can be 
linked to models implemented in SystemC regardless of their level of abstraction. This 
allows the reuse of the graphical model, and therefore of the virtual prototype, even at 
the register transfer level. 
 Virtual Prototype context. In the ViPERS framework virtual prototypes can be placed 
in a virtual context, such as a three dimensional virtual environment where, at 
simulation time, users can interact with the virtual prototype and view how the 
environment reacts to it. A feature that has been neglected in previous research on 
virtual prototyping is the possibility to prototype the interaction of the virtual prototype 
with its environment. The context is a three dimensional virtual environment where the 
user can navigate while interacting with the virtual device. The user can therefore view 
the changes which the virtual device is causing in the virtual environment. This 
provides added feedback to the user. The virtual environment can accommodate 
multiple virtual prototypes and therefore their interaction can be modelled and analysed 
during simulations. 
Finally the ViPERS approach provides the links to integrate virtual prototyping techniques with 
the SystemC design methodology for SoCs. 
4.2 The ViPERS methodology 
The ViPERS methodology conforms to the Pahl et al definition of a design methodology [107] 
as follows 
 It encourages a problem-directed approach 
-78 -
Chapter 4 The ViPERS Methodology alld Ellvirollmellt 
 It fosters inventiveness and understanding 
 It confonns to the concepts, methods and findings of other disciplines 
 It does not rely on solving problems by chance 
 It uses known solutions 
 It can be easily taught and learned 
 It applies findings of cognitive science and ergonomics to design 
The ViPERS approach is based on a modified version of the ROPES (Rapid Object-oriented 
Process for Embedded Systems) process [108, 109]. 
Design 
Architectural Design 
Executable Specification 
Analysis 
Hardware/Software 
Partitioning 
Detailed Design 
Coding 
Implementation 
Object Analysis 
System Analysis 
System, Integ ratlpn 
\ , I , , 
\ \ , \ , 
'. ' , ' 
',~,,\\ \ 
Systemivalldatlon 
Test ng 
'~~'"'''Virtual Prototypes 
Figure 4-2 ROPES process. 
Source: based on Douglass 1108, 1091 
- 79 -
Chapter 4 The VIPERS MethodoloU and Environment 
The spiral model of the ROPES process comprises four main phases as shown in Figure 4-2; 
these phases are: 
1. Analysis 
2. Design 
3. Implementation 
4. Test 
This process suggests the implementation of a virtual prototype each time the system is 
validated at the end of the test phase. This implies that a single virtual prototype is 
implemented at the end of each cycle of the spiral model, i.e. after the four phases are 
completed as shown in Figure 4-2. In the ViPERS approach, three prototypes are generated, in 
each corresponding cycle. In each phase, designers and engineers implement a virtual prototype 
which is used to verify the work undertaken before proceeding to the next phase. With the 
approach suggested in this thesis, designers do not need to go through the four phases before 
being provided with real means to test their models. In the ROPES process a virtual prototype 
is implemented only after the system is analysed, designed, implemented. and tested. In the 
ViPERS approach the first virtual prototype is implemented at the end of the analysis phase and 
this prototype is the result of a spiral model itself. A virtual prototype is created ad-hoc for the 
analysis phase and it conforms to a spiral model because the model will be refined until it 
satisfies the requirements. Once the requirements for this virtual prototype are satisfied. 
designers enter another spiral model for the design phase. Another virtual prototype will be 
used in this phase to ensure that the model satisfies the requirements for this phase. A similar 
spiral model is then applied to the implementation and test phase. 
Figure 4-3 shows the suggested modification to the ROPES process. Each of the three virtual 
prototypes generated throughout the four phases of the process are the result of a complete cycle 
in itself. In the ViPERS process each original cycle of the ROPES process comprises three 
spiral models. 
As shown in Figure 4-3 the analysis phase includes a spiral model which allows designers to 
iterate through the requirements analysis and specification in order to refine the individual 
components and the model as one. The executable model is connected to a graphical model to 
provide a virtual prototype which is used to test this model and refine it until the requirements 
- 80-
Chapter" The ViPERS Methodology alld Ellvirolllllellt 
are satisfied. As for the analysis phase, a spiral model which produces a virtual prototype is 
provided in both the design phase and in the implementation and test phases. 
If at the end of the test phase the designer is not satisfied with the model/component or if a new 
component needs to be designed and implemented, the same process just undertaken is repeated 
starting again from the spiral model in the analysis phase. The three spiral model described in 
the previous paragraph is part of an overall spiral model which is shown in grey in Figure 4-3 
and is based on the ROPES process described earlier in this section. 
Functional Prototype 
Design Analysis 
Architectural Prototype Implementation Digital Prototype 
Figure 4-3 Modification to ROPES process 
A similar approach to the one used in the ViPERS is described by Hoffmann [110]. This 
process depicts the integration of the V-diagram, shown in Figure 4-4, with the ROPES process. 
The process involves the creation of a virtual prototype for each use-case made in the 
requirements analysis phase, and a virtual prototype for the architectural system model. After 
implementing these prototypes the process enters a semi-spiral of the ROPES process. In this 
semi-spiral model the analysis phase is omitted and the process is only made up of the design, 
implementation and test phases. In the ViPERS approach the two legs of the V-diagram are 
transformed in a spiral model to allow the implementations to be verified through the generated 
virtual prototype. 
- 81 -
Use-Case 
Model{s) 
Conceptual/ 
Architectural 
System Model 
Implementation Model 
Chapter -I The ViPERS Methodology and Envlrollme"t 
System Modlftcatlon 
... .. ... .. " . ". 
Figure 4-4 V-Diagram of the Engineering Iifecycle 
The suggested multiple spiral model integrates the use of virtual prototypes with a system level 
design approach, and specifically for the ViPERS approach, it combines the use of virtual 
prototyping with the SystemC design methodology. 
This integration is show in Figure 4-5. This diagram shows the main steps from requirements 
analysis to RTL implementations, as well as the process of modelling the graphics of the target 
device and its virtual environment. 
The virtual prototypes generated in the different phases are the combination of a functional 
model with a graphical model. The nature of each virtual prototype depends on the nature of its 
functional model. The same graphical model can be used throughout the entire design flow. 
This further justifies the combination of graphical models with low level implementations, since 
no additional graphical modelling is needed after the optimal design has been chosen. The 
nature of the functional model does not depend on the language of implementation but only on 
the phase from which it has been produced. 
- 82 -
00 :::t' 
= = IrQ 
SoC Modening 
[ Relul r~e~tA,;ali~ - l 
I Execulible spedfoH;] 
. --- --- ---- -- --, '\. 
I ___ ___ ---- - - ---~,' 
; --- ---- ---_.' \ I UnTi~ Fundional Modelling I 
--- , 
I Timed FuocOOnai Mooelli~ 
ardl'/ar Sofutm 
IslIS Cycle ~rat Model l RTDS I .. ~'. 
1at-1,' 
I Cyde AcaJrie MexleJ I ". I ' Code Happi~ ~' 
S  litio. billie 
Simulation 
srstem( 
Simulitim 
System( 
Simulition 
" 1\ , 
I '  , 
I ~. ,: 
I' . . ' 
Sinulation Environment 
Vlrtul Prototypes 
Fundional 
Prototype 
~ Prototype 
I ,'1 " .. 
, , , 
Rederi., Middle 
Graphitil 
Ineradi,e 
Hodel 
Vi rtual 
Environment 
Graphics Modelling 
< . : I Component Scripting 
, . . 
, I , .. 
~ "edt Scripting I I Message Handl ing h 
'.~.. ~ 3D Griptts Cration I VRMl Translation V 
c:::::::::: ~ 
~ ... 
~ ... 
c;::, -c::. 
~ --... 
Chapter" The VIPERS Methodology and Environment 
The methodology can be divided into two main concurrent tasks, the design and implementation 
of a SoC (SoC Modelling), and the modelling of the graphical and interactive features of the 
target product and its environment (Graphical Modelling). The combination of graphical and 
functional models during a simulation constitutes the simulation environment. 
4.2.1 Graphical Modelling 
Graphical modelling includes the creation of both, two dimensional (or possibly three 
dimensional) models and three dimensional environments. Both types of models need to be 
interactive. Interactivity is given to graphical components through scripting. The main steps 
involved in the creation of two dimensional models are: 
 20 graphics creation. Two dimensional graphical models are implemented using YOM 
and its library of graphical components. When graphical components are not already 
available in the VDM library, graphical editors (e.g. Adobe Photoshop) can be used to 
create the bitmaps. The bitmaps can then be imported into the YOM library. Elements 
of the YOM library can be dragged and dropped into its workspace to create the virtual 
device. 
 Object scripting. Some of the graphical components belonging to the virtual device 
need to be interactive. Buttons are an example of a common component in handheld 
devices which need to be interactive. Scripting is applied to interactive components to 
obtain the desired behaviour during simulations. 
 Message handling. The interaction of the graphical model with its functional 
counterpart is achieved through the exchange of messages between the two models. 
Graphical components need to be instructed on how to handle the messages received 
from the behavioural model, as well as what messages to send out. 
The main steps involved in the creation of three dimensional environments are: 
 30 graphics creation. The three dimensional virtual environment is created using off-
the-shelf 3D graphical editors such as 3D Studio Max. 
 VRML translation. The 3D virtual environment created in the previous phase is 
translated into VRML format. 
- 84-
Chllpter 4 The VIPERS Methodology lind Environment 
 Node scripting. Some components of the virtual environment will need to be given 
dynamic features. This is achieved by scripting the nodes which implement those 
components in the VRML file. 
 Message handling. The 3D virtual environment needs to communicate with external 
graphical and functional models. As for the two dimensional models previously 
described, the virtual environment needs to be instructed on how to handle the message 
exchange. 
The next sections will explore the tasks involved in the implementation of the functional models 
and their combination with graphical models within the simulation environment. 
4.2.2 SoC Modelling 
Only tasks specific to the ViPERS methodology will be explored in this section since the 
adopted design flow for SoCs conforms to the SystemC design methodology which was 
previously described in details in Chapter 3. 
4.2.2.1 Analysis Phase 
The tasks involved in the analysis phase are the requirements analysis, the analysis of the 
system, of its objects and defming the functional specification of the target device in an 
executable form. 
As shown in Figure 4-5 the first step in the methodology is the requirements analysis and the 
consequent production of an executable specification derived from it. A key aspect is to ensure 
that effort spent in the early product definition phase is reused as much as possible when 
implementing and testing the device. 
The suggested flow for the analysis phase is explored in Chapter 3 of this thesis. This approach 
is used to analyse the requirements of the target device as well as analysing the system and its 
internal objects. Once the requirements of the system have been identified and the system and 
its objects have been analysed the specification of the target device can be defined. In the 
ViPERS approach the specification is provided in an executable form. This executable 
specification can then be linked to a graphical model, it can be distributed and shown to the 
various stakeholders. An executable specification is not just a written document which 
identifies and specifies the system but it is a model which can be executed. At present in the 
ViPERS framework the virtual prototype provides the capability to define and visually represent 
various features such as the functional behaviour and some aesthetic qualities of the target 
device but other features such as the power consumption are not directly supported. Features 
- 8S -
Chapter -I The VIPERS Methodology and Environment 
such as the response time of the device can be analysed and defined. Some requirements will 
meet some technical constraints and will need to be redefined but the virtual prototype can be 
used to identify the boundaries of acceptance of certain features. Other features such as 
compatibility and configurability are not directly supported by this virtual prototyping approach 
but are defined in traditional ways as described in Chapter 3. In this phase the standard 
approach, such as the one described in Chapter 3, is used in conjunction with virtual prototypes 
in order to enhance the capability of the designer for analysing and defining certain features of 
the system. In addition the virtual prototype driven by the executable model allows the 
stakeholders to visually understand some of the defined features of the target device. 
Understanding and communication between stakeholders in this phase is very important. HCI 
experts, for example, will need to communicate with hardware and software engineers in order 
to minimise the possibility of defining unrealistic models. They could be in charge of defining 
the boundaries of acceptance for the response time of the display. The virtual prototype could 
be used to analyse the user's perception of the response time and to draw important conclusions. 
At the same time though, interaction with hardware and software engineers could enable HCI 
experts to understand the technical constraints and limitations. The virtual prototype is a very 
effective way of communicating since it provides a graphical representation of the required or 
specified features. It is intention of the ViPERS approach to further analyse the field of 
specification in order to define its constituent parts and what can be implemented to enhance 
this process. 
The functional model implemented in this phase is not expected to contain low level 
implementation details. This model is only required to resemble the functional behaviour of the 
target electronic product. SystemC and UML are both candidate languages for the 
implementation of the functional model in this phase. Both languages provide the capability of 
implementing executable models. 
UML provides the means to model detailed requirements which can lead, with the aid of 
software tools such as Rational Rose RealTime and the use of state machines, to the production 
of the first functional model. If the graphical model has been implemented at this stage then the 
requirements can be explored through the connection of the graphical model to its behavioural 
correspondent in UML as shown in Figure 4-5, and feedback from the stakeholders can be 
gathered. 
A functional model can also be created in SystemC. There are however, several drawbacks to 
using SystemC in the analysis phase. SystemC models are harder to implement, modify and 
- 86-
Chapter 4 The ViPERS Methodology alld Ellvironmellt 
test, and no automatic generation of appropriate documentation is provided. An advantage is 
that once verified, SystemC models are ready for further refinement. 
The combination of the functional model with its graphical counterpart m the simulation 
environment produces the virtual prototype referred to as a Functional Prototype. The 
Functional Prototype is implemented in the analysis phase to explore features of the target 
product such as the graphical interfaces, physical interfaces, and its behaviour. 
The requirements need to include physical implementation details, and from this, several 
candidate outline specifications can be created as shown in Figure 4-6. From these candidates, 
one or more graphical models can be produced and animated w ithin the ViPERS VOM design 
and simulation environment. 
Figure 4-6 Candidate solutionsS 
5 Models created by Dr. Phil Watten, Centre for VLSI and Computer Graphics, University of Sussex 
- 87 -
Chapter 4 The ViPERS Methodology and Environment 
4.2.2.2 Design Phase 
The tasks involved in the design phase are: 
 Architectural design 
 Hardware/Software design 
 Detailed design 
The functional model in this phase is required to resemble the architecture of the underlying 
electronics of the target device and to simulate its behaviour. This model enables designers to 
partition the hardware and software blocks and to explore available options. SystemC is the 
language selected for this phase; the model might be a refined model from the previous phase or 
a newly developed model. The level of abstraction depends on the designer, on the complexity 
of the model, and on the required simulation speed. It is suggested though, to implement 
models at an abstraction level which allows testing of different partitioning options. To increase 
simulation speed and decrease the complexity between the refinement steps, it is proposed to 
follow the SystemC suggested design flow [85] and allow the implementation of an 
intermediate transaction level model [111] for architectural exploration. 
If the functional description of the device electronics is written in UML from the previous 
phase, it is then used to create the high-level SystemC model within a SystemC simulation 
environment, for which the Synopsys CoCentric System Studio or the freely downloadable 
SystemC library and Visual Studio.NET are used. As suggested in the SystemC methodology 
untimed functional models are at the highest level of abstraction. The C++ code written or 
automatically generated from the UML model can partly be reused for the implementation of 
the UTF model since no clocks, signals, ports, etc, are used in these models. At present the 
conversion from one model to another is manual and most probably some modification and 
reimplementation of the code would be needed. The amount of modifications depends on the 
quality of the code written for the UML model and which UML tool is used to generate the 
code. Future work includes a translation mechanism to go from UML to SystemC models 
automatically; this will be further discussed in Chapter 7. 
The Architectural Prototype is the result of combining the functional model obtained in this 
phase with its graphical correspondent. 
4.2.3 Implementation and Test Phase 
The tasks involved in the implementation are: 
- 88-
Chllpter 4 The VIPERS Methodolo/lY lind Environment 
 Coding 
o Hardware implementation 
o Software implementation 
 Unit testing 
And in the testing phase: 
 System integration 
 Hardware/Software co-verification 
 System validitation testing 
The flow of the implementation and test phase follows the SystemC methodology described in 
Chapter 3. The description of the functional model in this phase is defined by a low level 
implementation of the target electronic system. This model is obtained from a further 
refinement of the architectural model and can be implemented at various levels of abstraction. 
Hardware and software blocks are implemented in parallel and tested within the system level 
model. Once the blocks have been separately verified they are integrated and the system is 
verified as one. The final aim of the hardware model is to be realized in synthesisable RTL 
code. 
The Structural/Digital Prototype is the result of combining the functional model obtained in this 
phase with a graphical model in the ViPERS simulation environment. 
4.3 ViPERS Virtual Prototyping Environment/Framework 
The ViPERS framework contains the tools, services, and links which allow the implementation 
and simulation of virtual prototypes. Figure 4-7 shows the components of the ViPERS virtual 
prototyping environment. 
The ViPERS virtual prototyping environment is composed of: 
1. Graphical tools 
a. VDM 
b. Win32 3D Visualisation GUI 
- 89-
Chllpter 4 The VIPERS Methodology lind Environment 
2. Connectivity to functional models 
a. CoCentric System Studio 
i. SxSocket Library [25] 
b. Visual Studio.Net and the SystemC library 
i. SystemC Container application [21] 
c. Rational Rose RealTime 
i. SxUMLSocket Package [24] 
3. Communication Manager 
a. Local Communication Control Service (LCCS) 
This chapter will describe the graphics tools and LCCS while the other elements will be 
explored in detail in the next chapter. 
- 90-
c .., 
"C .., 
Graphics Modelling 
Win32 3D Visualisation GUI 
3D Visual isation 
Management 
Message Rout ing 
Model 
Socket j --
SoC Modelling 
~-------------------------------------
Server 
Socket 
Communication 
Engine 
Parser Register 
Control Un 
1---------, o Uf CoPYnQht 
I 0 E""'mol Tool I 
I 0 int..-no' ~nu . us CoPYnQht I 
Io _________ .j 
---------------
Responsibility: : VT- Vincenzo Trignano I 
I MB- Dr. Mike Bassett 
I PW- Dr. Phil Watten 
: BJ- Ben Jackson 
---------------
Rationa l Rose Real-Time 
Socket Package 
,--------. 
 Socket Capsule , 
Server , 
Socket ----.-
CoCentnc 
System 
Studio 
SystemC 
Container 
Application 
SystemC 
Free Toolkit 
SystemC I 
ubrary 
~ ""l 
~ .. " 
t't'j 
t't'j 
-.: ., 
Chapter 4 The ViPERS Methodology alld Ellvirollmellt 
4.3.1 VDM Development Environment6 
VDM is a vital component in the ViPERS environment enabling the modelling of interface 
components. The Virtual Device Modeller is a framework which has been designed to enable a 
virtual device to be built and exercised. The VDM targets the development of interface-based 
components and provides a comprehensive API to facilitate this. Although the virtual device is 
not limited to interface components, interface components, such as displays or keyboards, are 
the main focus here. 
'" (<it - aN> 
,.,. r;~ " , - ~ ~ r=----'--;---;-::---;c.,.--;:::---=:----:-: 
, ... .,.,. Gr..,.AtfOMtOI_ ilI :
~""",ow(X) l . '<I$I 
L*~OI """ 
1.~I  ..".., 
~...uJ5. "'" 
9w'l1 ... ~"IIto 
_-.0<_ 
~1~,q, 
5lw"oJ 1~-
 W l ",,", 
. ", -
 ..J,,-. 
' u~_'t 
 ...l b". __  
. ", -
- u dsr400,. ~,--. 
 w _ 
Purollto\ .",. 
-"'" '4)t1Wor'-. 
ltwY~ 
""",,,"lnte 
""",,,~ 
\'b,-.l,~i~. '" 
",.I( keor.:,.,W <I 
\r~OI'b dl 
~QlIK~" 
~ .. )~,dI 
IA~CCS " 
Figure 4-8 VDM Graphical User Inter face 
::f ,Q:IO"-' .. ,~.wJt. 
'1 t-... ._--
. \i e_ 
... , ,,( I('()'III,) 
""""-" . 
. \") ,,...~ 
 W lulu ... ') 
 W llult_ 
 lot NtJrt'J 
 III N t"'" 
-, ~ .. - , 
VDM enables 2D graphical models of peripheral devices to be created and connected to a 
simulation system. User interaction is available with a mouse or keyboard as in any Windows 
based application however, the interaction speed will depend on the abstraction level of the 
simulation engine . 
VDM models are created with a scripting language, which provide access to the API provided 
by VDM. The API provides a rich environment of virtual component creation helpers. 
6 VDM was implemented by Dr. Phil Watten, Centre for VLSI and Computer Graphics, University of 
Sussex. 
- 92 -
Chapter 4 The ViPERS Me t hodo l ogy a ll d Ellvirollmellt 
Interfaces to external simulation systems are also defined in the script. In the case of a display 
system, work has gone into the development of the PixelFonts [43] API technology, which 
enhances display models to enable sub-pixel investigation as shown in Figure 4-9 . 
Display 
Backgrourd 
Bitmap 
Olaracter 
Backgrourd 
Bitmap _Ii 
f~. MsgDisplay.pxf  Virtual ... IIII EJ 
file fdit Yiew :ielp 
Ready 
Figure 4-9 Display modelling with PixelFont7 
For example, a single pixel in a monochromatic LCD may be a single square with a small 
number of possible intensities. On the other hand a pixel from a colour LCD may be created 
from three stripes of red green and blue with the ability to produce millions of colours. The 
clarity of an image depends on the pixel size and geometry. It is possible for different display 
systems to require individual image manipulation and enhancement techniques targeted 
specifically to the geometry of each pixel in the display system. Testing such image techniques 
is difficult on the monitor of a PC, as this is another display type itself. Pixel Fonts enables 
models of displays to be designed, which are abstracted from the underlying disp lay technology, 
such as the PC monitor and which can accurately portray the visual effect of the real device 
(within the limitation of the display used). 
7 Display model created by Dr. Phil Watten, Centre for VLSI and Computer Graphics, University of 
Sussex. 
- 93 -
Chapter 4 rhe ViPERS Methodology and Environment 
In this architecture, representative applications for YOM are the modelling of graphically 
orientated interface devices. These are typically displays or keyboards. Although keyboards do 
not generate graphics they manifest a realistic graphical representation unlike, say, a network 
connection where graphics may be used for analytical purposes only. 
The photorealistic graphical model of the virtual prototype is constructed from graphics files 
within the YOM environment. The YOM environment has been created to satisfy the YiPERS 
requirement that the modelled device has a photorealistic appearance and that accurate 
modelling of the device behaviour can be achieved from a user-interaction perspective. 
Figure 4-10 Development process of a graphical prototype 
It is common to find a reasonable graphical quality in existing virtual prototyping tools [42, 66, 
67, and 68], but their graphical models are not photorealistic and an area that is particularly 
neglected is the accurate modelling of displays. The ViPERS VDM environment offers visually 
accurate modelling of both input devices and custom displays to increase the level of realism. 
- 94-
Chapter 4 The VIPERS Methodology and Environment 
The device buttons and display element files are created in a generic graphics bitmap editing 
application such as Adobe Photoshop. The files can then be imported in the VDM framework 
and added to its graphics library. Designers can drag and drop the graphical objects and put 
them together inside the VDM workspace. The graphical model of the virtual prototype is 
constructed by compositing graphical components together. Figure 4-10 shows how Adobe 
Photoshop was used to create all the bitmaps needed on a custom display of a remote control. 
The development offers a logical split of design style between the scripted graphical appearance 
coding and the device behaviour that will eventually be implemented in software or hardware as 
follows: 
 Scripting can be used to model all device behaviour that is purely associated with the 
physical model. 
 SystemC and UML can be used to model the behaviour of the device. 
The ViPERS VOM development environment allows the importing of standard graphics files. 
The environment uses an XML-style file to store the description of buttons or display elements. 
The library of VOM provides a number of buttons, displays and other graphical components 
which are commonly found in handheld devices. The graphical user interface of VOM is shown 
in Figure 4-8. 
4.3.1.1 The VDM Architecture 
VDM is implemented in C++ with the MFC. It is built on an open automation architecture and 
exposes an API that has been designed to aid the development of virtual devices. To produce a 
virtual device model, the user must make calls to the exported API. This can be done externally 
or with the internal scripting engine. Figure 4-11 shows the VDM architecture; the diagram 
shows how the automation server isolates the scripting engine layer from the API layer. This 
isolation gives the automation server control over the API layer so that conflicting command 
streams do not interfere. The automation server routes calls from external applications and the 
internal scripting engine, to the VDM and PixelFonts API. This results in a programmable 
architecture with external connectivity that can be configured into almost any orientation 
- 95 -
Chapter 4 rhe ViPERS Methodology and Environment 
CoCentric 
Figure 4-11 VDM architecture. 
Source: Watten 1431 
4.3.1.2 The Advantages ofVDM 
VDM provides the ability to have a constant model throughout the design flow. A device model 
developed at the concept-level of the design flow can remain current right through the design 
process. At each level of the design different simulators may be used with the same VDM 
model. 
A concept-level design may have very little implementation but be rich in ideas and user 
interface issues. Producing a VDM model of the user interface can help test the design validity 
and after stages of iteration can help with the production of more efficient interfaces. The 
interface device itself may only be a concept at this level with VDM hosting a model of a device 
yet to be constructed. In the case of a custom manufactured LCD, the design of the user 
interface is critical, as the manufacture of the display itself is a costly and lengthy exercise. Not 
only does the VDM based model aid validation of the display for the present design, but it can 
help in anticipating future designs and thus can add a certain amount of future proofing into the 
design. In fact, once a product is made commercially available, feedback from users can be 
used to adapt the existing virtual prototype for future releases of the product. 
For the VDM model to stay current throughout the design process, the interface to that model 
can be implemented on a number of different levels. VDM provides the ability to connect 
external simulators at multiple levels. This enables VDM to connect to external applications. 
- 96 -
Chapter 4 The VIPERS Methodology and Environment 
4.3.2 Environment Modelling 
Modelling the environment, in the ViPERS context, is the process of creating interactive three 
dimensional virtual environments which can be used in virtual prototyping simulations. The 3D 
world presents to the user a model of the environment in which the device is intended to be 
used. This aids the user in more closely visualising the end goal of the proposed product as 
opposed to relying on imagination. The user is presented with a 20 visualisation of a handheld 
device on a separate PC. A 30 portrayal of the environment in which the device exists reacts in 
sympathy with the model and responds to interactions generated by the simulation. The 
architecture for rendering the 3D visualisation and message communication system is depicted 
in Figure 4-12. The models for the virtual environment are created using 30 Studio Max and 
are exported as VRML files. These are then viewed using ParallelGraphics's VRML browser, 
Cortona, version 4.2 [112] which is embedded in a C++ Win32 wrapper application. This 
encompasses the VRML browser, and allows manipulation of the VRML model through the 
Cortona Application Programming Interface (API). Communication between the VRML 
model, 20 visualisation and the functional simulation model is implemented using a socket 
interface. 
WIN32 3D Visualisation GUI 
Messages 
Cortona 
ActlveX 
3D VRML 
3D Visualisation Renderer 
Management and 
Message Routing 
Messages 
"---- Communication 
Plug In 
Model 
20 Visualisation 
And Electronic 
Simulation System 
Figure 4-11 Wl0313D vlluallsation tool 
-97 -
Chllpter II The VIPERS Methodology lind Environment 
4.3.3 Executable Functional Models 
An executable functional model (EFM), in the context of the ViPERS prototyping environment 
is a description of the functional behaviour of a device. An EFM can be described at different 
levels of abstraction, from transaction to register transfer level, and implemented in different 
language, from UML to SystemC. 
At present the ViPERS environment provides support for two types of executable functional 
models. The distinction between EFMs is determined by the language of implementation; 
currently SystemC and UML implementations are supported. 
Details of the implementation and communication mechanism of EFMs are omitted in this 
chapter since they are explored and discussed in details in Chapter 5. 
4.3.4 Local Communications Control Services 
The Local Communication Control Service (LCCS) is a Linux-based application that controls 
and regulates the communication between different applications, systems or subsystems. The 
ViPERS modelling environment is composed of different tools that are required to 
communicate with each other at simulation time. This communication needs to be regulated 
and messages routed to appropriate destinations. Internal blocks or subsystems might be 
implemented in different languages and/or use different simulation engines. The local 
communication control service enables different tools to run on different computers and 
communicate through the network irrespective of their platform. LCCS is designed to deal with 
the heterogeneity of the ViPERS simulation environment,: 
Applications, models, virtual prototypes, internal blocks and subsystems which are simulating 
will be referred to as distributed objects, for the purpose of illustrating LCCS. 
LCCS serves five main purposes within the ViPERS environment: 
1. Interconnecting tools. The ViPERS simulation environment connects together different 
tools such as VOM, Rational Rose RealTime, CoCentric System Studio and Visual 
Studio. Additionally the open architecture of VDM allows the connection of other 
external tools and simulations. Tools wishing to communicate within the ViPERS 
simulation environment need to register their presence with the communication 
framework. LCCS enables external tools to communicate with each other during a 
simulation. More than one instance of the same tool can be made to connect to LCCS. 
An ID tag given by the connecting tool during the registration process allows LCCS to 
establish its identity in a unique way. 
- 98 -
Chapter -I The ViPERS Methodology and Environment 
2. Interconnecting virtual prototypes. A simulation might comprise multiple virtual 
prototypes interacting with each other. In most cases the communication is set up 
between the behavioural models of the interacting virtual prototypes. In some cases, 
though, a designer might not need to build a behavioural model for a virtual device if 
this is not a significant part of the simulation, or if there is no interest in modelling its 
behaviour. 
3. Interconnecting models (behavioural and graphical models). The behavioural model 
and its graphical counterpart need to communicate during a simulation. In addition the 
behavioural models of different virtual prototypes need to communicate with each 
other. 
4. Routing messages. LCCS is in control of routing messages to their destinations. The 
routing process is later described with the use ofUML diagrams. 
5. Registering distributed objects. LCCS stores in an internal register all the objects that 
take part in a simulation. The registration process determines whether an object should 
be accepted into the simulation environment or not. Objects which wish to 
communicate within the ViPERS simulation environment need to be registered with 
LCCS. Messages which are not a request to register and corne from unregistered 
objects, will be automatically discarded. 
The Local Communication Control Service is made of four main units as shown in Figure 4-13. 
These units are: 
 The Server Unit. 
 The Register Unit. 
 The Parsing Unit. 
 The Control Unit. 
4.3.4.1 Server Unit 
The server unit is implemented using standard TCPIIP sockets. The socket is implemented as a 
server and it is non-blocking. This allows the server unit to be constantly listening to the 
network for incoming messages without blocking the process on the listen function. The server 
- 99-
Chapter 4 The ViPERS Methodology alld Ellvironment 
unit is not in charge of checking the validity of the objects which connect. It will accept all 
clients which try to connect and receive messages from them. 
LCCS.DLL plug-In 
Figure 4-13 Local Communication Control Services 
4.3.4.2 Register Unit 
( ,-. \ 
"8 I ' , I " ~\ :~: v.temC ,~, 
\ : : , , 
" .. I I 
SxSockets Library 
For CoCentrlc 
The register unit is the memory of LCCS, and it is where the ID tags of the distributed objects 
that take part in a simulation are stored. It is necessary for an object to be registered within this 
unit in order to access the routing services provided by LCCS. The register unit stores objects 
hierarchically. Applications are stored at the top level, and internal blocks at the lowest level. 
Distributed objects are stored and managed with the use of joined linked lists. Figure 4-14 
shows an example of a simulation where two graphical models running on two separate 
instances of VDM are interacting with a behavioural model running on CoCentric System 
Studio. 
The register unit stores two nodes for the VDM objects (VDMl and VDM2) and one for the 
CoCentric object (CoCel) in the top level linked-list. Associated with each object in the top 
level linked-list there is another linked list which contains the respective internal components. 
In the diagram shown in Figure 4-14 for example, the CoCei object is associated with a linked 
list which contains the internal sources and the sink of the SystemC model. The sources 
components are the buttons (BU1, BU2, and BU3) and the sink is the display (DISPJ). VDM 
simulations only require one internal object to communicate since an internal plugin 
(LCCS.Plugin) controls the internal routing of messages to the buttons and the display. The 
structure implemented in the register unit is intended to enable different hierarchical levels to 
communicate. If an object wants to communicate with an internal block then the message needs 
- 100 -
Chapter 4 The VIPERS Methodology and Environment 
to contain both the ID tag of the application and of the specific internal block. The control unit 
scans the linked list of applications first, and once it finds the application it enters its sub-linked-
list and locates the specific object. Another advantage is the possibility of running more 
instances of the same application simultaneously. This was one of the requirements for the 
ViPERS framework due to the desire to simulate multiple virtual devices simultaneously, 
interacting with each other in the same simulation environment. 
Register 
Application 
Message 
Parser 
<R><A>YDMI 
<R><A>CoCel 
<R><A>VDM2 
<R><A>CoCel<P>BUl 
<R><A>CoCel<P>BU2 
<R><A>CoCel<P>BU3 
<R><A>CoCel<P>DISPl 
<R><A>YDM1<P>YDMPl 
<R><A>YDM1<P>VDMPl 
<R><A>VDM1<P>VDMPl 
<P>BU1<M>"TRUE" 
4.3.4.3 Parser Unit 
Register 
\ , , 
VDMPl 
I;"'~~I 
Figure 4-14 Register and parser classes 
CoCel I ; .. ,~~ I , , , 
BUi I I 
\ , , 
BU2 I 
\ , , 
BU3 I , , , 
DISPl I 
VDM2 I 
\ , , 
VDMP:Z I 
All the messages received by Lees are of type string. The strings are tagged messages. The 
parser unit parses the messages which are received by LeeS. The control unit is able to 
understand and direct messages only after they have been parsed by this unit. The parser is 
responsible of checking the correctness of messages. The syntax rules used to check the 
validity of messages are defined in the communication protocol for the ViPERS environment. 
Messages which are syntactically wrong are discarded. The parser unit extracts all the 
information contained in the tagged messages (ID tag, destination tag, application tag, etc.) and 
provides it to the control unit. 
- 101 -
Chapter 4 The ViPERS Methodology alld Ellvirollmellt 
4.3.4.4 COlltrol Ullit 
This unit manages the other three units which constitute LCCS. The control unit enables 
distributed objects to connect through the server unit and to register their presence in the register 
unit. It instructs the server unit to receive messages and the register unit to check the 
registration status of the object. It stores objects in the memory and retrieves the information 
when needed. It instructs the parser unit to parse messages and then retrieves the information 
relative to that message. It is also responsible of sending messages to their destination. If an 
external object, which is not currently supported by the ViPERS environment, needs an ad-hoc 
mechanism to communicate with LCCS the code needs to be added in this unit. While other 
units need to be kept as they are, the control unit can be extended as long as the added 
mechanisms do not conflict with existing ones. 
4.3.4.5 Platform Issues 
One of the main purposes of LeeS within the ViPERS framework is to enable the 
communication of CoCentric models with VDM. CoCentric is a Linux-based application while 
VDM is Windows-based. Figure 4-15 shows the possible distributed simulations that can be set 
up using LeeS. 
1 or more Llnux : 
Application 1 
_______________ 1 
Figure 4-15 LCCS, platforms and combinations 
- 102 -
Chapter 4 The VIPERS Methodology and Environment 
As shown in Figure 4-15, LCCS does not need models from both applications (VDM and 
CoCentric) to set up a simulation. LCCS can be used to feed and receive messages to a host 
application by simulating the presence of another application. This feature can be used if one of 
the models (graphical or functional) has yet to be implemented. 
4.3.4.6 The design and implementation of LCCS with UML 
LCCS has been designed in UML and the base classes automatically generated in C++. The 
initial experiments have been carried out with a first version of LCCS implemented on the 
Linux platform using the Kylix 3.0 programming tools from Borland. 
LCCS was designed in UML as shown from Figure 4-16, Figure 4-17, and Figure 4-18. The 
structure, the purpose and the interaction mechanism of LCCS were designed and modelled 
using UML class diagrams, use-case diagrams and sequence diagrams. The UML design allows 
easy reimplementation of this application. This allows LCCS to be easily ported to different 
platforms and allows developers to add new mechanisms. 
-103 -
Chapter 4 The VIPERS Methodology and Environment 
Class Diagram 
The class diagram below is a conceptual diagram which shows the classes involved in 
connecting CoCentric with VDM in the ViPERS environment. As it is a conceptual diagram it 
is not implied that these classes are actually implemented in a programming language. 
As shown in Figure 4-16, the main classes, VDM, LCCS and CoCentric are associated with a 
common class. This class is the Socket class which is the base class for all the TCPIIP sockets 
used to support the communication framework ofthe ViPERS environment. 
IE l LaS IQQrtricI 
+LadlI( ) *r-+Ru1li ( ) 1~~ I 0ICISh CbrCrcIIHt 
* -tteVtM +S1arfTITeIId ( ) yy 
\11M I 1~-1teIJsIOSIriIs ~- ttaJsUlScucIs 
- tIlCIIeI1SajB 
+~ret +~ret 1 -1t1e5er\eSoct8 
0III1ISocIIIt + Wc:IeS1rilIToSt/1rg ( ) +iwtr1at( ) +Iwfrat( ) SIMISDdtIt +~dIttcIIS1rItlI ( ) +1wt4t( ) +1wt4t( ) + 4Iirbo IinIe 
+t4r'P I1nIe 
+Ane( ) +Rrd( ) +Rrd( ) 
~ -lheRegIsta' +Brd( ) 
+BrD( ) 
+ RiIm:J,e ( ) +Aerro.e( ) 
+carect( ) 
+Serd( ) +UsIEn( ) 
RIgIIt8r 
+ReaNe( ) +SalI( ) 
+ReaNe( ) + hierttiJst: ( ) 
I +AImMFraTt.it ( ) 
+<DtfrartJst ( ) 
 -1t'eSIric ~7 + REgIster ( ) * -theScua 
SDdtIt S'Iuca SHe 
0.. - thelJsICDats + <iIr1rVt SacIQd) 
+4'PiICltfiMtlI de +tQrIrvt SodeII) 
I.iItOiDdIIb + <iIr1rVt SImJaIkrII) +~ SIrrUIaalI) 
+Aaqt( ) 
+4&xtIIP head +~1Gtess 
+ <iIr1rVt Jtd:t-. 
+carect( )  +4'P~ 
+4&xtIIP ret +4'P~ +Brd( ) -1I'eScxiB 
+~() + hia1frat ( ) 
+UsIEn( ) + I1iertft ( ) 
+Serd( ) +Rrd( ) 
+ReaNe( ) +RImM( ) 
Figure 4-16 Class dlaaram for LCCS 
- 104 -
Chapter 4 The VIPERS Methodology and Envirollment 
Use-case diagram 
Lees acts as a server between a graphical model and a behavioural model. For this reason its 
main purpose is to send and receive messages to and from client applications. Messages can 
have very different natures as shown in the use-case diagram in Figure 4-17 . 
.. ~ecely. Meaaves from ~ 
,,/ ~ CoCentric ~ 
.// / '" 
.. / / / 
,/~i~ude- / I 
... // ;/ -Include- Include- / 
Registering the ;' I 
Simuliition I 
\ ~rslng the : esSilg0 I _I _---__ 
\\\ \ 
\ \ ~/' 
indude- \ \ ~/ 
'~~nclude- \ //"'nclude-
\ \ / 
\ \ ?/ 
\ \ I( 
~Y.M=rSfro~ 
Transports the Outputs 
of the BeNlvlourei Model 
to the VIsual Model 
Receive Messeges 
Figure 4-17 Use-case. Actor: LeeS 
- 105 -
Interrupt Simulations 
- Include-
Interact with 
Simulations 
Kill Simulations 
Chapter 4 TIre ViPERS Methodology alld Ellvirollmellt 
Sequence Diagram 
Figure 4-18 shows a typical interaction between vDM, LCCS and CoCentric. The processes 
illustrated in Figure 4-18 are explained in more details later in this chapter. 
------- --
Repeat these two stages 
for all the sources in the 
CoCentric model 
, Repeat these two 
I stages for all the sinks 
in the Cocentric model 
1 : \<REGVDM>VD ... 
3 : \<VDMID>VD ... 
\ < ST ARTSIM >COCENTRIC <VERSIO 
N> 2003.03< SIMNAME> REMOTE\ 
... ... 
\ <51 MID> REMOTE 1 <OBJECT> BUTT 
ON1 <MSG>UP\ 
14 : \TE5T\ 
I j CoCentric Simulat... J 
6 : \S tern COCENTRIC REMOT.. . 
\<REGSOURCE>BUTTON1<5IMID>R 
EMOTE1\ 
8 : \Sources 
UstAdd(REMOTEI,BlJTTONI)\ 
\<REGSINK>LCD1 <5IMID>REMO ... 
\<5IMID>REMOTE1 <OBJECT>LCD1 
<MSG>TEST\ 
The list containing 
REMOTE will be 
associated with one or 
more VOM simulations. 
From that 
association LCD will 
know where to send its 
messages. 
Figure 4-18 Sequence diagram for an LCCS connection 
LCCS as well as the distributed objects that intend to connect to the ViPERS simulation 
environment need to conform to a communication protocol. The protocol defines the rules and 
- 106 -
, ______________________________ ~C~h~Q~p~t~e~r~4~T~h~e~V~/~P~E~R~S~M~et~h~o~d~o~l~og~y~a~n~d~E~n~v~/r~o~n~m~e~n~t 
syntax for the passing of tagged messages between distributed objects within a simulation. It is 
an XML-style protocol and the syntax of messages is presented in the next section of this thesis. 
4.3.5 The ViPERS Message Protocol 
Table 4-1 shows the tags used within the messages used in the communication of distributed 
objects. The table shows the tags, and a brief explanation of the field of each tag. 
TAGS Short Field 
<REGVDM> <R> The name of the simulation that is running in VDM. 
<VDMID> <VID> The handle of the simulation that is running in VDM. 
<STARTSIM> <S> The name of the application that has to be launched. 
<VERSION> <V> The release version of the application. 
<SIMNAME> <SN> The name of the simulation that needs to start. 
<REGSOURCE> <RSC> The identity name of the source the user wishes to register. 
<SIMID> <SID> The handle of the simulation to which the 
source/sink/object belongs 
<REGSINK> <RSK> The identity name of the sink you want to register. 
<OBJECf> <0> The identity name of the source/sink that wants to 
communicate. 
<MSG> <M> The message that has to be sent. 
Table 4-1 - tqs for LCCS communication protocol 
4.3.5.1 Description of Tags 
This section presents the different tags, and their use within the ViPERS environment. 
<REGVDM> or <R> 
This message is sent by YOM to request registration to LCCS. If the message is valid, LCCS 
will start the registration process for this instance of VDM. The field of the message provides 
the identity name of this instance. LCCS will store this identifier string in a linked list 
-107 -
'-______________________________ ~C~h~a~p~te~r_4~T~h~e~V~IP~E~R~S_M~e~th~od~o~/~o~g~y~a~n~d~E~n~v~l~ro~n~m~e~n~t 
containing all the registered objects. It will then return a handle of that instance. The handle is 
needed especially when more than one instance of the same tool are present in the same 
simulation. Example: '<REGVDM>VDM or <R>VDM 
<VDMID> or <VID> 
Lees sends this message to VDM after registering its presence. The string in the field of this 
tag is a handle of the simulation. This handle represents the identity of the simulation and it is 
used by LeeS when it wants to send a message to that object. Example: '<VDMID>VDMJ or 
<VID>VDMJ' 
<ST ARTSIM> or <S> 
This message is sent to LeeS to request that a simulation is started. This message is followed 
by another two tags, one for the version of the tool and one for the identity of the simulation. If 
these tags are not specified, then the default version of the tool and the last simulation are 
executed. Example: '<ST ARTSIM> VDM J or <S> VDM J' 
<VERSION> or <V> 
This tag can only be attached after the STARTSlM tag and it specifies the version of the tool 
which contains the distributed object. Example: '<VERSION>2004.03 or <V>2004.03' 
<SIMNAME> or <SN> 
This tag specifies the name of a simulation that VDM has requested to start. Once the 
simulation starts successfully, LeeS sends a message to VDM sending the handle to this 
simulation. This enables VDM components to identify the destination of the messages. 
Example: '<SIMNAME>REMOTE or <SN> REMOTE' 
<REGSOURCE>or <RSC> 
This tag is used to register the sources. This tag is followed by another tag that specifies the ID 
of that source. When Lees receives this message it stores the identity name of that source in a 
linked list. Example: '<REGSOURCE>BU7TONJ or <RSC> BU7TONl' 
<SIMID> or <SID> 
This tag is used to specify a handle to a simulation; it is usually used in messages containing a 
source, or a sink, or an object that needs to specify to which simulation it belongs. The ID of 
- 108-
Chapter 4 The VIPERS Methodology and Environment 
the simulation is used by LeeS to locate the specific linked list associated with that object. 
Example: '<SIMID>REMOTEl or <SID> REMOTE}' 
<REGSINK> or <SNK> 
This tag is used to register the sinks. This tag is followed by another tag that specifies the 
identity name of the sink. When LeeS receives this message it stores the handle of this sink 
into a linked list. Example: '<REGSINK>LCDl or <SNK> LCD}' 
<OBJECT> or <0> 
This tag is used when an objects wishes to send a message to another object within the same 
simulation. The field of the tag is the handle to that component; this can be a sink or a source. 
Example: <OBJECT>BUITONl or <0> BUTfON1' 
<MSG>or<M> 
This tag simply specifies the message to be sent; it always follows an object tag which tells 
LeeS where to direct the message. Example: '<MSG>DOWN or <M> DOWN' 
4.3.5.2 Example 
YOM REGISTERS ITSELF: 
Table 4-2 shows the messages exchanged between YOM and Lees when YOM is registering 
for a simulation. 
Sender Receiver Action Message 
VDM LCeS Request to <REGVOM>VDM 
Register 
LCeS VOM Handle to <VDMID>VDMI 
Registration 
Table 4-1 - VDM registration messages 
-109 -
Chapter -I The VIPERS Methodology and Environment 
VDM REQUESTS A SIMULATION TO RUN: 
Table 4-3 shows the message sent by VDM to LCCS in order to start a simulation within 
CoCentric. LCCS returns a handle to VDM for that simulation. 
Sender Receiver Action Message 
VOM LCCS Request a Simulation <ST ARTSIM>COCENTRIC<VERSION> 
to Start lOO3.03<SIMNAME>REMOTE 
LCCS VOM Handle to Simulation <SIMID>REMOTEI 
Table 4-3 - VDM simulation request messages 
LCCS STARTS SIMULATION. 
SIMULATION BLOCKS IN COCENTRIC REGISTERS WITH LCCS: 
Table 4-4 shows the messages sent by the internal sources and sinks within the CoCentric 
simulation in order to register their presence with LCCS. 
Sender Receiver Action Message 
Source LCCS Request to <REGSOURCE>BUTTONI <SIMID>REMOTEI 
Blocks Register 
Sink LCCS Request to <REGSINK>LCDI <SIMIO>REMOTEI 
Block Registration 
Table 4-4 - CoCentric registration messages 
RUNNING MODE: 
Table 4-5 shows the typical messages exchanged between the VOM graphical model and the 
CoCentric behavioural model. 
- 110-
Chapter" TI,e ViPERS Methodology a"d E"virollmellt 
Sender Receiver Action Message 
VDM LeeS Sends a <SIMID>REMOTEI <OBJECT>BUTTONI <MESSAGE> 
Message UP 
Block Message 
Table 4-5 - running mode messages 
4.3.6 LeCS Connection to VDM 
When a model is loaded, VDM (lccs.dll) attempts to establish communication with a server 
specified within the model description. The model provides all LeeS configuration relevant to 
the model within the simulation node shown in Figure 4-19. 
<VDMTaggedFile> 
<simulation> 
<lees> 
</lees> 
</ simulation> 
</VDMTaggedFile> 
<server>139.184.100.123</ server> 
<port>1234</port> 
<startsim>COCENTRIC</8tartsim> 
<version>2003.03< / version> 
<simname>REMOTE</ simname> 
Figure 4-19 YDM file section for connection to LCCS 
To establish communication VDM begins the LeeS handshake sequence: 
1. A socket connection is opened to server:port 
2. <REGVDM>vdm is sent 
3. <VDMID>vdmid</VDMID> is received 
4. <STARTSIM>COCENTRIC<VERSION>2003. 03< S IMNAME > REMOTE is sent 
- 111 -
- Chapter 4 The ViPERS Methodology and Etlvirotrmetrt 
5. YDM waits for the SIMID to be returned - the format expected is: 
<SIMID>REMOTE1</SIMID> 
6. The simulation sends actions and messages to YDM. All messages are preceded by 
<SIMID>simid</SIMID> 
 An action enables an object to be modified e.g.: 
o <SIMID>simid</SIMID><action>FagorRemote.Display.Large 
7Segl.visualise.drawimage="O"</action> 
o <SIMID>simid</SIMID><action>FagorRemote.Keyboard.Butt 
on2.visualise.opacity="30"</action> 
 A message is handled by objects in the model and can be used to trigger multiple 
actions: 
<SIMID>simid</SIMID><message>FagorRemote.Display=\\ALLOFF"</message> 
In the above example a message handler within the FagorRemote.Oisplay namespace sends the 
appropriate actions to tum the display off. YOM sends messages to the simulation. These 
messages are triggered from actions within the model. A string sent as an action to 
Simulation.LCCS.Outgoing is wrapped and transmitted. As an example this is the message 
handler for a button (buttonl) as described in the model definition shown in Figure 4-20. 
<object> 
<id>Buttonl <lid> 
< type>image</type > 
<visualise> 
<message> 
<image><bitmapid>button</bitmapid> </image> 
<position> <x>136</x> <y>290</y> </position> 
<trigger>MouseDown</trigger> 
<action>this.visualiae.drawimage="t" </ action> 
</visualise> 
<action> Simulation.LeeS.Outgoing = "Buttont.MouseDown" </ action> 
</object> 
</message> 
<message> 
</message> 
<trigger>MouseUp</trigger> 
<action>this.visua1ise.drawimage=" 0" < / action> 
<action> Simulation.LeeS.Outgoing = "Buttont.Mouse Up" </ action> 
Figure 4-20 VDM file section for interactivity 
The messages are wrapped up into the LCCS protocol: 
- 112 -
~ _________________________________ ~C~h~a~p~t~e~r~4~T~h~e~V~i~P~E~R~S~~~e~t~h~o~d~o~l~o~g~y~a~n~d~E~/~lv~i~r~o~n~m~e~n~t 
<SIMID>REMOTEl< / SIMID><MESSAGE>string from action</MESSAGE> 
4.3.6.1 A workillg example of LCCS 
Figure 4-21 shows a typical interaction through LCCS of a YDM model with a SystemC model 
implemented in CoCentric System Studio. The diagram is part of an experiment which is 
described in more details in chapter 5. 
r------------------------------------, Local Communication Control Service - LCCS 
Registration Message 
SondMeuoge(roglOterPort. myVDM .VDMPort) ; 
Simulation M_ge 
Sond_e(BUTT_ I . myVDM .lrue); 
Realster: 
Applic.tion: Appllc.otlon: 
APPlICATION_A APPlICATION _ B 
Port: Porta: 
VOMPort :lOOOO BUTT_ I : lOOO 
BUTT_2 :l000 
BUTT_ l:lOOO 
BUTT _4: lOOO 
BUTT_ 5 :l000 
BUTT_6:l000 
BUTT _7: lOOO 
BUTT _8 : lOOO 
SondMe .. oge(reg'''erApp. APPUCAnON_1I  myCoCenlric. '); 
Simulation M_ge 
SondMe_e(VDMPort. myCoCenlrlc ,lrue) ; 
(CoCentr1c) 
Figure 4-21 LCCS in a simulation environment 
As shown in Figure 4-21, the YDM instance requests registration to LCCS but not of individual 
components (e.g. buttons and display). CoCentric registers both the application and each 
socket component (sources and sinks). The socket components in CoCentric correspond to the 
eight buttons and the display of the virtual prototype. The eight buttons in the VDM model are 
connected to eight source components in the SystemC model. When a user presses a button on 
- 113 -
~ _____________________________ ~C~h~aP~te~r~4~T~h~e~V~/P~E~R~S~M~e~t~h~o~d~o~/o~gwy~an~d~E~n~v~l~r~on~m~e~n~t 
the graphical model, a message is sent to the source component corresponding to that button. A 
sink component is connected to the VOM display model. The sink component instructs the 
graphical display on how to update. VOM does not need to separately register each component 
because the LCCS.OLL manages the internal routing of the messages. The diagram shows the 
hierarchical structure of the register unit, and how the applications and internal blocks are 
stored. Typical registration messages and other types of messages are shown in this example. 
4.4 ViPERS Vs Industrial Prototyping Tools 
Existing virtual prototyping software focuses on the functional implementation and user 
interaction features of a device, with some solutions offering routes to assisted software 
generation. The observation is that these tools are weak regarding some aspects of virtual 
prototyping because: 
 The lack of photorealism in the graphical prototype, fails to fully exploit the potential of 
virtual prototyping 
 The lack of tooling and methods to connect the virtual prototyping results to 
downstream System on Chip (SOC) tooling (which concentrates on design work 
downstream from RTL) 
 Accurate specifications of the device behaviour are assumed to be produced as an 
isolated process at the start of the design process 
 The tools are not specifically set in the context of a design methodology 
 The tools do not exploit the use of virtual prototypes for performance exploration 
A key concern with existing virtual prototyping tools [42, 66, 67, and 68] is the functional 
nature of the graphics. An ad-hoc approach adopted by some engineers involves a custom 
prototype built in MS Visual Basic or similar high-level environment. The premise of this style 
of approach is that the graphical quality of the model is not important; the purpose of the virtual 
prototype being only to demonstrate the sequence of user interaction events. The ViPERS 
approach is built on the desire to accurately model the detailed graphical look of a device to 
further exploit the potential value of virtual prototyping; this approach can be used to reduce the 
imagination gap between the appearance and style of the virtual prototype and the final product. 
If the intention of the virtual prototype is to ensure that all stakeholders have a common frame 
of reference for the final product then any lack of detail in the graphical quality could have the 
- 114-
- Ch"pter 4 The VIPERS Methodology "ltd Eltvlrolt",eltt 
result that the final product does not satisfy all the requirements of a diverse group of 
stakeholders. 
Other key concerns in the ViPERS approach are the application of the prototyping environment 
in the context of a methodology and an assisted route to downstream SoC tooling. Different 
applications and services that constitute the ViPERS environment are connected together in 
order to create direct links between the different phases and tools of the methodology, thus 
avoiding unnecessary work or translations. Where design methodologies or tools already 
existed, they were incorporated in the ViPERS framework. The ViPERS approach provides an 
assisted route to downstream SoC tooling, down to the RTL level. The SystemC methodology 
for system level design of complex SoC [10, and 85] was incorporated in the ViPERS approach 
for this purpose. Communication services and processes are provided to incorporate the 
SystemC methodology and tools inside the ViPERS methodology/environment. Existing 
prototyping tools seemed to predict such links but did not offer an assisted route. 
Finally, it is clear from the research in the field of requirements and specification development 
[92] that the specification work is unlikely to be confined to the period before implementation 
begins. Determining accurate product requirements and specifications is a vital stage in the 
development ofa commercially viable device and the ViPERS methodology can help extend the 
value and meaning of the requirements and specification phase to further ensure the validity of 
this work before implementation begins [113]. Hence there is a need to rapidly feed changes in 
the requirements into the implementation tool chain in an evolutionary way. It is common for a 
design house to be given a written specification for a prototype device. Often the specification 
is not complete enough for the first resultant prototype to be satisfactory to the client, resulting 
in some design iterations. If the design house were to build a virtual prototype or even several 
alternative schemes, the client could clarify the specification before any hardware or software is 
built, so that the virtual prototype is a form of communication and reference in addition to the 
written specification [59]. 
The next section provides a comparison between the ViPERS framework and the major virtual 
prototyping suites available on the market. 
4.4.1 ViPERS Vs Cybelius 
Cybelius has emerged during the course of this work as one of the major commercial virtual 
prototyping tools. One of the main differences between Cybelius and the ViPERS framework is 
the language of implementation. While the ViPERS environment is strongly C++ oriented, 
Cybelius is Java based. Cybelius otTers platform independence and strongly focuses on Web 
-115 -
Chapter -I The VIPERS Methodology and Environment 
applications of virtual prototyping. Java offers more support in these fields than C++. The 
ViPERS framework instead is mainly concerned with speed and real-time simulations and is 
therefore implemented in C++. Another difference is in the toolset. Cybelius provides 
proprietary tools to implement virtual prototypes, including a tool which is used to model the 
functionality of prototypes through state machines. In ViPERS, tools were developed only if 
existing ones did not provide adequate support. For functional modelling for example, the 
ViPERS environment provides the means (software tools, packages and libraries) to connect to 
tools such as Rational Rose RealTime, CoCentric System Studio and Visual Studio.Net. The 
ViPERS framework, unlike Cybelius, supports contextual virtual prototyping by providing 
interaction of virtual prototypes into three dimensional virtual environments. The main 
differentiation of the two environments is in the link to hardware. The ViPERS approach is 
strongly oriented towards making virtual prototyping techniques part of a methodology that 
goes from requirements analysis to low level implementations of hardware and software 
components. While Cybelius intends to enhance the conceptual and marketing phases of target 
products, the visual layer of the ViPERS environment targets to aid the entire design flow of an 
electronic product. Cybelius, as ViPERS, provides an open architecture that enables the linking 
of other applications to the environment and the possibility to create plug-ins. Both 
environments provide the possibility of creating both two dimensional and three dimensional 
models, but the ViPERS environment is focused on photorealism. They both support a library 
system to store and reuse graphical and functional objects/components and in addition they 
support distributed simulations. 
4.4.2 ViPERS Vs Altia, And, E-Sim. 
Unlike the ViPERS environment, Altia, And, and E-Sim provide support only for two 
dimensional graphics (not 3D), and do not support virtual environments. Graphical models 
created with these tools are not photorealistic. E-Sim and And both provide support for the 
creation of functional models with their own tools while Altia and ViPERS provide the means 
to communicate with external tools. ViPERS is the only environment to provide a solid link to 
hardware, while the tools compared only provide a link to embedded software through 
automatic generation of code. They all support a library system to store and reuse graphical and 
functional objects/components. Table 4-6 shows a comparison between the ViPERS framework 
and other virtual prototyping tools based on the analysis made in the previous sections. The 
table shows which feature are available and which not in the different tools. 
- 116-
CybeUus Altla And E-sim ViPERS 
Library for 
./ ./ ./ ./ ./ 
components 
Reuse of Graphical 
and Logic ./ ./ ./ ./ ./ 
Components 
Interactive models ./ ./ ./ ./ ./ 
Code Generation ./ ./ ./ ./ ./ 
Own Graphical 
./ ./ ./ ./ ./ 
Editor 
Own Logic Editor ./ X ./ ./ X 
Linked to Hardware X X X X ./ 
Linked to Software ./ ./ ./ ./ ./ 
Part ofa 
X X X X ./ 
Methodology 
State Machines ./ ./ ./ ./ ./ 
Virtual Environments X X X X ./ 
- 117-
Chllpter 4 The VIPERS Methodology lind Environment 
2DGraphics ,/ ,/ ,/ ,/ ,/ 
3D Graphics ,/ X X X ,/ 
Photorealistic 
X X X X ,/ 
Graphics 
Web Support ./ ./ ./ ./ ./ 
Sharing of 3D 
,/ X X X X 
Content 
In-Built Support for 
X ./ X X ,/ 
External UML Tools 
Distributed 
./ ,/ - - -
Simulations 
Open architecture ,/ - - - ./ 
Plug-ins Support ./ - - - ./ 
Table 4-6 ViPERS Vs Industrial virtual prototypinl tools 
-118 -
Chapter 5 
EFMs - Executable Functional 
Models 
- Chapter 5 EFMs - Executable Functional Models 
EXECUTABLE FUNCTIONAL MODELS 
n the ViPERS approach, Executable Functional Models are defined as 'models that 
describe a number of properties associated with the functionality of an electronic system; 
they are independent executables which contain the means to communicate with an 
external application for simulation purposes '. As described in the previous chapter VDM is the 
nucleus of the ViPERS prototyping environment. The combination of an executable functional 
model with a VDM graphical model constitutes the simulation environment of the ViPERS 
framework as shown in Figure 5-1. 
The material presented in this chapter has also been published in [24,25, and 26]. 
5.1 Introduction 
Chapter 4 described the refinement steps related to the ViPERS methodology and the 
consequent creation of virtual prototypes that result from the four main phases (analysis, design, 
implementation and test). Virtual prototypes are distinguished by the phase of the design flow 
they are generated from, and therefore which features of the target device they incorporate; each 
virtual prototype implements an EFM. The virtual prototypes are: 
1. Functional Prototype; this is a product of the analysis phase, where the requirements 
and specification of the target product are analysed and defined. 
2. Architectural Prototype; this is a product of the design phase, where architectural 
design takes place and hardware/software partitioning of the electronic system is 
defined. 
- 120-
___________________________________ C~h~ap~t~e_r_5 __ E_F~M~s_-~E~x~e~c~u~ta~b~/~e_F~u~n_c~t~l~o~n~a~/_M~o~d~e~/~s 
3. Digital Prototype; this is a product of the implementation and test phases, where all the 
hardware and software blocks that constitute the target electronic device are 
implemented and then tested. 
Executable functional models provide a means to simulate the target device in different phases 
of the design flow and analyse its requirements (behaviours, interfaces, etc), architecture 
(HW /SW partitioning) and finally its digital implementation. The aim of executable functional 
models is to simulate the behaviour of the virtual prototype (functional, architectural and 
digital) throughout the design and implementation stages. 
The ViPERS methodology and its environment provide the specific tools, libraries, packages, 
and services needed to connect EFMs to the target graphical model. 
EFMs are developed to test various features of the target electronic product; these features 
include: 
 Functional properties 
 Graphical User Interfaces and User Interactivity properties 
 Architectural issues such as HW /SW partitioning 
 Digital/structural properties, explored through the verification of the hardware/software 
implementations 
The ViPERS approach currently provides support for two types ofEFMs, which are: 
1. UML-~xecutable functional Models QJ.ML-IDMs), which are implemented in 
Rational Rose RealTime. 
2. SystemC-~xecutable functional Models (SystemC-~s), which uses either: 
 The freely downloadable SystemC library and Visual Studio version 
6.0 (Windows-based),and 
 CoCentric System Studio from Synopsys (Linux-based) 
- 121 -
Chapter 5 EFMs - Executable FUllctiollal Models 
~-------------------------------------~~~-~~~~~~~~~~~~~~~~~~~~--
:1::$ 
I:J :LL 
'- -- --
QJIIl 
E 'iii 
.- ttl 
::Je: 
.0 .-
X (I) 
III e: 
/0 QJ 
L. L. 
1- ___ _ 
iO 10 
.r:. L.Ol ::Je: 
Cl- t:l= 
C QJQJ 
0\ ~"lJ .r:.o 
'iii ~~ 
Q)  0 
.0 .-
3: .~ 
1Il"lJ 
III e: 
(I) /0 
I l: :.s 
1 ____ -
QJ ttl 
1Ilet: 
Figure 5-1 EFMs allocation in the ViPERS methodology 
1'0 C 
:J ... 
E'-.- > 
C.fu 
1'0 C 0 
CQ)U) 
.2' E It-
IIIQ)O 
Q)-co. 
UML-EFMs use a UML package to connect to YDM and were demonstrated by Lister et al 
[24]. SystemC-EFMs implemented using the freely downloadable SystemC class library use a 
SystemC-container application which enables the communication of the EFM with the YOM 
model and were demonstrated by Lister et al [21]. The second type of SystemC-EFMs 
- 122 -
Clu.pter 5 EFMs - Executable Functional Models 
(CoCentric) uses the SystemC library for CoCentric, SxSockets Library, in conjunction with the 
local communication control service (LCCS) and was demonstrated by Lister et al [25]. 
Drawbacks and advantages of the different approaches in different stages of the methodology 
will be described in this chapter. 
S.2 UML-EFM 
This section presents the use of UML-EFMs in the context of the ViPERS virtual prototyping 
methodology. 
5.2.1 Introduction 
Existing tooling for SoC design tends to assume that an accurate specification of the device 
behaviour has been developed as an isolated activity at the start of the design process. The 
ViPERS approach integrates the requirements analysis and specification process into its design 
flow. Virtual prototyping is applied in these stages to ensure a common understanding between 
designers and engineers as well as non-technical members such as investors and management 
teams related with the development of the target product. UML provides diagrams to intuitively 
describe systems in a standard way. Additionally it provides the capability to describe systems 
without committing to any language of implementation. The use of UML for the requirements 
analysis phase of software is a widely accepted practice and benefits from a wide industrial 
support. In the ViPERS framework standard UML diagrams are employed to support state 
machines and capsules, which offer extended dynamic features to existing descriptions. The 
result is an executable model which is used in conjunction with a graphical model to implement 
a virtual prototype. In the ViPERS approach this executable model is referred to as an UML-
The first step in the ViPERS methodology is the analysis phase and the consequent production 
of a UML-EFM derived from it. Several methods of requirements gathering have been explored 
including traditional written reports and UML based tooling. UML provides the means to 
document detailed requirements which can lead, with the aid of software tools such as Rational 
Rose RealTime and the use of state machines, to the production of the first behavioural model 
of the electronic device. As described by Selic and Rumbaugh [97] Rational Rose RealTime is 
built on the UML-RT profile, which, due to its limited architecture and performance modelling 
capabilities, should be considered complimentary to the UML Profile for Schedulability, 
Performance and Time (also called the Real-Time UML Profile). Rational Rose RealTime was 
chosen above other UML real-time software tools [114, and lIS] because of the plan by 
Rational Rose to implement a SystemC profile [lOS]. 
-123 -
Chapter S EFMs - Executable Functional Models 
A UML socket capsule which is part of a package, the SxUMLSocket Package, is employed to 
link the state machine of the functional model to its correspondent graphical model. 
Communication between the functional and the graphical model conforms to a XML-like 
communication protocol which defines the criteria that models need to be consistent with, in 
order to establish a connection with each other and communicate. The protocol provides 
designers with the possibility of creating EFMs of a different nature from the one described in 
this section. 
Traditional UML techniques are used to explore the requirements of target electronic products. 
Once the system is specified purely by means of UML diagrams (class, sequence, use-case, 
activity, etc), Rational Rose RealTime is used to implement a state machine that describes the 
functionality of the system. The ViPERS approach suggests the use ofUML state machines for 
the creation of the functional model in this analysis phase. The model can optionally be 
described in SystemC, using the freely downloadable toolkit or taking advantage of the 
graphical interface and automatic code generation that software tools as CoCentric System 
Studio from Synopsys offer. 
The advantages offered by UML-EFMs are clear during a simulation where the functional 
model is linked to its graphical counterpart model. Designers as well as investors, hardware 
engineers as well as end-users with no technical background can test the usability of the 
product; interaction is achieved, for example, by pressing a button or moving a slider on the 
graphical model and viewing the changes on the display or other output means of the virtual 
prototype. The designer can also view the progress of the simulation through the graphical state 
machine at run time, and track the changes between states that result from the interaction of the 
user with the VDM model. 
The interaction of the executable functional model with the graphical model is a very effective 
approach to test features such as the graphical user interface and user interactivity issues of the 
device prior to any implementation. The two elements that make up the virtual prototype 
(graphical and functional model) can be packaged together in order to be distributed over the 
Web among stakeholders or end-users for feedback. 
5.2.2 UML-EFM Implementations 
UML-EFMs are used in the analysis phase of the ViPERS approach to take advantage of the 
many advantages that a description language such as UML, with its extensive tool support, can 
bring to the definition of a system when details of the implementation have yet to be defined 
[109]. The models are developed as state machines using Rational Rose RealTime, which 
-124 -
- Chapter 5 EFMs - Executable Functional Models 
provides a familiar framework for Windows programmers; state machines are defined 
graphically and c++ code is added to the various states and transitions. These UML models 
represent a very high level description of the system, the state machine in fact is supported by 
various diagrams (class, structure, sequence, etc), as well as communication protocols to 
communicate with other threads. The UML-RT profile also introduces the capability to use 
capsules, which are differentiated from classes by their dynamic behaviour. Capsules are active 
objects that represent system components; their internal behaviour is defined by statecharts and 
they communicate with each other through stereotyped objects called ports which implement 
interfaces. The suggested approach for the development of a UML functional description is to 
create the various classes and diagrams which represent the initial high level description of the 
system. Once the first design of the system is achieved, it can be refined by adding attributes 
and operations that will be eventually used for the behavioural description of the model. A 
capsule is then implemented to incorporate the classes and give dynamic support to the system; 
the behaviour of the capsule is described using state machines. 
The communication protocol of the capsule needs to be defined so that the designer can 
commence testing the capsule by injecting signals at simulation time. As soon as the model 
functions as expected, the SxUMLSocket package is integrated into the system to provide the 
means to communicate with external applications. The integration of the two capsules and the 
structure of a basic UML-EFM are shown in Figure 5-2. 
At this stage the functional model is an independent executable which is ready to communicate 
with the VDM graphical model. The state machine can be tested through enhanced visual 
means; in fact the user can interact with the graphical model of the electronic model and view 
how the state machine processes the inputs and feeds the outputs to it. The designer does not 
need to follow the simulation through a visual representation of the state machine, which 
requires technical knowledge, but can interact with the virtual prototype as if he/she was an end-
user. Changes on the display of the graphical model or other outputs that the model might 
possess are now the means by which the designer tests the functionality of the target product. 
Some of the benefits of using UML state machines are that they are: 
 Easy to implement 
 Fast to simulate 
 Executable 
- 125 -
Chapter 5 EFMs - Executable Functional Models 
'------------------------------------~~-~~-=~~--~~~~~~~~~~~~~ 
 Parts of the state machine can be reused in later stages of the implementation 
Capsule 
State 
Machine 
Structure 
Diagrams 
UML-EFM 
SxUMLSocket 
Package 
Socket 
capsule 
State 
Machine 
Structure 
Diagrams 
Communication Protocol l 
Sequence 
Diagrams 
Figure 5-2 UML-EFM structure 
The advantages of this approach during this phase of the methodology are substantial. UML-
EFMs provide a very high level description of the target device, plus Rational Rose RealTime 
provides various tools to help the designer in the development and debugging stages. Designers 
are provided with all the means to test the usability, graphical user interfaces and interactivity 
issues of the target system. The model can easily be modified or new ones can be created to test 
different possibilities or to fix unexpected behaviours. Ideally designers would develop a set of 
possible candidate solutions for the target product, from which one would be chosen as the final 
design. The life of the UML-EFMs in the methodology is not over at this stage. It is very likely 
that the designer will need to come back to the UML-EFM when technical constraints or 
unexpected bugs make mandatory the redesign of certain features. 
The nature of the model provides fast and easy means to achieve this goal. UML-EFMs have 
another two possible uses in the VIPER methodology. These are: 
- 126-
~ _________________________________ ~C~h~G~p~te~r~j~E~F~M~s_-~E~x~e~c~u~tG~b~/~e~F~u~n~c~t/~o~n~G~/~M~o~d~e~/~s 
1. Automatic translation to SystemC-EFM; issues related with the translation 
mechanism are outlined later in this thesis. 
2. Reuse of state-machines in later stages of the design flow as embedded code; 
this is highly dependent on the implementation of the EFM state machine, 
however Rational Rose RealTime provides the means to generate code for 
specific platforms. 
5.2.2.1 SxUMLSocket Package 
The SxUMLSocket package is a UML package that provides the classes, the communication 
protocol, and the capsule needed to link the state machine describing the behaviour of the 
system to an external application. The package was developed using Rational Rose RealTime 
and Visual Studio version 6.0, and the generated code is C++. The package includes the class 
diagram, the structure diagram, the sequence diagram, and the state diagram that visually 
describe static and dynamic features of the socket capsule. Figure 5-3 shows the three UML 
diagrams used to describe the socket capsule provided into the SxUMLSocket package. The 
diagrams are: 
1. Class diagram. This diagram shows the classes and their relationship. with associated 
attributes and operations that are used in the socket capsule to implement the server 
socket and its functionality. The class diagram contains all the classes needed to 
support the socket capsule plus other classes to support new developments. The class 
diagram includes: 
 Socket Capsule Stereotype. This is a stereotype capsule which represents 
the active object of the TCPIIP socket and therefore implements its 
behaviour. 
 Sock ClIIss. This is the base class for both the server and the client 
classes. It implements all the operations which the server and client 
sockets will use such as connect, listen, accept, send, receive, etc. 
 Server & Client Classes. These classes define the functions and attributes 
that are specific for the server and the client implementation. 
 SockExcept Class. This class defines the exception cases for the socket 
implementation. 
- 127 -
'-_______________________________________ C_h_a~p_t_e_r __ 5_E __ F_Af __ s_-__ E_x~e~c_u_t_a_b_l_e __ F_u_'_'c_t_i_o_"_a_I_Af __ o_d~e_l __ s 
2. Sequence diagram. This diagram shows the sequence of events, through the exchange 
of signals, between the socket capsule and the functional capsule (i.e. the capsule that 
describes the behaviour of the target device) 
3. Structure diagram. This shows the structure of the socket capsule. The diagram shows 
the presence of a conjugate wired end port (remote_co",,,,). This port represents the 
means for this capsule to communicate with other capsules. 
, , , , 
Capsule 
Socket ' 
1) Class Diagram 
/ remoteControl : 
RemoteControl 
ro~e~O:I _______ ~ ______ ~ Ms(,Lrcvd 
2) Sequence Diagram 
MS~Lsnd 
+/remote30mm 
::Comms"" 
3) Structure Diagram 
Figure 5-3 SxUMLSocket Package, sequence and structure diagrams 
The socket capsule is implemented as a non-blocking server thread and the dynamic features of 
it are described in its state machine, visually shown in the statechart of the capsule. As shown 
- 128 -
'-_______________________________________ ~C_h_a~p_t_e_r __ 5_E __ F_A1~s __ -_E~x~e~c~u~t~a~b~/~e~F~u~,~'c~t~i~o~n~a~/~A1~o~d~e~/s~ 
in Figure 5-4 the state diagram consists of one state and two transitions; the wailing for 
messages state, the initial transition, and the sending message transition. 
Figure 5-4 SxUMLSocket Package, state diagram 
The operation of the socket capsule was purposely kept simple to allow designers to modify its 
mechanism when needed. After the initial transition, determined by the initialisation of the 
socket capsule, the state machine enters the waiting to receive state and waits through a non-
blocking receive function call for messages from the client model (YDM). The non-blocking 
feature allows the capsule to perform other operations while waiting for the client to send a 
- 129 -
Chapter 5 E FMs - Executable FUllctiollal Models 
~----------------------------------------~~-~~~~~~--~~~~~~~~~~~~~~~ 
message. Once the socket capsule receives a message, it sends it to the EFM capsule to be 
processed by its state machine. The state machine will output a signal carrying the message to 
be sent back to the YOM model and this signal will trigger the socket capsule to go through the 
sending message transition. This transition will force the socket capsule to send the message to 
the graphical model. Details of the sequence of events and interaction that take place during a 
simulation between the two capsules (socket and EFM), and the YOM model are shown in 
Figure 5-5. 
NebNork 
VDM UML-Executable Functional Model 
i EFM State Machine 
Package I 
Presses a button 
Of the 
Graphical Model 
VDM sends 
A message 
------ j ' 
To server ._- -
.. . '  ;, 1 EFM triggered By the signal 
VDM receives 
Message from server 
And Displays output 
I  , I W 
Waiting For 
Acknowledgment 
Signal Carrying 
Message For VDM 
i  i . 
I I  
:, :  : 
'" - -.I. - - _. I 
. .. I ,I 
:   
i  I 
Figure 5-5 Interaction between UML-EFM and VDM 
- 130 -
Chapter 5 EFMs - Executable Fultctioltal Models 
5.2.2.2 UML-EFM Simulatioll 
Figure 5-6 shows the state machine of an executable UML model interacting during a 
simulation with its YDM graphical model correspondent. Designers can follow the transition of 
the machine in different states while interacting with the graphical model; designers can modify 
the state machine and therefore the functionality of the prototype and test different solutions . 
~ 10 I:Q X ~; ."'Wll ... Iil .. Q~~ .. .:.-________________ ~ 
rJ U (;(lI;RU60 Tl1 . V .. n ()f 
IS .. 
 060'C:l 
f-tI (9 
IO:l/3 
",,_ ... 
"" ... 
CP1 ,~ 
" 1--
Nltt_ . . ... 
~""". 
..-.. 
(II -~. 
", .. 
0- -1 Jr-~~--"---->~----~==, 
The Graphical Model is running in VDM 
and the simulation is connected to the 
UML executable Model. 
Rational Rose RealTime: 
The UML Executable model is 
running and 
it is connected to the VDM model. 
the state Machine shows the current 
state in the simulation 
Figure 5-6 UML executable model interacting with VDM 
Further details on the SxUMLSocket package are given in Appendix 2. 
- 131 -
... Chaptu 5 EFMs - Executable Functional Mod"s 
5.3 SystemC-EFM 
This section will explore the services provided in the ViPERS framework to link SystemC-
EFMs with their graphical counterpart in YOM. Currently SystemC models can be 
implemented using the freely downloadable SystemC library or CoCentric System Studio. 
Tools such as CoCentric offer some advantages, but licensing costs, application-specific code, 
and platform issues, inspired the ViPERS approach to support both approaches. 
5.3.1 SystemC-EFM in Co Centric 
This section presents the use of TCPIlP sockets to extend Synopsys CoCentric System Studio 
for high-level System-On-Chip simulations. The benefits of using TCPIlP sockets to extend the 
CoCentric platform are discussed. The implementation details are presented and an application 
is described that exploits the near real-time performance of the solution. 
5.3.1.1 Introduction 
In the early stages of building a SoC simulation environment. it is necessary to pull together 
high-level, fast execution models of both internal SOC components and models from the wider 
system scope. In general, CPU models are required for the SoC simulation; to increase 
simulation performance, these should be represented as Instruction Set Simulators. Where high-
level models do not already exist. but hardware implementations of blocks are available, it is 
desirable to be able to connect to these from the simulation environment. As an example, it 
might be that a SOC includes an RF macrocell that is a purchased IP block. This block might be 
available as a hardware module that can be connected to the CoCentric simulation, therefore 
avoiding simulating this complex block and so improving overall performance. If the RF block 
is part of a remote control. for example. this scenario would allow actual control of a real-world 
device. RTL level simulation of complex hardware blocks. either HDL or SystemC, should be 
avoided where simulation performance is an issue. If large amounts of RTL are needed for a 
given simulation it would be preferable to place this in some form of hardware emulator. 
To facilitate the co-simulation of CoCentric with models or hardware outside the SystemC 
simulation, the CoCentric environment was extended by implementing generic TCPIlP sockets 
[116] communication components. This library of models provides a user-friendly mechanism 
to allow communication between CoCentric and any user defined tools. The use of industry 
standard TCPIlP sockets allows the external user defmed tools to be on differing machines or 
as platforms. 
- 132-
Chapter 5 EFMs - Executable FUllctiollal Models 
5.3.1.2 SxSockets Library 
This section discusses the implementation of the ViPERS SystemC socket library as CoCentric 
models. Object orientated techniques have been used throughout implementation, and platform 
dependent standard libraries were used to provide low level sockets functionality. The library 
structure will be outlined and then a brief explanation of each model will be given. 
SOURCE 
Socket 
strobe 
Adapter 
Primitive Model 
message 
Primitive Model 
Hierarchical Model 
Adapter 
Primitive Model 
System 
Core Design 
message 
Socket 
Primitive Model 
Hierarchical Model 
Figure 5-7 Overview of sink and source component use 
The ViPERS SystemC socket library components can initially be divided into two main 
categories: the sources and the sinks as shown in Figure 5-7. The CoCentric manual suggests 
[31] a source provides an algorithmically or predetermined stream of output values into a 
SystemC simulation. The ViPERS SystemC socket library of source components expands the 
scope of the CoCentric source to allow an external application to control the content and timing 
of the output values via a TCP/IP socket. The CoCentric manual [31] defines a sink as taking 
- 133 -
~ _______________________________________ ~C~h~a~p~t~e~r~5~E~F~~~s_-~E~x~e~c~u~t~a~b~/~e~F~u~,~,c~t~;~o~n~a~/~~~o~d~e~/~s 
one or more input values from a SystemC simulation and recording this in a data set. The 
ViPERS SystemC socket library sink extends this definition by allowing the data to be sent via 
a TCPIIP socket. Both the sources and the sinks are top level models made from two primitive 
models; one is the primitive socket model and the other one is the primitive socket adapter 
model. The primitive socket model contains all the functions to be performed on the socket. 
The adapter translates the socket message content, always a string, into different formats, such 
as integers and vectors. Both the primitive and top level models are saved in a library structure. 
Top level models are ready-to-use components. If a user requires an input or output format that 
is not provided in the library, a new top level model can be created by copying an existing 
model and customising the primitive socket adapter source code. 
5.3.1 .2.1 The Top Level Socket Source Block, SxSourceTopLevel 
The top level socket source model is built up of a primitive socket source model 
(SxSourceSocketPrimitive) and a primitive socket source adapter (SxSourceAdapterPrimitive) 
as shown in Figure 5-8. The input signal of the primitive socket source block is connected to a 
standard CoCentric clock. The SxSourceTopLevel is parameterised by four values which are 
shown in Table 5-1. 
SxSourceTopLevel - Schematic 
'jt'" ~.r---"lIII __ Wl~UrceAdap v 
Strobe ' 
SxSourceSocketPrimitive SxSourceAdapterPrimitive 
SxSourceTopLevel - Symbol 
utput 
Figure 5-8 Schematic and symbol of SxSourceTopLevel 
- 134 -
~tp'uf 
~ _______________________________________ ~C~h~aLP~t~e~r~5~E~F~kf~s~--=E~x~e~c~u~t~a~b~l~e~F~u~n~c~t~;o~,~,a~l~kf~o~d~e~ls~ 
5.3.1.2.1.1 The Primitive Socket Source, SxSourceSocketPrimitive 
When the SxSourceSocketPrimitive model successfully connects to the server, it sends a 
message specifying to which simulation it belongs and the top level socket source identity 
name. This information can later be used by the server to determine where to deliver the 
messages in the case of multiple sources. The primitive socket source model periodically 
checks for incoming messages and pushes out any new values to the SystemC simulation as 
shown in Figure 5-10. The primitive socket source component uses a SystemC clock edge 
event to determine when to check for a new message on the appropriate TCP/IP sockets. The 
SxSourceSocketPrimitive is a CoCentric model that is implemented based on a standard Linux 
socket class [116] and is configured as a non-blocking client. This configuration allows the 
checking for incoming messages without blocking the SystemC simulation. 
II schedule o utput write 
output.write(test) ; 
I I drive strobe high 
strobe.write( true ) ; 
II return control to the simulation and wait for next clock 
wait () ; 
II drive s trobe low 
strobe.write( false ) ; 
Il return control back to simulation a nd wait for ne xt clock 
wait (); 
Figure 5-9 Code segment for source socket 
SxSourceSocketPrimitive implements a thread (SC_THREAD) which IS sensitive to clock 
edges; on each wait statement the thread will return control to the SystemC simulation kernel 
until a new clock edge event occurs as shown from the code fragment in Figure 5-9. 
The SxSourceSocketPrimitive block has two output signals: a message and a strobe, as 
illustrated in Figure 5-7. The strobe signal is used to instruct the primitive socket source adapter 
that a new message is being sent from the primitive socket source block, or re-sent if unchanged 
from the previous value. 
- 135 -
Chtlpter 5 EFMs - Executable Functional Models 
Clock 
I I I I 
Message 7:z-z:-rjZZR Messa-l-,-r -/- ~ -r h;.;;k -rz-' /- -- _t..j. - __ ~i-;"..t_L.J"'..{_ ~-i-'-.~-.,/. 
Strobe 
.:' While the socket ... 
:' thread Is waiting ... 
: for a clock edge '. 
f the output and \ 
: the strobe signal  
i have been : 
: transmitted to 
: the next block 
~ (adapter) and 
will be 
. processed In the 
.. SystemC 
simulation 
Itt  I I 
I I I I I I 
 I , I. I 
. . . 
:' thread Is waiting ... 
:' for a clock edge ... 
, the change In \ 
: the strobe signal \ 
: has been : 
,i transmitted to i 
, : the next block : 
/ \ (adapter) and i 
,'... will be : 
" .. SystemC " 
" ... simulation .. ," ' , . 
, '. , . 
.---"""'""-----,.' 
Figure 5-10 Behaviour of source component 
5.3.1.2.1.2 ThePrimitive Socket Source Adapter. SxSourceAdapterPrimitive 
The primitive socket source adapter block is used in conjunction with primitive socket source 
model to form the top level socket source block. The aim of the primitive socket source adapter 
model is to translate an incoming text message into SystemC recognised signal types. 
Each positive edge transition on the strobe input of the SxSourceAdapterPrimitive model will 
cause the incoming message string (sc_string) from the SxSourceSocketPrimitive model, to be 
converted and written to the output signal. In the model provided in this example, the input 
message string is converted to a boolean (bool), but models can be adapted to provide other 
SystemC types. 
- 136 -
~ _____________________________________ C~h~aLP~te~r~5_E~F~Af~s_-~E~x~e~c~"~t~a~b~le~F~"~/~,~ct~i~o~,,~a~I~Af~o~d~e~l~s 
5.3.1.2.2 The Top Level Socket Sink Block, SxSinkTopLevel 
The top level socket sink model is built from a primitive socket sink adapter model connected to 
a primitive socket sink model as shown in Figure 5-11. The primitive socket sink adapter model 
receives the message from the SoC core design, translates it to a string and transmits it to the 
primitive socket sink. Once the primitive socket sink model receives the message from the 
primitive socket sink adapter, it sends it through a TCP/IP socket to the server. In the ViPERS 
SystemC socket library model discussed as an example, the top level socket sink accepts a 
boolean input and sends a TCPIIP server a string value of either true or false The 
SxSinkTopLevel is parameterised by four values which are shown in Table 5-1. 
SxSinkTopLevel - Schematic 
. Message ' 
. 1 Mil 
'ng~_Socket Si V2 
SxSinkAdapterPrimitive SxSinkSocketPrimitive 
SxSinkTopLevel - Symbol 
Figure 5-11 Schematic and symbol of SxSinkTopLevel 
5.3.1.2.2.1 The Primitive Socket Sink, SxSinkSocketPrimitive 
At the beginning of the simulation, the SxSinkSocketPrimitive block connects to a server and 
sends a message to register that it is active. During a simulation the primitive socket sink model 
receives messages from the primitive socket sink adapter block and pushes them through a 
TCPIIP socket to its destination. The SxSinkSocketPrimitive is a CoCentric model built using a 
standard Linux socket class [116] and is configured as a blocking client. The 
- 137 -
SxSinkSocketPrimitive is sensitive to its input string (message), when a message is received, it 
is sent unaltered via the TCPIIP socket to the server. 
5.3.1.2.2.2 The Primitive Socket Sink Adapter, SxSinkAdapterPrimitive 
The primitive socket sink adapter block combines with the primitive socket sink block to form 
the top level socket sink block. An event on the input of a SxSinkAdapterPrimitive block will 
be translated to a message string to be transmitted via the local SxSinkSocketPrimitive block. 
In the example model the input is a boolean (bool) and the output is a message to be transmitted 
as true orfalse. 
5.3.1.2.3 Top Level Model Parameterisation 
The top level models of the ViPERS SystemC socket library are parameterised. The values of 
the parameters need to be set in order for the sockets to function correctly. The parameters are 
given default values, but in most cases they will need to be changed to the appropriate values. 
The parameters can easily be changed in CoCentric by using the configure object option. 
Parameter Name Type Description 
A unique ID name of the socket component. (e.g. 
SocketName Sc_strinK 
buttonl) 
ApplicationName Sc_strinK Unique simulation name ID. (e.g. cocentricl) 
PortNo int This is the TCPIIP port number the socket will connect to. 
IPAddress Sc_strinl This is the TCPIIP address of the server to connect to. 
Table 5-1 - ViPERS Sockets Component Parameters 
5.3.1.3 Testing and Demonstrating the Technology 
In this section we will demonstrate how the socket blocks have been used in a virtual 
prototyping application. The application requires simulating an automated-home remote-
control electronic device. 
5.3.1.3.1 Experiment 
The physical appearance and visual responses of the remote control are modelled in the 
graphical visualisation tool; CoCentric is used to model the electronics of the device as a SoC in 
Systemc. The eight buttons of the remote control connect to eight corresponding top level 
-138 -
- Chapter 5 EFMs - Executable Functlonlll Models 
socket source models in CoCentric as illustrated in Figure 5-12. The display messages are 
carried over a ninth socket between the top level socket sink in the CoCentric simulation and the 
graphical interaction model. 
The SystemC block between the sources and the sink is the behavioural description of the 
remote control. This model can be implemented at any level of abstraction allowed by 
SystemC, keeping in mind that to maintain real-time simulation performance, a lower-level 
description may need a faster processor. The graphical model of the remote control could be 
running on a different machine or OS platform than that of the SoC simulation, this increases 
flexibility and choice of implementation environments. 
At simulation time the user can interact with the graphical model of the remote control. When 
the user presses a button, a message is sent via the TCPIIP socket to the corresponding top level 
socket source block in CoCentric. The top level socket source block will receive the message, 
translate it, and then feed it into the SOC core design block. The SystemC SoC core design 
block will process the button inputs and make changes to the desired display output. The 
changes to the display output are achieved by the top level socket sink sending an agreed tagged 
format message to the graphical interactive model, e.g. '<Rl> <Kitchen>'. 
The tests were conducted in the centre for VLSI and Computer Graphics at the University of 
Sussex on a 100Mb/s local area network. The simulation of the graphical model was running on 
a Windows XP PC with a 2GHz processor while CoCentric on a Linux Red-Hat 7.2 machine 
with a similar processor. 
As the SystemC SOC model became more complex, it was necessary to run CoCentric at the 
command line to reduce the system resources consumed. Once the SystemC model had been 
debugged, CoCentric was executed with no signal traces or log files; this allowed the simulation 
to run for days without a loss in performance. 
The socket components and libraries described in this section are specifically designed for 
CoCentric. CoCentric is a Linux-based solution; the sockets model discussed therefore use 
libraries that are specific to the Linux platform. 
The same library components described in this section were implemented for the Visual Studio 
framework to be used on the Windows platform. 
- 139-
n> -('> 
('> -0' 
'" r:::r 
-l>o ~ 
0 n> n> 
:; -n> ., 
:;::' 
::s -., 
, - f':l tcht:-n 
T r Ilr 1 
,~- ---- --------- -
I \ LCD_ Display (Port : 30001' 
I , ' 
Button_Opt4 (Port: 3001) \ 
 A~~~~ :~ 
, Q. Button_Opt3 (Port : 3002) \ 
' t-4 Button_Opt2 (Port : 3003) 'K==) 
I U Button_RIght (Port : 3005) : 
LCD Display 
8 Buttons, 
They are the inputs 
to the SoC Core Design. 
They are connected to 
the top level socket source 
blocks 
',,,, Button_Down (Port : 3006) : 
'- " Button_Up (Port: 3007) I 
I ' , , , 
,~---------------~ , 0 , , 
--I 000 \ ID Name = Button OpU'r+ Top level socket source 
\ 0 0 0 / Message = TRUE I 
'1~~---------------' , 
,~--------------~, , , , 
This shows the output of the 
SoC Core Design. _------------<{ 0 '10 Name = LCD_Display ',r - - - _________ _ 
\ /Message = <Rl>Kitchen I 
It is connected to 
the top level socket sink block 
'~-~--------------i' , , 
Top level socket sink 
II> ... 
~ -\:. 
I:> -
\:. -'" 
Chapter 5 EFMs - Executable Functional Models 
5.3.2 SystemC-EFM with the SystemC Toolkit 
Models implemented in SystemC using the freely downloadable SystemC library need a 
separate service which enables them to communicate with the graphical model. The ViPERS 
environment provides a SystemC container to enable the communication of the SystemC model 
with its graphical counterpart. 
The requirements for the SystemC digital model are to accurately model the electronics system 
that can be connected to the graphical based virtual prototyping tool to form a complete 
interactive solution. The communication mechanism between these two models needs to be 
robust and efficient to allow an accurate and real-time interaction to be maintained. 
5.3.2.1 SystemC Container - Wrapping SystemC inside a Win32 dU 
The digital model should be created in native SystemC. The SystemC library and the model are 
compiled, with the aid of a small custom library into a Win32 OLL which complies with the 
virtual prototyping tool external model plugin interface. The encapsulated model is loaded and 
linked at runtime into a new thread of an MFC-based host application with the aid of another 
small interface plugin management library. The interface libraries provide bi-directional 
interfaces to SystemC ports. 
The Win32-DLL-based SystemC model is connected to the virtual prototyping tool with a Local 
Communication Control Service protocol implemented in an MFC host application. The 
structure of the SystemC container is shown in Figure 5-13. 
To enable access to the top-level ports, the simulation is controlled outside of the SystemC 
simulation kernel. An iterative approach is taken of advancing the simulation a clock cycle at a 
time. This allows fine grain control of the application of external signals and the sampling of 
outputs from the native SystemC kernel, with the advantage of being able to read and write 10 
data in real-time. 
The OSCI SystemC library implements the top-level SystemC simulation object as a static 
object. To reset the simulation the SystemC object would need to be completely destroyed and 
re-created. This is impractical as it will require killing the simulation thread and reloading the 
DLL, therefore only the starting and pausing of the simulation is allowed. This does not prevent 
the digital model being reset as this can be done by toggling the reset pin. 
- 141 -
, , , , , , , , , , 
Chapter 5 EFMs - Executable Functional Models 
SystemC 
PortiO 
Client 
Port interface library (.exe) 
Plugin Manager 
Win32 DLL 
SystemC Wrapper 
L __ , 
l~~ _________ S_xP __ IU_g_in_M_a_n_a_g_e_r ________ ~ 
, ...--------. , , , , , 
: t:: 
: a.. lS 
<g L- ~ 
ascI SystemC 
2 ~  
~ Q) 1:: ~---. 
Simulation Model 
Digital 
Model 
L .. _________________________ _____ ______ __ ___ _ _______ __ _ ___ _ __ _ 
Figure 5-13 SystemC Container application 
In the context of this development a plugin is a precompiled piece of code which adds 
functionality to an existing system by a run-time linking mechanism. To retain a possible cross 
platform facility in the future, plugins are based in Win32 DLLs which, with the use of the 
associated Plugin Management Libraries conform to the required plugin standard. This standard 
is designed to enable implementation on other non Windows-based platforms. 
The plugin manager will traverse a path and attempt to identify valid plugins. An attempt will 
be made to load each plugin and if successful it will be logged in a list of useable plugins. In 
this case, if a SystemC-based digital model plugin is found it is loaded and appropriately 
logged. The higher-level MFC-based host application will make a request to the pJugin 
- 142 -
Chapter 5 EFMs - Executable Functional Models 
'-----------------------------------~~-~~~~~--==~~~~~~~~~~~~ 
manager for a plugin of this type. A handle will be returned and the application will be able to 
communicate with the digital model via the Port Interface Library. 
The digital model is instantiated and runs in a child thread of the main application and therefore 
executes asynchronously with respect to the main MFC-based host application. Bi-directional 
communication with the digital model is handled by the Port Interface Library. The library 
offers a set of 110 pins to both the host application and the digital model. A suitable abstraction 
mechanism is implemented such that neither the application nor the digital model are aware of 
the underlying communication technology which resides, in part, in both the DLL and the host 
application. 
To achieve an asynchronous communication model, data is transferred vIa C++ FIFO queues. 
The host application will send data to the digital model by effectively pushing data into a queue. 
Similarly the MFC will pop data out of the queue that has originated from the digital model. 
a- l$ ~ r-t COflCt toM 1"* ",.cr-_ "''' ~ "'*'" \:MI 
W __ fIPoIA~ 
_ .,j s...-r_ 
.:l .. ..,.a. 
.:l~~ 
J .. ..t_h 
.11-' 
.11-" 
.I~ .. ~ 
.J - ' 
.II"""~ 
.:l~cw 
1'- ...:1 001 r 
TlUCU (" F'.d.d 10 a-- t . ,oolb.~ 
r e '.,.. _I 1 _,1 to c:rea' 
111 I ( u.h t o r .)/ tI:r..oll olln 
T1I:~IED I- '. l led to c:r_ t   ,_''''. 
rel\lrft - 1 f . ,1 to C1 _ ' 
h ' _ VIIl 'pre._. once 
Figure 5-14 SystemC container application 
""bi l e: ev,  
The digital model exposes top-level signals (equivalent to real hardware pins) that are handled 
by the DLL portion of the Port Interface Library. The top-level SystemC ports are connected to 
the Port Interface Library which handles all the interaction with the stack based exchange 
mechanism. To ensure flexibility the underlying communication mechanism used to transfer 
- 143 -
Chapter 5 EFMs - Executable Functional Models 
messages IS genenc TCPIIP sockets [25]. The SystemC container application provides a 
graphical user interface which the user can use to take control of the simulations. The 
application is constantly displaying the exchange of messages between the behavioural model 
and the graphical model. The user can launch a simulation, pause and stop it through the 
interface of the application. A screenshot of the SystemC container application is shown in 
Figure 5-14. 
5.3.2.2 SystemC-EFM (SystemC COlltab,er) Simulatioll 
Figure 5-15 shows a simulation example where a SystemC model implemented using the Visual 
Studio and the SystemC library is interacting with a VOM model. The SystemC behavioural 
model was implemented using the Visual Studio version 6.0 framework and linked to the VOM 
model through the SystemC container application. 
~" .. -
The Graphical Model is running In VOM 
and the simulati on Is connected to the 
Container. 
SystemC Container: 
showing messages passed between 
the graphical model In 
VOM and the SystemC model 
Visual Studio 6.0: 
SystemC model Is edited, debugged and complied 
In this framework with by Including the SystemC library 
Figure 5-15 SystemC model interacting with VDM 
- 144-
Chapter 5 EFMs - Executable Functlontll Models 
During a simulation, such as the one shown in Figure 5-15, the user interacts with the graphical 
model, and the SystemC container application displays the exchange of messages between the 
two models (functional and graphical). 
5.4 Comparing EFMs 
In this section we will compare the use of the UML-EFMs previously described, with the 
SystemC-EFMs in the context of the ViPERS virtual prototyping methodology. The advantages 
and disadvantages of different EFMs justify their specific allocation in the design flow. At 
present, the only SystemC-EFMs that have been built and tested by the ViPERS team are 
implemented in behavioural and untimed functional SystemC. However, SystemC models can 
be implemented and used within the ViPERS approach at any level of abstraction. 
UML diagrams can be used to construct SystemC executable models in the analysis phase, to 
demonstrate that the design can meet the requirements. One of the drawbacks of this approach 
is that engineers needed a UML background in order to understand the design. In our approach 
the UML model serves two purposes; first it can be used to graphically describe the system, in 
which case UML knowledge is needed, and secondly it can be used in conjunction with a 
graphical model to execute its functionality in a simulation. In the second case no knowledge is 
needed; the user simply interacts with a photorealistic representation of the target product and 
studies its behaviour. 
UML-EFMs present substantial differences with SystemC-EFMs. UML-EFMs are almost 
entirely devoted to the first phase of the methodology, the analysis phase, while the SystemC 
model can be used in all of the phases through its refmement process. A SystemC model offers 
the advantage that it can be implemented at different levels of abstraction, and each level can be 
allocated in the methodology as part of the refinement process. Another advantage which is a 
consequence of the previous one is the reusability of the SystemC-EFMs. The SystemC models 
can be reused from their first high level implementation down to the timed (cycle accurate) 
models. But UML-EFMs have some major advantages over SystemC-EFMs, which drove the 
ViPERS methodology to explore their use in the analysis phase. These advantages are: 
1. Ease of implementation. UML-EFMs are very easy to implement and to modify which 
makes it a better candidate when, in the analysis phase, designers need to quickly put 
together and test the device and possibly implement modified version of it. 
- 145-
2. Simulation speed. UML-EFMs provide real-time simulation speed. which can be 
achieved only by a high level SystemC description; this depends on the framework 
(Visual Studio. CoCentric. etc) and implementation style. 
Both UML and SystemC descriptions conform to an industrial standard and therefore are not 
tied to any particular proprietary tool. Both can benefit from a vast tool support. 
The ViPERS team encountered speed limitations when trying to simulate a behavioural 
SystemC-EFM implemented in CoCentric. Because of the platform issues inherent with 
CoCentric models, the model was similarly re-implemented using Visual Studio and the 
container application [29]. The new model performed better giving a near to real-time 
simulation performance. 
From the above considerations the best possible solution for the ViPERS prototyping 
methodology was to employ both models in different phases in order to maximise their qualities 
and minimise their weaknesses. however different routes are applicable. 
- 146-
Chapter 6 
A Case Study of a Radio 
Frequency Remote Control 
Chapter 6 A Case Study of an RF Remote Control 
A CASE STUDY OF A RADIO FREQUENCY 
REMOTE CONTROL 
his chapter presents the use of the ViPERS approach, for the design and development 
of an electronic handheld device. It illustrates how the ViPERS approach and 
environment are applied to the design of an RF -based remote control device used for 
home automation. The outlined design flow includes the modelling of both the digital and 
graphical features of the remote control. The case study is based on the collaboration between 
the University of Sussex and a electronics manufacturing company Ikerlan [117]. The purpose 
of the target device is to control several functions of a domestic cooking stack such as the 
temperature of the oven, the ventilation speed of the hood, and the cooking timer. This case 
study will highlight the benefits of applying the ViPERS methodology to the design of handheld 
electronic systems; the visual layer provided by the virtual prototype will demonstrate the 
advantages in the exploration of functionality, interfaces and user interaction. 
The material presented in this chapter has also been published in [27, 28, and 29]. 
6.1 The Collaboration 
The material shown in Figure 6-1, a picture of the cooking stack and a sketch of the remote 
control, plus a written requirements document of the remote control were provided by Ikerlan at 
the beginning of the collaboration. 
The requirements document outlined the functionality of the remote control and described the 
functions of the buttons and the icons on the display. The functionality was illustrated by 
describing different scenarios. Each scenario aimed at describing how the user could interact 
with the remote control to achieve a specific function. It illustrated the sequence of actions 
- 148-
Chapter 6 A Case Study 0/ an RF Remote Control 
which a user would have to follow in order to set or modify a function of the cooking stack 
through the remote control. The description also identified how the display of the remote 
control should be update in accordance to the actions of the user. 
The sketch of the remote control in Figure 6-1 b shows the seven push buttons and the fifteen 
icons which make up the display. The buttons include the power button, the right and left 
buttons, the plus and minus buttons, the selection button and finally the ok button. The display 
can roughly be divided into twelve main sections, where for example the timer section contains 
four separate icons. The sketch is not photorealistic and does not contain physical details of the 
target device, and therefore it does not provide a clear idea of how the remote will actually look 
like. However, it provides a good understanding of the interactive components which make up 
the device. The requirements document, instead, aimed at explaining how the different 
functions are carried out by a user. For example it describes how a user might switch the oven 
on, set it to a type of cooking, set its temperature. and finally set its timer. Out of the many 
scenarios only certain steps are precisely described by showing how the display would appear 
when a user performs a certain task. The issue in this case is that providing a sketch for all the 
possible tasks which the remote control can perform can be very time consuming especially if 
no ad-hoc tool is used to aid the designer generating the screenshots. Even with this approach 
though. which resembles the paper prototyping approach and it is more interactive than the one 
presented by Ikerlan, it is still very likely that some scenarios or details would remain 
undefined. The problem with these types of approaches can be found in their static nature 
which does not necessarily promote exploration. The dynamic and interactive nature of a 
virtual prototype instead. is more likely to enable designers and users to explore the features of 
the target device and identify issues and problems which would have probably not been 
considered with a static approach. 
An example, to illustrate the ambiguity of the requirements document, is the presence of the 
clock icon and the seven segment display showing the time. The requirements document 
defmes that a clock icon will be highlighted when the remote control is showing the current 
time. It even specifies that this would disappear when the user is setting the timer for any of the 
three appliances. The problem here arises since. the document does not specify when exactly 
the icon should be highlighted or not. It is clear. for example. that if the oven is off and the 
remote control is in a monitoring state then the time should be displayed, but it is not specified 
what would happen when the user switches on the oven. This is just one of the many examples 
of ambiguity which was encountered when analysing the written requirements document. 
- 149-
Chapter 6 A Case Study of all RF Remote COlltro/ 
The work undertaken by the ViPERS team included a detailed requirements analysis and the 
implementation of a high level functional model of the remote control. UML was chosen as the 
modelling language for the requirements analysis and its Real-Time profile, know as the UML 
Profile for Schedulability, Performance and Time, used to implement the executable model for 
requirements exploration. SystemC was the modelling language of choice for the digital design 
of the remote control. 
J \I' \WIIO 
a) b) 
Figure 6-1 Photo of the cooking stack and sketch of the remote controlS 
High level models can be put together with minimal effort, allowing rapid conceptual 
exploration in the early stages of the design phase. The initial description of the remote was 
later refined and further details added to the design. The ViPERS approach can roughly be 
divided into three main modelling tasks where the appearance, functionality and environment of 
the electronic device are modelled and then refined. 
8 Sketch of the remote control and picture of the cooking stack were provided by Ikerlan 
- 150 -
Chapter 6 A Case Study o[ all RF Remote Control 
u_e-c  dlagrama 
el  d i.gram  
 ~u.nc. d'.gr  .". 
almuletJon .nvlronment 
Figure 6-2 Modelling tasks in ViPERS 
Figure 6-2 shows the modelling tasks: 
environment 
Mod.,llng 
 UML modelling: includes the creation of UML diagrams and the implementation of an 
executable model in UML that can be used in a simulation environment to test the 
interfaces, the functionality, the usability, and interactivity issues of the device. 
 SystemC modelling: this includes the implementation of an executable SystemC model 
with its related refinement processes. The SystemC model can be used for the same 
purpose as the ones described by the UML model and in addition it can be used for 
architectural and structural exploration of the underlying digital implementation of the 
target device. 
 Graphics modeJUng: this includes the 2D/3D graphical modelling of the target device 
and its virtual environment. The graphical model of the device allows modelling the 
physical interfaces of the target device. When combined with an executable functional 
model, it can be also used to test the graphical interfaces of the virtual device. The 
virtual environment, can be used to simulate and test the interaction of the virtual device 
with other virtual devices and with its environment. 
Not all the tasks mentioned above are obligatory in the context of the ViPERS approach but 
some are included as extra features that designers can exploit. The 3D modelling of the 
environment, for example, can be used to enhance user experience in a complex simulation 
environment. Tasks are shown in parallel since each phase is independent to the others. A 
design flow will be explored in this chapter, to illustrate the suggested flow for the ViPERS 
approach. 
- 151 -
Chapter 6 A Case Study of all RF Remote COlllro/ 
6.2 Graphics Modelling 
In previous chapters of this thesis, virtual prototyping was described as a visual layer on top of 
the digital design. The modelling of the visual layer includes the modelling of all the graphical 
elements and their interactive features. 
~ OBooc:J 
I-+l (9 
10:32 
Figure 6-3 2D Remote Control9 
In this section two types of graphics modelling will be explored, device and environment 
modelling. Environment modelling [22] represents a novel and optional phase in the ViPERS 
approach that involves the creation of a virtual environment for the target devices. In the 
specific case of this study the environment is represented by a three dimensional virtual kitchen 
which contains the cooking stack as shown in Figure 6-8. Device modelling is the process of 
creating two dimensional photorealistic models of the target device, and/or other models which 
could take part in the simulation. 
6.2.1 Device Modelling 
The modelling of the graphics was achieved through VDM. The sketch of the remote control 
showed in Figure 6-1, gives a very rough idea of the physical interface of the target device. 
Clearly an imagination gap is created between team members who most probably will envisage 
9 Model created by Dr. Phil Watten, Centre for VLSI and Computer Graphics, University of Sussex 
- 152 -
~ _____________________________________ C~h~aLP~t~er~6~A~C~a~s~e~S~t_"_d~y~o/~a~/_' _R_F __ R_e_I_"_o_te __ C_o_'_'t_r_o __ 1 
the target device differently. The accurate modelling of the graphics eliminates this imagination 
gap and allows a precise description of the aesthetic qualities of the device. To satisfy Ikerlan, 
it was decided to provide several options, which offered different graphical qualities, and 
different interfaces. The process of changing graphical qualities such as the colour is referred to 
as skinning and it is shown in Figure 6-4. 
Figure 6-4 Candidate solutions lO 
The first graphical model needs to be implemented in order to initiate detailed discussions 
between designers. VDM provides the capability to create the graphical model and easi ly 
modify its graphical elements when desired. The final graphical model designed for the remote 
control is shown in Figure 6-3. An experienced user of Adobe Photoshop designed this 2D 
remote control and imported it into VDM into approximately three days. 
VDM provides libraries of graphical components which are commonly found on handheld 
devices. Since the required components were not found in the library, Adobe Photoshop was 
used to create the required graphical elements. Figure 4-10 shows the graphical components 
which were created for the graphical display of the remote control using Adobe Photoshop. 
10 Model created by Dr. Phil Wanen, Centre for VLSI and Computer Graphics, University of Sussex 
- 153 -
Chapter 6 A Case Study of all RF Remote COlltro/ 
Once the graphical elements were created and imported into the YOM graphics library, the 
selected components were dragged and dropped into the YOM workspace and the graphical 
model was constructed as shown in Figure 6-5. 
r ~ -p... ~, .. <'T~ 
L ~"""""J... J... J... J...~ 
_ rr rr' 
/23~551890RbdEF, Lnr--.~~~ 
123~561890RbdEF, Lnr-
Figure 6-5 Compositing of graphical components 
The graphical model for the remote control showed in Figure 6-3 was the result of several 
iterations between designers. Other graphical models that were implemented to explore 
alternative options are shown in Figure 4-6. 
To explore the interaction of the remote control with the cooker, a two dimensional model of the 
cooker was implemented. The procedure was the same as for the remote control, but fewer low 
level details were implemented as the cooker did not constitute the main focus of the case study. 
The interactive two dimensional cooker stack is shown in Figure 6-6. An experienced user of 
Adobe Photoshop designed this 20 cooker and imported it into YOM in approximately two 
days. 
- 154 -
Chapter 6 A Case Study of all RF Remote COlltrol 
Figure 6-6 2D cooking stackll 
6.2.2 Environment Modelling 
In the ViPERS approach the modelling of the environment can be undertaken to add value and 
reality to the simulation experience. Another important aspect of virtual environments is that 
they allow designers to prototype the interaction of the virtual device with other virtual devices 
and with its environment. Using virtual environments allows placing the virtual prototype into a 
context. In a typical virtual prototyping simulation a user interacts with a virtual prototype and 
views the consequences of his actions on the virtual device; in most cases these consequences 
are driven by the functional model (e.g. the display updating), or they are mechanical changes 
II Model created by Dr. Phil Watten and Ben Jackson, Centre for VLSI and Computer Graphics, 
University of Sussex 
- ISS -
'-______________________________________ c~/_'_a~p_te_r __ 6 __ A __ C_a_s~e __ S_tu~dyL_0~f~a_I __ R_F __ R_e_"_I_o_t_e_C __ o_"_tr_o_l_ 
(e.g. a button being pressed down). The virtual environment enables the user to actually view 
the changes that the virtual device is causing to its environment. For this case study a three 
dimensional virtual kitchen was implemented. This three dimensional virtual environment 
which is shown in Figure 6-7 contains an interactive three dimensional cooker. The 
interactivity of the 3D cooker means that during a simulation this will react in sympathy with 
the virtual device. An experienced user of 3D Studio Max designed this 3D virtual kitchen in 
approximately three days. 
Figure 6-7 Virtual Kitchen 12 
The virtual kitchen was implemented using 3D Studio Max. Interactivity was added by 
scripting specific graphical elements of the cooker within the kitchen model. During a 
simulation when a user interacts with the virtual prototype of the remote control, the virtual 
kitchen will respond to hislher actions. The user will be able to navigate inside the virtual 
environment and check the changes that have taken place. An example of interactive elements 
in the 3D model is shown in Figure 6-8 where the light of the hood is switched on by the user 
using the remote control. 
- 156 -
Chapter 6 A Case Study of aI/ RF Remote COl/fro/ 
Figure 6-8 Interactive virtual kitchen 
6.3 UML Modelling 
A first UML description of the remote control was achieved by means of standard UML diagrams, such 
as class diagrams, sequence diagrams, and use-case diagrams. This description is detailed in Appendix 
1. The written description of the functionality of the remote control was found to be ambiguous, and 
introduced uncertainty and misunderstanding between team members. Different readers of the 
document had a different idea of the functionality of the remote control. The UML diagrams were used 
to provide an initial understanding between team members about the system and its interaction with the 
outside world. 
Figure 6-9 shows the class diagram for the remote control. 
12 Model created by Ben Jackson, Centre for VLSI and Computer Graphics, University of Sussex 
- 157 -
Chapter 6 A Case Study of an RF Remote Control 
fbom_of'od<_) 
~: .. oo 
.. ,_ :W 
~: .. 
~YM .. 
~ll<>O ; "'oO 
~M: inI 
- - -- - - - - - --
Ik""~od<_) 
~_",, : ,,07 
""'l'OO4l 
. "K0\IP0d) 
. oi:J 
0' """""","""0:8.-.= ---, 
fbom-~""ogol 
~: ... O 
fhano-~"""ogol 
_-")~ ... O 
_-- o-()~ ------ / 
0""", 
[1Jom _oConbof'ackogt) 
~_"' : ".4 
--;:, 
~.oIo&(l 
. -0  
"""'-.(j 
Figure 6-9 Class diagram for remote control 
Dynamic features were then added in order to create the UML executable functional model 
(UML-EFM). A state machine was implemented to simulate the functionality of the remote 
control. This state machine was included into the capsule implemented for the remote control 
and it was later linked to the socket capsule. The socket capsule is part of the SxUMLSocket 
package and simply needs to be imported into the design. A communication protocol was 
defined to allow the two capsules to exchange data through signals. The state machine was 
implemented hierarchically. An example is shown in Figure 6-10 which shows the state 
machine which is activated when the user is controlling the functions of the oven (inside the 
oven state). 
- 158 -
Chapter 6 A Case Study of an RF Remote Control 
Figure 6-10 State diagram for remote control 
If the graphical model has not been implemented at this stage, Rational Rose provides the 
capability to artific ially inject signals within the capsules to test its functionality as shown In 
Figure 6-11. 
M...sysJem 0 
o ONt .. u ... 
o OI,_oCont,oI RernotoCont,oI 
Plebe, 
- C OI,_e_C(,,,,,,_Plebe 
- '_e_commlprobe_~ 
- ,_e_commIprobe_"" 
- tItm ()pen 5pe<I .. tlon ... 
- ,emott-1ea __ IIIIIII __ IIIII_1 
- remote_ 
- remote_ 
- lemote_ 
Fndln ... 
Replace In .. 
()pen Another 81_ 
Oose Browse. 
Refresh 
.; Mow Dodroo 
Cl,I+F 
Q,I+Shit+F 
Figure 6-11 Injecting signals 
- 159 -
Further details on the UML-EFM description of the remote control are given in Appendix 3. 
The UML model of the remote control was implemented by the author in approximately one 
week. 
6.4 SystemC ModeUing 
The SystemC Modelling starts with the creation of executable functional models in SystemC 
(SystemC-EFM) which at simulation time can be linked to the graphical prototype to deliver its 
functionality. The system models created in the early stages of design are later refined into 
lower level models. 
For the remote control two SystemC models were created: 
1. A SystemC executable model with CoCentric System Studio (SystemC-EFM) 
2. A SystemC executable model with the SystemC library and Visual Studio (SystemC-
This chapter will only describe the development process linked to the CoCentric tool. The 
structure of the model implemented in Visual Studio was the same as the one implemented in 
CoCentric. The two approaches are compared below. 
6.4. J Co Centric Development 
The first step in the SystemC domain is the implementation of an untimed functional model of 
the remote control. Ideally this model should be generated automatically from the translation of 
the UML model. At present, in the ViPERS approach, there is no link or automated process to 
link the UML and SystemC models. This means that models have to be implemented almost 
from scratch. Reuse currently applies only to the UML standard diagrams. Effort is being 
made by major industrial companies as illustrated by Sardini [lOS] to link SystemC and UML. 
The SystemC-EFM is a behavioural description of the remote control and its structure is shown 
in Figure 6-12. This model was implemented by the author in approximately two weeks. 
- 160-
Chapter 6 A Case Study of an RF Remote Control 
Figure 6-12 CoCentric model of remote control 
The top level Keypad and DisplaySink blocks contain the sources and the sinks blocks which are 
used to communicate through LCCS to the graphical models, The top level 
Behavioural_Remote contains the blocks which implement the functionality of the remote 
control. The internal structure of this block is shown in Figure 6-13, 
r~ 1 r1Jo .F-'- 3 ~ A C / "O"- 0 <1'<1' .. " ~'~'-----'3 
.unl,.'''' 
Figure 6-13 Behavioural block of remote control 
- 161 -
Chapter 6 A Case Study o[ an RF Remote Control 
Further details of the SystemC-EFM description of the remote control implemented in 
CoCentric are given in Appendix 4. Screenshots and considerations of the overheads incurred 
by CoCentric System Studio and Rational Rose RealTime when automatically generating code 
are given in Appendix 5. 
6.4.2 Refinement Process 
Once the development work has reached the implementation stage, it is necessary to consider 
the architecture of the remote control's electronics, including partitioning of the functions 
between hardware and software. Several alternative solutions within the same virtual prototype 
environment can be considered. 
Figure 6-14 indicates the simplified block architecture of the remote control, the only block 
carried forward from the purely behavioural model is the user interaction state machine. The 
other blocks can be represented in various degrees of detail. A key question in the 
implementation of the device is whether to include a microcontroller or not. In the remote-
control case, which includes an RF macrocell, a microcontroller is normally required to program 
and manage this block. Once a microcontroller is included within a design, the trade-off 
between moving more functions to a more capable microcontroller becomes an option. For 
each of the other blocks in the remote control's architecture, it is necessary to explore discrete 
hardware implementation via existing IP or newly created RTL code. The other design choice 
is software running on the microcontroller; again this can be pre-existing or newly developed. 
Figure 6-14b shows how one possible refinement of the generic architecture maintains the 
display control and RF macrocell functions as RTL, whilst the user interaction, battery and RF 
management functions are implemented as software modules. The software modules of the 
remote are implemented as SystemC IP blocks at a high-level, the main difference between the 
above and the original high-level implementation is that only one of these modules is allowed to 
operate at any given instant. 
- 162-
Chapter 6 A Case Study of all RF Remote COlltrol 
~--------------------------===~~~==~~~~~~~~~~ 
1/'1 -f-t 
f-t Button f-t 
f-t De-bounce 
: 0 ::: :::> 
co ... 
: ~ Micro 
.8 ~ Controller 
User Interaction 
Statemachine 
Battery 
lv1anagement 
RF macrocell 
Management 
RF Macrocell 
Aerial 
Software tv odules 
User Interaction 
Statemachi ne 
Battery 
Management 
RF macrocell 
Management 
~ RF Macrocell RTl 
Aerial 
Display 
Control 
Refinemel1 
Process 
Display ~ 
Control ~ 0 
RTl B 
Figure 6-14 Refinement process for the remote control 
6.5 Simulation Envirollment 
For this case study several simulation environments were created. In this chapter three 
scenarios will be illustrated. The first one involves the interaction of two 20 models; one for 
the remote control and one for the cooker model. The second simulation involves the 
interaction of a 20 model (remote control model) within a 30 environment (kitchen model). 
The third scenario simply shows how the simulation can be projected through a different 
visualisation method from the traditional PC monitor used in other simulations. 
- 163 -
'-______________________________________ c_'_a~p~te_r __ 6_A ___ C_a_s_e_S __ tl_'d~y~o~f __ a_" __ R_F __ R_e_t_" _o_te __ C_o_t_' _tr_o_l_ 
6.5.1 Simulation Environment 1: 2D Remote Control and 2D Cooker 
Figure 6-1 5 shows the first simulation scenario comprising of the two dimensional models of 
the remote control and the cooking stack. Figure 6-15(a) shows the graphical model of the 
remote control connected with its CoCentric counterpart. Figure 6-15 (b) shows the graphical 
model of the cooking stack connected to its SystemC functional model through the SystemC 
Container application. 
Figure a) 
Figure b) 
Figure 6-15 Simulation scenario 1 of the remote control 
During the simulation, the users interact with the remote control, and consequences of their 
action are shown on both the display of the remote control and on the cooking stack. If a user 
presses the sequence of buttons which enables the remote control to switch one of the hobs on, 
- 164 -
'-______________________________________ c~h~aLP~t~e~r~6~A~C~a~s~e~S~t~u~dLy_o~f~a~II~R~F~R~e'~II~o~t~e_C~o~lI~t~ro~1 
then the icons on the display of the remote control will show that the hob is on and the virtual 
prototype of the cooking stack will graphically show the hob ring glowing. This simulation was 
run on four separate pes, one for each model. 
6.5.2 Simulation Environment 2: 2D Remote Control and 3D Kitchen 
This simulation environment shows the interaction of a two dimensional graphical model of the 
remote control within the three dimensional model of the virtual kitchen. As for the previous 
scenario, the user interacts with the two dimensional model and views the changes on both the 
display of the remote control and on the cooker inside the virtual kitchen. 
Figure 6-16 Simulation scenario 2 of the remote control 
As shown in Figure 6-16 the functionality of the remote control is driven by the UML-EFM, 
and the user can view the simulation through the graphical state machine of the remote control. 
Further details of the simulation of the UML-EFM model of the remote control in conjunction 
with its VDM counterpart is given in Appendix 3. 
- 165 -
~ _____________________________________ ~C~J~I~aLP~te~r~6~A~C~a~s~e_S~t'~/~dy~o~f~a~II~R~F~R~e~"~II~o~t~e~C~o~lI~tr~o~1 
6.5.3 Projected Simulations 
All the simulations explored in the previous examples were viewed by the user through a 
computer monitor. This section will illustrate the use of projectors for enhanced visualisation of 
virtual prototypes and their environments. The use of projection is discussed in this section to 
demonstrate that while most experiments use computer monitors as they are low-cost solutions, 
several other methods can be considered. Another method which will not be discussed in this 
thesis (for reasons explored in Chapter 2) is the use of head-mounted displays or CA YEs. 
These methods compared to projections provide enhanced user experience from a graphical 
point of view, but do not provide the capability to simultaneously view data from the underlying 
simulations. 
Figure 6-17 Projected simulation scenario 
In the example shown in Figure 6-17 the 2D remote control is executing with a 3D virtual 
kitchen. Projection is used in this context to simultaneously view graphical simulation as well 
as data from the simulations. Stakeholders can simultaneously view the changes in the UML 
state machine, the SystemC model as well as the virtual device and the virtual kitchen reacting 
to user actions. Each model is simulating on a different machine which is connected to a 
separate projector. A lower-cost solution is the use of computer monitors. Compared to 
- 166 -
'-______________________________________ c~h~aLP~t~e~r~6~A~C~a~s~e~S~t~u~dLy~o[~a~n~R~F~R~e~m~o~t~e~C~o~n~t~r~o~J 
projections, the smaller size of computer monitors does not allow a complete and concurrent 
view of the entire simulation. The projection enhances the visualisation of the models and at the 
same time facilitates discussion between team members. Different stakeholders with different 
knowledge can concentrate on the simulation or the data they are more interested in, while 
simultaneously having some insight about other simulations. The magnified images provided 
by projectors allows, as shown in Figure 6-18, team members to communicate and use a 
presentation-style approach to draw the attention of the audience to specific features or 
simulation data. 
Figure 6-18 Projected scenario and team communication 
6.6 Reflections on tlte case study 
The case study presented in this chapter, was used to evaluate the effectiveness of the ViPERS 
approach in the design of handheld devices. Overall considerations of the ViPERS approach 
and environment will be discussed in Chapter 7, while this section will illustrate some of the 
benefits which were realised from the case study. 
- 167 -
- Cllllpter 6 A ClISe Study 01 lin RF Remote Control 
In the early stages of the collaboration, the written requirements document and the sketch of the 
device were used to evaluate a traditional development approach. This approach resulted in 
misunderstanding and confusion between the readers of the document. It was clear that while 
derming the overall functionality and physical interface of the target device, the document was 
ambiguous and the description was not precise enough. Different readers of the requirements 
document had a different understanding of the functionality of the remote control. Two main 
issues were identified. One issue was that some parts of the system were interpreted differently 
by the readers while, other parts were not even defined. 
It was realised that in order to obtain a clear understanding of the document, several interactions 
would have been needed between the readers and the writers of the document. This process 
would have resulted in a series of rermed documents which would have finally satisfied both 
teams. However the document might still have been ambiguous to future readers and probably 
some issues would have still not been raised. 
The ViPERS approach provided many benefits in this stage. The readers of the document 
started discussing and designing the system using standard UML diagrams. A level of 
understanding was easily reached. This understanding allowed the insertion of dynamic 
features in the design in order to create an executable model in UML. In the meantime other 
designers were creating a graphical model for the remote control and a three dimensional virtual 
kitchen. The virtual prototype provided a common reference between team members and could 
be understood by anyone irrespective of their technical knowledge. This model could be easily 
showed to the writers of the requirements document, who could test it and provide feedback 
about parts of the systems which were wrongly interpreted. The high level of abstraction of the 
model allowed an easy and quick modification of the functionality of the system in order to re-
propose the modified virtual prototype. 
Once the two teams reached a common understanding, further analysis of the virtual prototype 
was undertaken, and several candidate solutions were implemented. This can involve changing 
the aesthetic qualities, the physical interfaces, the graphical interfaces and even the functionality 
of the target device. The ViPERS approach provided a description which was more 
understandable, less ambiguous and also more flexible, since changes could be easily fed in and 
viewed. Overall, the ViPERS approach allowed specifying the target device more precisely. 
Other conclusions could be drawn for example on the response time of the display. An example 
is the speed at which the icons of the display should blink. The virtual prototype allowed the 
designer to determine the speed boundaries which make the blinking acceptable by a user while 
a written document would be less useful in derming such features. In addition the photorealistic 
-168 -
- Chllpter 6 A Clue Study of lin RF Remote Control 
nature of the graphical model allowed detailed discussions of the aesthetic qualities of the target 
device. 
Other benefits were realised when adopting SystemC executable models. The graphical model 
in this phase was used as a testbench and as a visual tool to view the output of the core design of 
the system. The precise functional specification achieved in the previous stage allowed 
designers to understand the behaviour of the system. Once the SystemC model was 
implemented and combined with a graphical model, the designer could interact with the virtual 
prototype and feed input signals to the SystemC model. At the same time the designer could 
view the changes that took place on the virtual prototype and therefore analyse the correctness 
of the behaviour of the SystemC model. 
Finally the use of the virtual environment and of projections enhanced the user experience 
during simulations and provided designers with more feedback about the behaviour of the 
system. 
Further conclusions regarding the ViPERS approach will be discussed in the next chapter. 
-169 -
Chapter 7 
Conclusions and Future Work 
Chapter 7 Conclusions and Future Work 
CONCLUSIONS AND FUTURE WORK 
he introduction to this thesis outlined the motivations and objectives of the ViPERS 
methodology. The main objective for the ViPERS approach was to explore the 
applicability and determine the benefits and drawbacks of linking virtual prototyping 
techniques with a system level design methodology for SoCs. Other objectives were to evaluate 
the photorealistic modelling of graphical models, to establish a link between requirements 
analysis and SoC design, to explore the link between virtual prototyping and hardware/software 
simulations, and to evaluate the employment of virtual prototyping for early performance 
analysis. This chapter presents the conclusions drawn about each objective, based on the 
experiments and the case study explored in this thesis. 
7.1 Conclusions 
In common with previous research efforts which focused on virtual prototyping, in ViPERS 
results are in the form of implementations and experiences based on case studies and 
experiments. These results are explored in this chapter to provide the conclusions to the work 
undertaken. 
Experiments described in the previous chapter reinforce the effectiveness of virtual prototyping 
in interfaces design, usability tests, and human-machine interaction design. Consideration of 
these issues will not be presented in this chapter since, as described in Chapter 2, they were 
identified in previous research efforts. 
- 171 -
- Chapter 7 Conclusions and Future Work 
7.1.1 Linking Virtual Prototyping with SoC Design and Route to Hardware 
Showing the applicability and benefits of linking virtual prototyping techniques with SoC 
design is one of the main objectives of the ViPERS approach. The advantages of applying 
virtual prototyping techniques in the conceptualisation phase were demonstrated in several 
previous research efforts and were described in chapter 2. The ViPERS approach widens the 
use of virtual prototyping by demonstrating that it does not need to be a separate process but it 
can be integrated into a design methodology. The case study represented in Chapter 6 and the 
experiments discussed in Chapter 5 illustrate the technical implementation details of how virtual 
prototyping can be linked into the different stages of SoC design. The links provided in the 
ViPERS environment are libraries, packages and external services. The integration of these 
independent links into the executable functional models showed to be straightforward. The 
links can easily be imported into the functional descriptions without adding time to the 
implementation of these models. Small amount of coding might be needed to connect the 
models, but the structure of the socket components and their UML description allows rapid 
adaptation to different scenarios. The UML description of LCCS and of the socket package 
used in Rational Rose RealTime allows a designer to easily re-implement these components for 
different platforms or tools. Internal customisable components allow modification of some of 
their functionality for adaptation to specific requirements. This allows designers to add code 
when a desired behaviour is needed. The hierarchical components of the socket library 
implemented in CoCentric include a primitive component, the adapter, which translates the 
received sc_string (string) signals to different data types. These components provide designers 
with the freedom to use the sources and sinks within any CoCentric model. Parameterisation of 
certain features of these components allows their easy customisation without designers having 
to add any extra code. 
Real-time performance was obtained in most simulations. The communication infrastructure 
provided in the ViPERS framework did not constitute a bottleneck for the simulations of the 
virtual prototypes. In a virtual prototyping context real-time performance relates to the reaction 
speed of the graphical model during a simulation, i.e. the speed at which the display updates or 
buttons react to users actions. Slow reaction times of the graphical model can decrease the 
sense of reality felt by the user. The communication framework allowed different models, 
including graphical, behavioural, and low level hardware models to be simulated on different 
machines. Communication of models is obtained through TCPIIP sockets and therefore 
distributed simulations are simply obtained by changing the IP address from local host to a 
specific address of another machine on the network where the model will simulate. 
-172 -
- Chflpter 7 Conclusions lind Future Work 
The various socket links implemented for the SystemC socket library, the UML socket package 
and LCCS are based on standard TCPIIP sockets. The implementation code varies depending 
on the platform (Windows and Linux) but they share the same structure. This allows an easy 
understanding of the different socket links provided in the ViPERS approach and easy re-
implementation or re-adaptation to other external applications. 
It was realised that regardless of distribution, real-time performance would not be obtained in 
complex models implemented in the lowest levels of abstraction such as in bus-cycle accurate 
models. For this reason applications suggested for virtual prototyping in the ViPERS approach 
for this type of simulation do not rely on real-time performance. The virtual prototype can 
instead be used as a visual tool to inject signals into the simulation model and visualise results. 
From the experiments presented in this thesis it was realised that the benefits and applications of 
virtual prototyping vary depending on where in the design flow it is applied. As described in 
Chapter 2, past research efforts have shown the benefits of virtual prototyping in the 
conceptualisation phase, but the desire of the ViPERS approach is to avoid confining it to this 
phase, as past research efforts did, and evaluate its significance in successive stages of the 
design flow. As shown in Figure 7-1, it was realised through the experiments that the benefits 
of traditional applications of virtual prototyping, such as concept analysis and interface design, 
decreased. In contrast, new applications were realised in the implementation stages of the SoC 
design flow. 
Value rA virtual prototyplng 
_teeto,1I exploration 
Figure 7-1 Application of virtual prototypln& 
- 173 -
Chapter 7 Conclusions and Future Work 
In the conceptualisation phase of a product or in the requirements analysis a virtual prototype 
can be used to explore the concepts, the interfaces, and to consider on performance and provide 
designers with the capability to put together several virtual prototypes and test different 
candidate solutions. In the implementation phase, especially in the lower levels of abstractions, 
behavioural or RTL, concepts and interfaces have already been explored and the virtual 
prototype can be applied for different applications. Two applications which were realised were 
the use of the virtual prototype as a testbench and as a visual aid for the debugging for models 
(injecting signals and viewing changes on the graphical model). In a system level methodology 
as the one suggested by SystemC, subsystems and blocks can always be placed in the initial 
system level to be tested. If the graphical model is linked to the SystemC model, hw/sw 
engineers can use it as a testbench. Designers can input a sequence of actions in the graphical 
model which at simulation time become a testbench for the SystemC model. The low level 
implementation can be placed in the system level model by replacing its high level 
correspondent. The simulation of the modified system level model in conjunction with the 
graphical model is then rerun. The virtual prototype can be used to visualise simulation results 
in a more intuitive way. In one of the experiments conducted an RTL implementation of a 
simple remote control was developed. To test the implementation two approaches were 
undertaken by two designers. One designer adopted a traditional approach by using a testbench 
implemented in a text file to analyse the results through an output text file. Results from the 
text file were studied and compared by the designer to the desired behaviour. The second 
designer adopted a virtual prototype to test the system. Input signals were injected into the 
system by interacting with the graphical model and the output was visualised by the changes on 
the display of the graphical model. The second approach was more intuitive, easier and more 
designer friendly. Even in cases where simulation speed might be an issue, because of complex 
low level models, the virtual prototype can be used to inject signals into the SystemC core 
design and view the outputs through the interactive graphical model. The sense of reality is 
significantly affected but this is outside the scope of this specific application of virtual 
prototyping. 
Once the target device has been implemented, applications of virtual prototyping increase in the 
marketing phase. Possible applications in this phase are to apply virtual prototypes for the 
creation of user manuals of the product, or to present the product to the potential users through 
the Web, and help sell the product. 
Experiments did not include complex low level implementations and therefore no proof is 
presented of the applicability of virtual prototyping in this context. As any new approach, 
virtual prototyping needs to convince engineers of its benefits; bearing in mind that they rely on 
-174 -
techniques they have been adopting for years and with which they are very familiar. For this 
reason the ViPERS approach offers additions to enhance these processes rather than replace 
them. This approach enables the acceptance of its techniques while still relying on established 
methods. 
Another consideration refers to the comparison of the simulation speed in the three different 
approaches adopted in the ViPERS framework. Both the UML and SystemC models 
implemented in C++ using Visual Studio, produced real-time performance without any need to 
refine the communication mechanism. On the other hand SystemC models implemented in 
CoCentric presented some performance problems. 
At the behavioural level, with a fairly complex model, the CoCentric simulation speed was so 
slow, and the simulation of the virtual prototype appeared unreal. Icons on the display of the 
graphical model were blinking too slowly. From an implementation point of view one solution 
would be to re-implement the model at a transaction level. Transaction level models 
communicate through ports, channel and interfaces and offer a much higher simulation speed. 
Other experiments not presented in this thesis and aimed at speeding low level simulations 
included the use of virtual prototyping in conjunction with emulators. 
7.1.2 Photorealism 
Photorealistic models were introduced in the ViPERS approach to support the concept of virtual 
prototyping as a communication reference between team members and to accurately model the 
aesthetic qualities of a target product. One of the greatest benefits of virtual prototypes is that 
they eliminate ambiguities that natural languages, written or spoken, can often introduce. 
Experiments conducted, which applied crude graphical models to virtual prototypes, 
demonstrated that a certain degree of misunderstanding and uncertainty between team members 
was still present regarding the interfaces and the aesthetic qualities of the product. 
Accurate modelling of the graphics eliminated uncertainty and misunderstandings regarding the 
interfaces of the target product providing a common visual reference between team members. 
Another benefit of applying photorealistic models is the accurate modelling of the appearance of 
the target device. Virtual prototyping can potentially increase time and effort in the design of an 
electronic device but at the same time it provides the capabilities to design better products. 
Photorealistic modelling enables art designers to put together different models by modifying or 
adding new graphical components. In the competitive electronic consumer market the accurate 
modelling of the aesthetic qualities can be a determining factor in the success of the product. 
- 175-
Chapter 7 Conclus;olls alld Future Work 
-------------------------------~==~~~~~~~~~~~~ 
OK PIu$  
Figure 7-2 Crude graphics and photorealism 
The aesthetic appearance of handheld devices needs to be accurately modelled. Consumers are 
often attracted to a product rather than another one with similar functionality because of its 
aesthetic attractiveness. As shown in Figure 7-2 a photorealistic model can give a very good 
idea of the appearance of the target device while a crude graphical model only provides a rough 
idea of features such as the number of buttons. The photorealistic model instead can be used to 
accurately explore specific aesthetic facilities of graphical components within the device, such 
as size, colour, shape, position of components on the device, etc . For this reason YOM was 
designed to provide the capability to modify these features within its workspace. 
7.1.3 Requirements Analysis and Specification Development 
Another objective of the ViPERS approach was to provide the means to add value to the 
requirements analysis stage and actively integrate it into the design flow. To add value to the 
requirements analysis the ViPERS framework provides support for the implementation of 
executable models which can be used for early analysis of the interfaces and functionality of the 
target product. Requirements analysis must be detached from implementation details and at the 
same time products need to be described in a way which would be understandable by 
individuals with different background knowledge. Defining the requirements of a product 
involves the collaboration of various stakeholders. At this stage, managers, investors, 
- 176 -
Chllpter 7 Conclusions lind Future Work 
marketing teams as well as engineers need to collaborate to specify the requirements of the 
target product. UML is effective in describing systems in an intuitive way which is not tied to 
any specific implementation. But UML still requires knowledge of its syntax to be understood. 
The ViPERS approach applies UML semantics for the implementation of executable models. 
These models were then connected to graphical models to implement virtual prototypes. UML 
executable models are very easily put together and are not committed to any particular 
implementation. These models have the benefits of standard UML diagrams as well as 
providing an intuitive way to analyse the requirements of the target product. The target product 
is first described in standard UML and then refinements provide state machines to provide 
dynamic features to those descriptions. The execution of the model in conjunction with the 
graphical model provides a virtual prototype which when simulated requires no technical 
knowledge, not even UML, to be understood. The aim of the ViPERS approach is to allow easy 
and fast construction of these models was achieved. Experiments described in previous chapter 
of this thesis illustrated the benefits of UML executable models in enabling team members with 
different backgrounds to understand and modify the requirements easily. Another advantage of 
UML models is the possibility of reusing code. The dynamic features of the target product are 
described by means of state machines. Depending on the level of detail of this implementation 
embedded code can be automatically generated by UML tools. Reuse of code in UML models 
needs to be further explored, since, it currently only relies on the detail of implementation and 
on the translation mechanism offered by proprietary tools. Reuse of code can be applied to 
increase the value of requirements analysis. The capability in the ViPERS framework of easily 
putting together several candidate solutions demonstrated to be very advantageous in the 
requirements analysis. Designs are not committed to any particular implementation until a 
solution is accurately defined. 
A number of issues were not solved or addressed within this project. The UML executable 
model used for requirements analysis should be automatically translated into a high level 
SystemC model. This would optimise the process and would further integrate the requirements 
into the design flow for SoCs. In the ViPERS approach, currently, existing UML models are 
not linked to SystemC implementations. This means that after the UML model has been 
verified and the requirements have been defined, designers need to redesign from scratch the 
SystemC description of the target device. A translation mechanism will need to be introduced 
in order to better integrate the steps between requirements and design of a target product. 
Considerations on the translation between SystemC and UML are presented in the section on 
future work. A drawback of this missing link is that it pushes designers to consider a different 
approach, from the one suggested here, i.e. to start the modelling directly from a SystemC high 
-177 -
level model. This approach was experimented and can be considered as an alternative to the 
suggested design flow. The drawback of this approach is that the SystemC model is not as easy 
to implement as the UML version and requires more effort. Additionally the code is harder to 
modify and testing different candidate solutions becomes tedious. The SystemC model. unlike 
the UML counterpart. is tied to a specific language of implementation. and therefore provides 
fewer implementation alternatives to designers. 
Another unresolved issue is the coherence of models at different levels of abstraction. This 
problem relates not only to requirements analysis but also to the SystemC refinement process. 
The approach suggested in the ViPERS approach is based on different abstraction levels and 
refinements processes. The UML model in the requirements analysis is the highest level of 
abstraction within the ViPERS approach. The refinement of models implies that once a model 
has been verified details are added to this model to produce lower levels of abstraction. The 
problem arises when modifications are made to a model in the lower levels of implementation 
and no mechanism exists to feed back the changes to higher level models. This results in 
inconsistency between models at different levels of abstraction. This can result in loss of time 
especially when a product has to be designed as an improvement of a product previously 
released on the market. 
From the argument presented above it is clear that the ViPERS approach has only partly solved 
the problems related to requirements analysis and specification development. A lot of the future 
work presented in the next section is therefore related with the issues described in this section. 
7.1.4 Performance Analysis 
When using software intensive electronic handheld devices. users have different degrees of 
acceptance for delays in reactions of the device in relation to hislhers actions. Some delays are 
considered acceptable, some are not even perceived, whereas others are considered 
unacceptable. Virtual prototypes were successfully applied in the ViPERS approach to explore 
delays and determine their acceptability. Determining delays and reaction speed of the device 
can be important in the implementation stages, where engineers need to partition functionality 
between hardware and software, and choose specific hardware components such as the 
processor, the display, etc. 
The advantages of performance analysis were experienced during the case study presented in 
Chapter 6. The remote control designed had a custom display. The selected icon blinks in order 
to show to the user which function he/she is controlling. The time interval between switching 
the backlight of the blinking icon on and off was under exploration. It was realised how the 
- 178 -
- Chllpter 7 Conclusions lind Future Work 
usability of the remote control could considerably be affected by changing the interval time for 
the blinking. An optimal solution was defined by obtaining feedback from users who tested 
different solutions. This type of performance analysis, within the ViPERS framework can be 
achieved in both UML and SystemC models. Both models can benefit from timing constructs 
which allow the insertion of delays. Where the simulation speed does not allow speeding up of 
a specific reaction, a higher level model can be used, keeping in mind what was described by 
Thorn [34] and illustrated in Chapter 2. 
7.1.5 Virtual Context for Prototypes 
As described in the introduction of this thesis one of the objectives of the ViPERS framework 
was to provide the means to model not only the features related with the target device, but also 
its interaction with other devices. This was achieved by implementing interactive three 
dimensional virtual environments as described in Chapter 4 and illustrated in the case study in 
Chapter 6. The aims are to enhance the experience of using virtual prototypes by modelling its 
interaction with other devices which would usually interact with the target product in the real 
world. In the case study presented in chapter 6 the virtual environment is a kitchen which the 
user can navigate into during simulation. When the user interacts with the two dimensional 
model of the remote control, the virtual cooker in the kitchen responds to the user's action. This 
allows the user to view the consequences of hislher actions on both the display of the remote 
control and on the cooker in the virtual world. In the approach described the value of a context 
for the virtual prototype is limited. More relevance to this approach is found in more 
sophisticated simulations where for example the virtual prototype interacts with multiple 
devices. The case study showed how the context improves the user experience during the 
simulation, by providing a more realistic simulation environment. The drawbacks of this 
approach are the complexity and time of implementation. Sophisticated three dimensional 
environments require expertise in the 3D graphics field, and additionally the time of 
implementation might be considerable. The decisions about whether to use sophisticated 
graphical modelling needs to be made on a case-by-case basis. In the remote control case study, 
for example the implementation of the 3D kitchen could have been avoided since its advantages 
were relatively small, due to the simple nature of the simulated product. In more complex 
simulations, the advantages of providing an environment might make it worthwhile to commit a 
designer to the implementation of the 3D environment. Future work in the ViPERS framework 
will include the implementation of complex virtual environments to further investigates the 
benefits and disadvantages of this approach. 
- 179-
- Chapter 7 Conclusions and Future Work 
7.1.6 Projection 
Finally this section discusses the use of projections for visualising simulated models. In the 
case study described in the previous chapter projection was applied to both the graphical models 
(2D remote control and 3D kitchen) and the behavioural models (UML-EFM of the remote 
control and SystemC-EFM of the cooker) simultaneously. This approach enhanced the 
communication ofteam members in the design phase. Visualisation of both the behavioural and 
graphical simulations allowed team members to concUlTently follow simulations and initiate 
discussions. This experiment was aimed at showing the possibility of visualising virtual 
prototyping simulations through a different means from the computer monitor used in previous 
examples. 
7.2 Future Work 
In this section, possible enhancements to the ViPERS approach and environment are discussed. 
Some of the motivations of the work presented in this section can be found in the considerations 
made in the previous section. 
The future work can roughly be divided six topics: 
1. Environment Modelling. 
2. Communication refinement. 
3. Requirements analysis and specification development. 
4. Transformations and code generation. 
5. SystemC implementations. 
6. Predicting usability. 
7.2.1 Environment Modelling 
The intended future work in modelling virtual environments in the context of the ViPERS 
approach is referred to as prototyping human experience. Complex virtual three dimensional 
environments can be implemented where multiple devices can interact. Designers can then 
separately model the behaviour of each device as well as modelling the interaction between 
them. Parameters set by designers within the virtual environment will influence the interaction 
between the devices. If for example, two devices are communicating from two separate virtual 
- 180-
~ _______________________________________ ~C~h~Q~p~t~er~7_C~on~c/~u~s~lo~n~s~Q~n~d~F~u~tu~r~e~W~o~r~k 
rooms in the environment, the distance and the wall influence the speed and quality of 
communication. The distance, the thickness and the material of the wall are an example of the 
type of parameters within an environment which can influence the communication of the 
devices. Designers should be able to easily modify those parameters and explore different 
scenarios. Special attention can be given to displays within the environments, by applying 
special rendering techniques to them [106]. A sophisticated communication network can be 
developed to allow the interaction of all the components within simulations. One of the major 
applications of these virtual environments can be in home automation. We are currently 
experimenting with the creation of three dimensional virtual houses, where home automation 
mechanisms are present. This should enable the exploration of the applicability of virtual 
prototyping in complex virtual environments for home automation. 
7.2.2 Communication Refinement 
The communication framework in the ViPERS environment did not constitute a bottleneck in 
the experiments and the case study presented in this thesis. It is considered in the future work to 
refine this communication framework in order to deal with multiple complex real-time systems 
interacting in virtual environments. Part of the future research will be based on optimising the 
use ofTCPIIP sockets by considering issues such as Internet latencies, data-packet size etc. The 
graphical user interface of LCCS will be designed to provide users with control over registered 
components. LCCS can be enabled to inject signals into pre-registered systems and subsystems 
and to run separate windows to show signal traces of components set by the user. Log files can 
be used to collect timings of the exchange of messages to further explore the performance in the 
communication framework. Different communication frameworks can be taken into 
consideration and compared to the current approach adopted in LCCS. At present LCCS acts as 
a central server and therefore controls the exchange of messages between distributed objects. 
Further work can also involve the creation of additional links to other external tools. LCCS 
could contain a library structure which contains all the independent links which external tools 
might require. This can enable the packaging of the communication mechanism to offer 
designers a fast solution and an easier approach. 
The interface of LCCS can be made to contain a workspace where the user can drag and drop 
simulation elements and connect them together. The example illustrated in Figure 7-3 shows a 
simulation made up of four graphical models (YDM Model, YDM Model J, YDM Model 2, and 
YDM Model 3) driven by different functional models (GoGentric J, GoGentric 2, SystemG 
Gontainer, and UML-EFM) which are interacting within a three dimensional virtual 
- 181 -
Chapter 7 COllclusiolls alld Futllre Work 
'-------------------------------------------------~~-~~--~~~~~~~---------------
environment (Win32-3D Environment I). The library of components would be made up of 
graphical models, executable functional models and ad-hoc links such as the ones described in 
Chapter 5 to allow the graphical and functional components to communicate during the 
simulation. For example a user would not be able to directly connect a YOM model to a UML-
EFM; a UML socket component would have to be placed between them. 
Libra 
CoCentric Model 
YOM Model 
Win323D 
Environment 
UML-EFM 
UML-socket 
SystemC 
Container 
CoCentric sockl 
CoCentric sock2 
CaCentric sock3 
CoCentric sock4 
SystemC 
Container 
UML-EFM 1-
LCCS Works ace 
CoCentric 1 t-- CoCentrlc sockS YOM Modell J 
CoCentric 2 .r- CaCentrlc sackS}-- 110M Model 2 J 
VOM Model I I 
Win32-30 I 
Env l ro~ 
UML-socket 1-- VDM Model 3 I 
SvstemC 
Container 
Figure 7-3 LCCS CUI 
Currently a user needs to execute the functional and graphical models separately. With a 
framework such as the one discussed in this section the user would only have to import the 
models into the library of LCCS, drag them into the workspace and connect them together. This 
would allow more control over complex simulations where mUltiple models, functional and 
graphical, are interacting with each other. LCCS would know the location on the network of the 
components which have been imported into the library. The user should be able to select any of 
the components in the workspace and retrieve information about them, view their code, and 
control them from the interface of LCCS. At run time, models and connections which are 
actively interacting can be highlighted. The main purpose of the framework would be to launch 
and monitor simulations. In fact the suggested framework would not need to change the 
communication mechanism currently employed but it would provide a graphical representation 
which would allow designers to easily set up a simulation and view the data, for both the 
models and the simulations. 
- 182 -
'-_______________________________________ ~C~h~ap~t~e~r~7~C~o~n~c~/~us~1~o~n~s~a~n~d~F~u~t~u~re~W~o~r~k~ 
7.2.3 Requirements Analysis and Specification Development 
A considerable portion of the future work could be in requirements analysis and specification 
development field. As previously described in this thesis virtual prototyping supports the 
specification of some of the features of the target device but it provides no direct support for 
others. An exploration could be undertaken to determine what the specification of a target 
device should contain, and which services can be implemented to support designers to 
accurately specify all the features that need to be defined. 
In the analysis phase paper prototyping can be taken into consideration. The approach suggests 
the use of hand drawn sketches of the graphical interfaces of the target implementation, which 
can be pre-drawn or simply drawn during an interview, which a designer shows to a potential 
user. According to the actions suggested by the user, the person in charge of the test changes 
the sketch of the current interface with an updated sketch of the graphical interface. The 
benefits of this approach are described by Grady [118]. Some of the benefits are the low costs 
in term of time and materials, the critical feedback from users, who are more willing to suggest 
significant changes when the design is rough, and willingness of the designer to change the 
design since they have invested limited time and effort on it. Sefelin et al [119] compare the use 
of paper prototypes with computer-based prototypes. The conclusions of Sefelin et al are that 
both types of prototypes lead to the same quantity and quality of critical user statements but 
subjects prefer computer prototypes. Since the comfort of subjects is an essential factor in 
usability tests, this implies that design teams should prefer the use of computer based 
prototypes. However, Sefelin et al illustrate that paper prototypes may still be preferable when 
the available prototyping tools do not support the components and the ideas to implement, when 
design members with limited software skills are to be included in the design, or when the tests 
lead to a lot of drawings. 
In the case of handheld devices the sketches of paper prototypes would be likely to represent the 
graphical interface of the display of the device. The ViPERS framework can support paper 
prototyping using VDM as the tool to generate the screenshots of the display of the target 
device. Firstly this can provide designers with a more effective way to create sketches, while 
providing a much higher graphical quality than a hand drawn sketch. Additionally the 
interfaces designed to conduct paper prototyping tests would be reused for the graphical model. 
This allows a refmement mechanism for the graphical model, which means that the analysis of 
the target design can commence even before the graphical model is completed. In this approach 
the two types of prototyping are not compared but the refinement of the paper prototype leads to 
the development of the computer-based prototype. 
- 183 -
-- Chllpter 7 Conclusions lind Future Work 
Another feature which can be included to aid the analysis and specification of the target device 
is support to parameterise some of the features of the virtual prototype. This can allow 
designers to set boundaries of acceptance upon certain features which have been under analysis. 
The virtual prototype can then be simulated several times by changing the parameterised values 
in order to analyse how the changes are perceived. This parameterisation can be controlled 
directly form the graphical model and the designer should be aware of all the parameters which 
have been set on the virtual device. Hardware and software engineers for example could 
suggest, based on their technical knowledge and their experience, that the blinking of the icon 
on a display will be likely to be within a range. This range can be used as a parameter on the 
virtual prototype so that HCI consultants can change it and test how the user perceives the 
different values. This would eliminate the risk of unrealistic requirements. Conversely the 
parameters might be set by the HCI consultants first, who might define, based on usability tests, 
that the speed of the blinking icon must not be below a certain value otherwise users would 
consider it unacceptable. This could, for example, force hardware and software engineers to 
design the system in order to satisfy that requirement. 
An exploration of the Model Driven Architecture (MDA) field could be undertaken to enable 
the ViPERS approach to provide the capabilities to incorporate the development of Platform 
Independent Models (PIM) and Platform Specific Models (PSM). The use of the 
Metamodelling Object Facility (MOF) can be considered to provide a SystemC metamodel 
which could eventually be used to translate the UML model into SystemC. UML models such 
as the ones described in Chapter 5 and Chapter 6 make use of capsules, ports connectors and 
protocols. The structure of these models which is often seen in the MDA approach resembles 
the structure of transaction level models used in SystemC. Transaction level models use 
channels, interfaces and ports to communicate between different blocks. This could be used as 
a meeting point for the translation between SystemC and UML. Another advantage of such an 
approach would be that the transaction level would be a very good starting point for the 
SystemC model. In fact, transaction level models may be simulated very rapidly and could 
therefore, depending on the complexity of the model, still provide real-time performance when 
combined with graphical models. 
7.2.4 Transformations and Code Generation 
This section presents a scheme for the transformation of models and code generation. Figure 
7-4 shows a design flow which could be explored within the ViPERS environment. The 
diagram shows that three abstraction layers can be individuated in SoCs, the application layer, a 
- 184-
Chapter 7 Conclusions and Future Work 
'-------------------------------------------~~~-~~~~~~~~~~~~~--~--
layer that contains RTOS and drivers and finally a layer containing the platform and the various 
hardware and software blocks. 
Applications 
Drivers I 
RTOS I 
Platform 
Hw/Sw 
Metamodelling (Translation of Models) MOF 
------------------------------------------------------------------ - ---- ... _---
Syntheslsable 
VHDL, SystemC, Verilog 
Figure 7-4 ViPERS future design now 
Future work could focus on the modelling of both the application and platform layers. UML 
can be applied to describe both layers separately, using domain specific profiles. Specific 
profiles might be implemented within the ViPERS framework. For the application layer, an 
MDA approach can be adopted to create PIMs and transform them into PSMs. Metamodelling, 
using MOF can be applied to both UML models in order to translate them to specific languages. 
The platform model can be transformed into a SystemC transaction level model, while the PSM 
will automatically generate the embedded code (C, C++, Java, etc.) for the target platform. The 
SystemC TLM can be refined following the SystemC design methodology as described in 
previous chapters of this thesis. The complete implementation of the system can be available at 
the end of the process. Virtual prototypes could be used from the initial UML description of the 
system, down to the final implementation. 
- 185 -
'-_______________________________________ ~C~h~Q~p~t~e~r~7~C~D~n~c~/u~s~I~D~n~S~Q~n~d~F~u~t~u~re~W~D~r~k~ 
7.2.5 SystemC Implementations 
Most of the future work in SOC design with SystemC could concentrate on exploration of 
different implementations. The work can be purely experimental and can provide the possibility 
of analysing the different models to establish their benefits and drawbacks. Transaction level 
and register transfer level models of complex systems can be implemented (RTL-EFM and 
TLM-EFM) as executable functional models. Routes to synthesis of SystemC code or 
translation to VHDL and VERILOG can be explored. 
The use of emulators in conjunction with virtual prototyping can be further explored. 
7.2.6 Predicting Usability 
One of the considerations made after the exploration of virtual prototyping showed in this thesis 
is that virtual prototypes can be used to predict the way the target product will be used. 
Predicting the use of a product can be very important in several applications. One future 
experiments could be focused for example on adopting virtual prototypes to study the usage of 
colours (red, green, and blue) on OLED (organic light-emitting diode) displays within a 
specific device. The colours on OLEO displays present different degrees of degradation, and 
specifically, the blue colour degrades faster than other colours. A virtual prototype can be put 
together and feedback from users can be obtained to explore how the target device would be 
typically used. A log file can record the display changes and evaluate the usage of different 
colours. Decisions can then be made on how to modify the graphical interfaces in order to 
minimise the consequences of degradation. Modified graphical interfaces can then be shown to 
users through virtual prototypes to check if the changes are realised. Future work in this field 
can be done in conjunction with the exploration of the degradation of OLEO displays and 
solutions proposed by Antonio-Torres [120]. 
This approach is limited by the fact that the predictions of the usability of a target product are 
not precise but an assessment. Another limitation is that only specific devices or applications 
can be used for predicting their usability. 
- 186-
References 
References 
REFERENCES 
-188 -
Referellces 
Myers, B.A. and Beigl, M. Handheld computing, Computer Magazine, Published by the 
IEEE Computer Society, September 2003, pp. 27,0018-9126/03. 
Berger, A.S. Embedded Systems Design. An Introduction to Processes, Tools & 
Techniques, CMP Books, 2002, 1-57820-073-3. 
Chang, H. Cooke, L. Hunt, M. Martin, G. McNelly, A. and Todd, L. Surviving the SOC 
Revolution, A Guide to Platform-Based Design, Kluwer Academic Publisher, United State 
of America, 1999,0-7923-86795, pp. 2. 
4 Moore, G.E. Cramming more components onto integrated circuits, The experts look 
ahead, Electronics, Volume 38, Number 8, April 1965, pp 35-39 
5 International Technology Roadmapfor Semiconductors (ITRS), 2003 Edition. hit l :l/puhli 
c. ilr .ner [accessed: 01/11/2004] 
6 Cooper, J. Greenberg, D. and Zuk, J. Reshaping the funnel: Making innovation more 
profitable for high-tech manufacturers, IDM Institute for Business Value, United States 
2002. hnp://www-l .ibm.com/solulions/plm/doc/conlcnLlhin/ ')~ E5 1 O-:l244 -00F. x iI" [acces 
sed 18/11/04] 
[accessed: 0111112004] 
8 Annex 1 : Description of Work, VIPERS Project, 1ST - 2000 - 30023, date of preparation 
of Annex 1 10/04/2002 (l.Arnmendment). 
10 Grotker, T. Liao, S. Martin, G. and Swan, S. System Design with SystemC, Kluwer 
Academic Publishers, Norwell, MA, 2002, 1-4020-7072-1 
11 Muller, W. Rosenstiel, W. Ruf, 1. Martin, G. and Grotker, T. SystemC, Methodologies and 
Applications, Kluwer Academic Publishers, 2003, 1-4020-7479-4 
12 Open SystemC Initiative. SystemC Version 2.0.1 Language reference manual. Revision 
1.0,2003, www. y temc.org [accessed: 01/1112004] 
13 Open SystemC Initiative. SystemC Version 2.0 User's Guide, 2001, available at 
www.syste l1lc.org [accessed: 01111/2004] 
14 VRP Project, Virtual Reality Prototyping, hUp://WWW.Vll.fi/clc/rc car h/soh/projccls/vrp/ 
vrp.htl11 ,1996-1998. [accessed: 0111112004] 
15 VIRPI Project, Virtual Prototyping Services for the Electronics and Telecommunications 
1996-1999 [accessed: 
01111/2004] 
- 189 -
Re/eretlces 
'----------------------------------------------------------------------~-~~~-
16 VIRVE Project, Distributed Virtual Reality Prototype-Based Design of a New Product in 
Networked Electronics and Telecommunication Companies, hllp:ll\Vww.hci.oulu .fi /virvc/, 
1999-2001 [accessed: 0111112004] 
17 PAULA Project, htl :/1 au la.oulu .fi /, 1998-2001 [accessed: 0111112004] 
18 CyPhone, ESPRIT-25946 1998-1999. htl :ll allla .oulu .fi / indcx . 1h )3?dil - Publicali on 
&click= Cyphone [accessed: 01/1112004] 
19 BEYOND Project, beyond the graphical user-interface Eureka 2023/ITEA 99002, lill ):/1 
www.e tra.reearch.phili ps.com/clIProjecl Ibeyond/ 1999- 2001 [accessed: 0111112004] 
20 Object Management Group, Unified Modelling Language (UML) - Version 1.5, OMG 
document forma1l2003-03-01, Needham MA, 2003. 
21 Lister, P.F. Bassett, M.e. Watten, P.L. Trignano, V. Jackson, BJ.e. A SystemC based 
Virtual Prototyping Methodology for Embedded Systems, In Proceedings of JP-SOC 
2004, IP Based SOC Design Forum and Exhibition, Grenoble, France, December 8-9, 
2004. 
22 Lister, P.F. Newbury, P.F. Watten, P.L. Senkoro, L. Dountsis, A. Midha, M. Banerjee, 1. 
Trignano, V. and White, M. Virtual Reality in Electronic Systems, In Proceedings of 5th 
International Conference on Business Information Systems, Poznan, Poland, April 2002. 
pp. 390-394. 
23 Lister, P.F. Watten, P.L. Lewis, M.R. Newbury, P.F. White, M. Bassett, M.C. Jackson, 
B.1.e. and Trignano, V. Electronic Simulation for Virtual Reality: Virtual Prototyping, In 
Proceedings of Theory and Practice of Computer Graphics 2004 (TPCG04) , 
Southampton, UK, June 2004. pp. 71-76, ISBN 0-7695-2137-1 
24 Lister, P.F. Trignano, V. Bassett, M.C. and Watten, P.L. UML-Executable Functional 
Models of electronic systems in the VIPERS Virtual Prototyping Methodology, In 
Proceedings of Forum on Specification and Design Languages (FDL '04), Lille-France, 
13-17 September 2004, ISSN 1636-9874 
25 Lister, P.F. Trignano, V. Bassett, M.C. and Watten, P.L. Extending SystemC for high-
level multi-platform SoC simulations, In Proceedings of the lEE Postgraduate Seminar on 
System-on-Chip Design, Test and Technology, September 2, 2003, Cardiff, UK Pp 19-24, 
ISSN 0963-3308. 
26 Lister, P.F. Trignano, V. Bassett, M.e. and Watten, P.L. UML-Executable Functional 
Models of electronic systems in the VIPERS Virtual Prototyping Methodology, Advances 
in Design and Specification Languages for SoCs , Kluwer Academic Publishers, Chapter, 
pp. (To be published around March 2005) 
- 190 -
'-___________________________________________________________________ =R~efLe~r~e~n~c~e~s 
27 Lister, P.F. Trignano, V. Bassett, M.C. Watten, P.L. and Jackson, BJ.C. Applying 
ViPERS: A Virtual Prototyping Methodology for hand-held electronic device The RF-
Remote Control Device Case Study, In Proceedings of The Embedded Systems Show 2004 
(ESS 2004), UK Embedded PhD Forum, October 13-14, 2004, NEC Birmingham. 
28 Lister, P.F. Trignano, V. Bassett, M.C. Watten, P.L. and Jackson, B.J .e. ViPERS: A 
Virtual Prototyping Methodology for hand-held electronic devices, e-book (Proceedings of 
the First UK Embedded Forum), Editors Koelmans, A. Bystrov, A. Pont, M. Published 
December 2004, University of Newcastle upon Tyne, pp. 4-15, ISBN 0-7017-0180-3. 
29 Lister, P.F. Watten, P.L. Newbury, P.F. Bassett, M.e. Jackson, B.J.C. and Trignano, V. 
Virtual Reality for Electronic Product Development of Hand-held Devices, In Proceedillgs 
of the Design Automatioll and Test ill Europe Conference and Exhibition (DATE '04), 
Paris, February 2004. 
30 Rational Rose RealTime, www.ibl11 .conv. o llwa rc/rationall [accessed: 0111112004] 
31 Co Centric System Studio Reference Manual, Synopsys, v2002.05-SP1, December 2002 
32 Garcia, A.B. Gocke Jr., R.P. and Johnson Jr., N.P. Virtual Prototyping: Concept to 
Production, Defense System Management College Press, Fort Belvoir, VA. 1994 
33 Hodgson, T. Virtual Prototyping, Handout 5.7. High Tech Marketing Compteck Federal 
Systems, Inc. , Dahlgren, VA, January 1998. 
34 Thorn, 1. Virtual Prototyping - Embedded Engineering in the Multimedia Age, AND 
technology white paper, hltp:llwww.andlr.conv'DocuI11Cnl Ivirlua1. pdr [accessed: 01/111 
2004] 
35 Kerttula, M. Salmela, M. and Heikkinen, M. Virtual Reality Prototyping - a Framework 
for the development of Electronics and Telecommunication Products, In Proceedings of 
the 8th IEEE International Workshop on Rapid System Prototyping, Chapel Hill, North 
Carolina, USA, 24-26 June 1997, 0-8186-8064-4. 
36 Salmela, M. and Pulli, P. A virtual Prototyping System for Electronics and 
Telecommunication Product Development, Online Proceedings of Virtual Reality 
Universe '97, Santa Clara, CA, April 2-4, 1997. 
37 Kerttula, M. Virtual Reality Prototyping of Electronics and Telecommunication Products, 
VR-SIG Seminar, Finland, 1998. 
38 McLeod, P. The availability and capabilities of 'low-end' virtual modelling (prototyping) 
products to enable designers and engineers to prove concept early n the design cycle, Pera 
Knowledge, Prime Faraday Partnership, November 200 I, 1-84402-018-5 
39 VTT electronics, Technical Research Centre of Finland, htt p://www.vtt.fi li nd xc .hlm. [ac 
cessed: 01111/2004] 
- 191 -
Re/erellces ~ ___________________________________________________________________ ~L_~~~ 
40 InfoTech research centre at the University of Oulu, Finland, http ://www.inrolcch .ou lu.fi /. 
[accessed: 01/11/2004] 
41 Nokia ltd, Copyright Nokia Corporation 2002. hI ://www.nokia.c m [accessed: 011111 
2004] 
42 Cybelius Software 2002, http://www.cybe liu .com [accessed: 0111112004] 
43 Watten, P.L. High Level Modelling and Design oj Display Systems, Doctoral Thesis, 
September 2002, School of Engineering and Information Technology, University of 
Sussex, Brighton 
44 Cruz-Neira, C. Sandin, DJ. DeFanti, T.A. Kenyon, R.Y. Hart, J.C. The CAVE: audio 
visual experience automatic virtual environment, Communications oj the ACM, Volume 
35, Issue 6, Pp 64-72, June 1992, 0001-0782 
45 Adobe Photoshop, Copyright 2004 Adobe Systems Incorporated http: //www.acJobc .col11/ 
products/photo hop/main.html [accessed: 0111112004] 
46 Discreet, 3ds max, Copyright 2004 Autodesk, Inc., hllp :l/www4 .cJi scrc't.com/3dsmax/ 
[accessed: 0111112004] 
47 Kerttula, M. and Tokkonen, T. Virtual Design of Multiengineering electronics systems, 
IEEE computer journal, November 2001, pp. 71-79,0018-9162 
48 Burdea, G.c. Keynote Address: Haptic Feedback for Virtual Reality, In Proceedings oj 
International Workshop on Virtual Prototyping, Laval, France, pp. 87-96, May 1999. 
49 SensAble Technologies, Copyright 1996-2004 SensAble Technologies, hll ) ://www. 
sen ab le.coml [accessed: 0411112004] 
50 Immersion, Copyright  Immersion Corporation 2004, http ://www.iml11crsioll .co I11/ [ac 
cessed: 0411112004] 
51 Manninen, T. Contextual Virtual Reality Prototyping - Cooperative User-Centred Design 
using Distributed Simulations, In Proceedings oj NordiCHI2000, October 23-25 - 2000, 
Stockholm, Sweden. 
52 Halttunen, V. and Tuikka, T. Augmenting Virtual Prototyping with Physical Objects, In 
Proceedings oJthe working conJerence on Advanced visual interfaces, Palermo, Italy, pp. 
305-306,2000, 1-58113-252-2 
53 Tuikka, T. Concept Development Support with Virtual Prototyping, TeamCAD: 
GVUINIST workshop on Collaborative Design, May 12-13, 1997, Georgia Institute of 
Technology, Atlanta. 
54 Schaaf Jr., J.C. and Thompson, F.L. System Concept Development with Virtual 
Prototyping, In Proceedings oj the 29th conference on Winter simulation, Atlanta, 
Georgia, United States, 1997, pp 941- 947, 0-7803-4278-X 
- 192 -
~ ___________________________________________________________________ ~R~e~f~e~re~,~,c~e~s~ 
55 Dostert, B.H. and Thompson, F.B. How features resolve syntactic ambiguity, In 
Proceedings of the 1971 international ACM SIGIR conference on Information storage and 
retrieval, SESSION: Natural language processing and query systems, pp 19-32, 1971. 
56 Berry, D.M. From Contract Drafting to Software Specification: Linguistic Sources of 
Ambiguity, Ambiguity in Natural Language Requirements Specifications, htt ):11. e.uwa te 
rloo.c - dberry/ambiguity.re .html [accessed: 0111112004] 
57 Tuikka, T. and Salmela, M. WebShaman: Collaborative Virtual Prototyping in the World 
Wide Web for Product Designers, Internet-Based Groupware for User Participation in 
Product Development, Workshop in conjunction with PDC '98 and CSCW '98. Seattle, 
USA, 14-18 November 1998, Volume 20, Issue 1, April, 1999, pp. 51- 55, ACM Press. 
58 Tuikka, T. User Actions as a Mediator for Concept Designers, In Proceedings of the 34th 
Hawaii International Conference on System Sciences, Hawaii 2001, -0-7695-0981-9/01, 
2001 IEEE 
59 Preece, 1. Rogers, Y. and Sharp, H. Interaction Design, beyond human-computer 
interaction, John Wiley & Sons, Inc. 2002, ISBN 0-471-49278-7. 
60 Kuutti, K. Battarbee, K. Sade, S. Mattelmaki, T. Keinonen, T. Teirikko, T. and Tomberg, 
A. Virtual Prototypes in usability testing, In Proceedings of the 34th Hawaii International 
Conference on System Sciences, Hawaii 2001, 0-7695-0981-9. 
61 Leppala, K. Kerttula, M. and Tuikka, T. Virtual Design of Smart Products, 
Cyberdesigner's Notebook, IT Press, 2003, 951-826-688-3. 
62 Salmela, M. and Kyllonen, H. Smart Virtual Prototypes: Distributed 3D Product 
Simulations for Web-Based Environments, In Proceedings of VRML2000/Web3D 
Conference, Monterey, CA, February 21-24, 2000. 
63 Tuikka, T. and Salmela, M. Facilitating designer-customer communication in the World 
Wide Web, Internet Research: Electronic Networking Applications and Policy, Vol. 8, 
No. 5,442-451 
64 Zorriassatine, F. Wykes, C. Parkin, R. and Gindy, N. A survey of virtual prototyping 
techniques for mechanical product development, In Proceedings Iw;tn Mech. Engrs Vol. 
217 Part B: 1. Engineering Manufacture, B081 02, MechE 2003 
65 Zubillaga, F. and Allen, c.R. Virtual Instrument Toolkit: Rapid Prototyping on the Web, 
lEE Internet Computing, September-October 1999, 1089-7801/99. 
66 Altia, Inc., Copyright 2004 by Altia, Inc., htl ): //www.a lli a. 0 111 [accessed: 01111/2004] 
67 AND Technology Research, Research and Development for Electronic Products, 
Copyright 1980-2004 AND Technology ResearchLimited htl )://www.ancllr.com [acces 
sed: 0111112004] 
- 193 -
References 
RAPID virtual prototyping tools, MMI solutions for Electronic Products, e-SIM LTD, 
Copyright2004 e-SIM Ltd http ://,ww.c-illl .com/ [accessed: 01111/2004] 
69 Amout, G. SystemC Standard, In Proceedings of the 2000 conference on Asia South 
Pacific design automation, Yokohama, Japan, 2000, pp. 573-578, 0-7803-5974-7 
70 Habibi, A. and Tahar, S. A Survey on System-On-a-Chip Design Languages, Proceedings 
of The 3rd IEEE International Workshop on System-on-Chip for Rea/-Time Applications, 
(IWSOC'03), Calgary, Alberta, Canada, June 30 - July 02, 2003, ISBN 0-7695-1929-6/03 
71 Alexander, P. Karnath, R. and Barton, D. System Specification in Rosetta, In Proceedings 
of the IEEE Engineering of Computer Based Systems Symposium, Nashville, Edinburgh, 
UK. April 2000. 
72 SuperLog. http://\\, , .SuperLog.org, 2003. [accessed: 04/11/2004] 
73 Sutherland, S. The Veri/og PLI Handbook, Kluwer Academic Publishers, 1999. 
74 Baraona, P. Penix, J. and Alexander, P. YSPEC: A Declarative Requirements 
Specification Language for YHDL, Current Issues in Electronic Model/ing, vol. 3, pp. 
51-75,1995. 
75 CynApps, Inc. Cynlib: A C++ Library for Hardware Description Ref erence Manual, 
Santa Clara, CA, USA, 1999. 
76 Domer, R. Gajski, D.D. Gerstlauer, A. Zhao, S. and Zhu, J. SpecC: Specification 
Language and Methodology, Kluwer Academic Publishers, 2000, pp 313. 
77 De Micheli, G. Hardware Synthesis from C/C++ models, In Proceedings of the conference 
on Design, automation and test in Europe (DATE '99), Munich, Germany, pp. 80,1999. 
78 Ku, D.C. and De Micheli, G. High-level Synthesis and Optimization Strategies 10 
HerculeslHebe, In Proceedings of the European Event in ASIC Design Conference 
(EuroASIC) , Paris, France, May 1990. 
79 Bellows, P. and Hutchings, B. JHDL - An HDL for Reconftgurable Systems, In 
Proceedings of IEEE Symposium on FPGAs for Custom Computing Machines, IEEE 
Computer Society Press, Los Alamitos, CA, Kenneth L. Pocek and Jeffrey Arnold, pp. 
175-184, 1998. 
80 Baird, M. Designers May Find C++ to Their Liking, Oct 03, 2001, CMP Media LLC, 
rt ic lc. i html '?a rt i ' Ie lcl= I 650370 
J. [accessed: 01111/2004] 
81 Yerkest, D. Kunkel, J. and Schirrrneister, F. System Level Design Using C++, In 
Proceedings of the conference on Design, automation and test in Europe (DATE 2000), 
Paris, France, 2000, pp. 74-83. 1-58113-244-1 
- 194-
References 
~-------------------------------------------------------------------~-~~~~ 
Kogel, T. and Bussaglia, D. SystemC Based Design of an IP Fowarding Chip with 
Co Centric System Studio, Synopsys User Group (SNUG), Europe 2002. 
Sanguinetti, J. Higher-Level Design Sees Plusses of C++, Electronic Engineering Times, 
November I, 1999. 
Panda, P.R. SystemC - A Modelling platform supporting multiple design abstTactions, In 
Proceedings of the 14th international symposium on Systems synthesis (ISSS'01), 
Montreal, P.Q., Canada, September 30 - October 03, 2001, 1-58113-418-5/01/00 I O. 
85 Holloway, S. Long, D. and Fitch, A. From Algorithm to SoC with SystemC and CoCen/ric 
System Studio, Synopsys User Group (SNUG), San Jose 2002. 
86 Swan, S. An Introduction to System Level Modelling in SystemC 2.0, Technical report, 
Open SystemC Initiative, 2001. htt):llwww .. stcmc.or ,I [accessed: 0111 112004] 
87 Kunkel, J. Toward IP-Based System-Level SoC Design, COMPUTER, Vol. 36, No.5, 
May 2003, pp. 88-89,0018-9162 
88 Getting Started with Co Centric System Studio, Synopsys, v2002.05-SP2, December 2002. 
89 Lavagno, L. Martin, G. and Selic, B. UML for Real, Design of Embedded Real-Time 
Systems, Kluwer Academic Publishers, 2003, 1-4020-7501-4 
90 Holt, J. UML for systems engineering, watching the wheels, lEE professional applications 
of computing series 2, 2001,085296 105 7 
91 Christel, M.G. Kyo, C.K. Issues in Requirements Elicitation, Technical Report, 
CMU/SEI-92-TR-012 ESC-TR-92-012, September 1992 
92 Rational Unified Process for Systems Engineering, http ://www.rntionnl.com/ [accessed: 
01/11/2004] 
93 Goodrich, V. and Olfman, L. An Experimental Evaluation of Task and Methodology 
Variables for Requirements Definition Phase Success, In Proceedings of the 23rd Hawaii 
International Conference on System Sciences (HICSS), Los Alamitos, California: IEEE 
Computer Society Press, 1990, pp. 201-206. 
94 Object Management Group, UML profile for Schedulability, Performance, and Time, 
OMG document ptc/03-02-03, Needham MA, 2002. 
95 Selic, B. The Real-Time UML Standard: Definition and Application, In Proceedings of 
the 2002 Design, Automation and Test in Europe Conference and Exhibition (DATE '02), 
Paris, France, March 04-08,2002 1530-1591102. 
96 Martin, G. UML for embedded systems specification and design: Motivation and 
Overview, In Proceedings of the 2002 Design, Automation and Test in Europe Conference 
and Exhibition (DATE'02), Paris, France, March 04-08,2002 1530-1591/02. 
- 195 -
'-___________________________________________________________________ R~ef~e~r~e~n~c~e_s 
Selic, B. and Rumbaugh, J. Using UMLJor modelling Complex Real-Time Systems, white 
paper, rational (Object Time), March 1998. 
Vanderperren, Y. Sonck, G. Van Oostende, P. Pauwels, M. Dehaene, W. and Moore, T. 
A design methodology for the development of a complex system-on-chip using UML 
and executable system models, Proceedings of Forum on Specification and Design 
Languages (FDL'02), Marseille, France, September 24-27,2002. 
99 Zhu, Q. Matsuda, A. Kuwamura, S. Nakata, T. and Shoji, M. An Object-Oriented Process 
for System-on-Chip using UML, In Proceedings oj the J 5th international symposium on 
System Synthesis (ISSS'02) , October 2-4 2002, Kyoto, Japan, pp. 249-254 1-58113-576-
9/02. 
100 Fujitsu Limited, Fujitsu Laboratories Limited, New SoC Design Methodology Based on 
UML and C Programming Languages, Technical Analysis, Vol.20, No.4, Tokyo, April 
101 Bruschi, F. Sciuto, D. A SystemC based design flow starting from UML models, 
Politecnico di Milano, Cefriel, Siemens ICM, OSCI presentation, 6th European SystemC 
User Group Meeting, Lago Maggiore, October 22, 2002. 
102 Vanderperren, Y. A Design Methodology for the development of a Complex SoC using 
UML and Executable System Models, OSCI presentation, 6th European SystemC User 
Group Meeting, Lago Maggiore, October 22, 2002. 
103 Zhu, Y.W. Wong, W.F. Kathy, N.D. and Thiagarajan, P.S. UML Jor System Co-design, 
National University of Singapore, Presentation, www.col11p.nus.cdu. sg/-cl11bsy fUM Uor 
104 Thornberg B. and O'Nils M. Evaluation of a SystemC-based Design Flow for Embedded 
System Design, Mid-Sweden University, Presentation, WWw.ilc.mh.sc/ icklro/forsknillg. 
web/Po ler -2002/po ler /ulvardering%20av%20Syslcm ,.pdf: [accessed: 0111112004] 
105 Sardini, A. SoC Design with UML and SystemC, OSCI Presentation European SystemC, 
6th Users Group Meeting, Lago Maggiore, October 2002. 
106 Senkoro, L. Texture Mapping Algorithms Jor Display in Virtual Reality, Doctoral Thesis, 
May 2004, School of Engineering and Information Technology, University of Sussex, 
Brighton, 2004. 
107 Pahl, G. Beitz, W. Wallace (Translator), K. Blessing (Translator), L. and Bauert 
(Translator), F. Engineering Design: A Systematic Approach, Springer-Verlag Berlin and 
Heidelberg GmbH & Co. KG. December 1995, ISBN 3-5401-99179. pp 10-11. 
108 Douglass, B.P. Doing Hard Time: Developing Real-Time Systems using UML, Objects, 
Framework and Patterns, Addison-Wesley, 0201498375, 1999 
- 196-
References 
~--------------------------------------------------------------------~-~~~ 
Douglass, B.P. Real-Time UML Second Edition, Developing Efficient Objects for 
Embedded Systems, Addison-Wesley, 0201657848, 1999. 
Hoffmann, H. From function-driven Systems Engineering to object oriented Software 
Engineering, I-Logix white paper, Systems and Microcontroller Division. 
Pasricha, S. Transaction Level Modellingfor SoC with SystemC 2.0, STMicroelectronics, 
In Synopsys User Group SNUG San Jose 2002. 
Cortona, VRML browser, Copyright 2000-2004 ParallelGraphics, blp://www. xlra l\ c1'r 
aphi c .com/products/cortona/, January 2004, [accessed: 01/1112004] 
Kimura, 1. and Verlag, S. Product Development with Mathematical Modeling, Rapid 
Prototyping, and Virtual Prototyping, Shaker Verlag, June 2002, ISBN 3-8322-0896-8, 
Chapter I. 
114 Artisan Software real-time Studio, Copyright 1998-2002, ARTiSAN Software Tools, 
http: //www.arti sanw.com/ [accessed: 01/11/2004] 
115 ILOGIX, Copyright 2004 I-Logix, 
cessed: 0111112004] 
116 Gay, W.W. Linux Socket Programming by Example, QUE, April 2000, 0-7897-2241-0 
117 Ikerlan, Centro De Investigaciones 
.h tl11 [accessed: 01/11/2004] 
118 Grady, H.M. Web Site Design: A Case Study in Usability Testing Using Paper 
Prototyping, Proceedings of IEEE professional communication society international 
professional communication conference and Proceedings of the 18th annual ACM 
international conference on Computer documentation: technology & teamwork, 2000, pp. 
39-45, 0-7803-6431-7/00 
119 Sefelin, R. Tscheligi, M. Giller, Virtual Paper Prototyping - What is it good for? A 
Comparison of Paper- and Computer-based Low-fidelity Prototyping, In Proceedings of 
Computer Human Interaction 2003 (CHI 2003), Short Talk: Issues in Software 
Development, Florida, USA, April 5-10, 2003. 
120 Antonio-Torres, D. Lister P.F. and Newbury, P. Modelling of a Compensation scheme for 
OLED Degradation, SID '04 Digest, Seattle, USA, May, 2004, pp. 1124-1127. 
- 197 -
Appendix 1 
Standard UML Description 
of the Remote Control 
'-__________________________ ~A~PuP~e_n~d~ix~l~S~t~a_n~d~a_r~d~U_~~L~D~e~s~c_r~ip~t~i~o~/I~o/~t~h~e~R~e~m~o~te~C~o~'~'t~r~o~1 
ApPENDIX 1 
STANDARD UML DESCRIPTION OF THE 
REMOTE CONTROL 
his appendix describes how standard UML I was used for the analysis and design of 
an RF-based remote control. The purpose of the target device was to control several 
functions of a domestic cooking stack such as the temperature of the oven, the 
ventilation speed of the hood, and the cooking timer. The design of the remote control was part 
of a collaboration between the Centre for VLSI and Computer Graphics2 at the University of 
Sussex and an electronics manufacturing company Ikerlan3. Other details on this collaboration 
are given in Chapter 6 of this thesis. 
The UML description and analysis of the remote control includes standard UM L diagram such 
as use-case and class diagrams as well as state and activity diagrams. The approach described 
in this appendix was used to analyse the requirements of the remote control and specify some of 
its features. 10 the context of the ViPERS approach this type of investigation takes place during 
the analysis phase described in Chapter 4 of this thesis. 
The analysis presented here was based on the material provided by fkerlan. The material 
included a rough picture of the remote control and a written document that described some of its 
functionali ty. 
I Object Management Group, Unified Modelling Language (UML) - Version 1.5, OMG document 
fonnal/2003-03-01, Needham MA, 2003. 
2 The Centre for VLSI and Computer Graphics is a research group in the School of Science and 
Technology in the Department oflnforrnatics at the University of Sussex 
3 Ikerlan, Centro De Investigaciones Tecnologicas, hit ) ://w\V\ .ikerl all .C. h ub/cas t/index .Ittl}} [accessed: 
01 / 11 /2004] 
- 2 -
'-__________________________ ~A~p~p~e~n~d~I~X~J_S~ta~n __ d_a_r_d_U __ Al_L __ D~e_s_C_rl~p_t_;_o_"_o~f~t_h~e_R __ e_m_o~t_e __ c_o_"~t_r~o~1 
1.1 Use-case diagram: Main 
This section will illustrate how UML use-case diagrams are used to describe how the users of a 
system interact with it. Figure I-I shows the main use-case diagram for the remote control. 
The diagram shows the presence of two main actors. One of the actors is the user that control 
the remote control and another one is the cooking stack which exchanges (sends and receives) 
messages with the remote control. 
Switch the remote control on and off 
u,,'~C) 
Send Messages to the remote 
Control the appliances 
C)~< -~ 
Receive messages from the remote CookingStack 
Figure 1-1 Use-Case for remote control 
The next sections explore the flow of events for the each use-case showed in Figure 1-1 . 
1.2 Use-case diagram: switching tile remote cOlltrol on and off 
1.2.1 Use case name: Switch remote control on/off 
This use-case applies to the user switching the remote control on and off. 
1.2.1.1 Brief descriptio" 
Pressing a side button on the remote control the user will be able to switch the remote control on 
and off. 
- 3 -
'-__________________________ A~p~p~e_n __ d_ix __ 1_S __ ta_n_d_a_r_d __ U_M __ L __ D_e_s_c_r~ip_t_;_o_n_o~f~t_h~e_R_e~m __ o~t~e_C~o~'~/~tr~o~1 
1.2.2 Flow of events 
1.2.2.1 Basicflow 
If the remote control is switched off the user can press the side button on the remote control and 
switch it on. If the remote control is switched on then the user can press the side button to 
switch it off. 
1.2.2.2 Alternate flows 
There are no alternate flows. 
1.2.3 Special requirements 
1.2.3.1 First special requirement 
The remote control will need to have the battery inserted and charged in order for the remote 
control to be switched on. 
1.2.3.2 Second special requiremellt 
If the battery of the remote control finishes the device will automatically switch off. 
1.2.4 Precondition 
The remote control needs to be switched off in order to be switched on and vice versa. 
1.2.5 Postcondition 
There are no postconditions. 
1.2.6 Extension points 
If the user switches the remote control off while setting a function for one of the appliance those 
settings will not be saved and therefore will not affect the cooking stack. 
1.3 Use-case: Monitor the appliances 
~ ______________ >~~ ______  _in_cl_ud_e>_> ____ >~~ 
Monitor the appliances 
Figure 1-2 Use-case (monitor the appliance) 
1.3.1 Use case name: Monitor the appliances 
The diagram for this use case is shown in Figure 1-2. 
- 4 -
Select the required appliance 
- Appendix 1 Standard UML Description 0/ the Remote Control 
1.3.1.1 Brief description 
The user can monitor all of the appliances on the cooking stack. This means that if for example 
the oven is turned on and is working at a fixed temperature, the user will be able to view on the 
display of the remote control all these parameters for the oven. The user can monitor an 
appliance by selecting it on the remote control. 
1.3.2 Flowofevents 
1.3.2.1 Basicflow 
The user selects the appliance that needs to be monitored using the select appliance button. 
Once the appliance is selected, the remote control displays the status and other parameters for 
that appliance. 
1.3.2.2 Alternate flows 
J .3.2.2. J By exiting the edit mode 
When a user exits the edit mode, the remote control automatically goes in a monitoring mode. 
1.3.2.2.2 Switching on the remote control 
When the remote control is switched on it automatically goes in a monitoring mode. 
1.3.3 Special requirements 
1.3.3.1 Exit the edit mode 
The user needs to exit the edit mode in order to enter the monitoring mode. 
1.3.3.2 Pressing the select appliance button 
The select appliance button has two different uses depending on the way it is pressed. In order 
for the user not to enter the edit mode the button must not be kept pressed for too long. A 
parameter set by the designer will control the length of time which will determine the behaviour 
of this button. If the button is pressed for a time longer than this parameter then the remote 
control will go in the edit mode. If the time is shorter then the remote control will stay in the 
monitoring mode and will move to the next appliance. 
1.3.4 Precondition 
The remote control must be switched on. 
1.3.5 Postcondition 
There are no postconditions. 
'-___________________________ ~A~p~p~e~n~d~;=x_l~S~t~a~n~d~a~rd~U~AI~L_D~e~s~c~r~;p~t'~O~/~I~o~f~t~h~e~R~e~n~lo~t~e~C~o~/~I~tr~o~/~ 
1.3.6 Extension points 
There are no extension points. 
1.4 Use-case: Control tlte appliances 
Program automatic cooking 
Program extractor hood 
include include 
Program backIng 
Cancel a program 
include  include 
Correct programmed parameter 
Program the timer 
Figure 1-3 Use-Case (control the appliances) 
1.4.1 Use case name: Control the appliances 
The diagram for this use case is shown in Figure 1-3. 
1.4.1.1 Brie/descriptio" 
The user can control some functions of the appliances of the cooking stack via the remote 
control. The next sections will give some details of all the possible actions which are included 
in controlling the appliances. 
'-_______________________ ~A~p~p~e~n~d~/~x~l~S~t~G~n~d~G~rd~U~AI~L~D~e~s~c~r/~p~t~/o~n~o~1~t~h~e~R~e~m~o~t~e~C~o~n~t~r~o~1 
1.4.2 Flowofevents 
1.4.2.1 Basicflow 
Firstly the user selects the required appliance by moving through them with the appliance 
selection button. Once the required appliance is selected, the user can enter the edit mode. The 
edit mode is accessed by keeping the appliance selection button pressed for a few seconds. Once 
the remote has entered the edit mode the user can switch on the selected appliance. The selected 
icon on the display will blink to enable the user to change the available options using the 
directional buttons (left, right, plus and minus). If the user selects the status to be on and the 
presses the ok button, the appliance will be switched on and another icon will start blinking. 
The actions to follow depend on the appliance that the user has selected. The remote control 
will guide the user through a number of different options which are specific to the selected 
appliance. 
'-___________________________ ~A~p~p~e~n~d~ix~l~S~t~a~n~d~a~r~d~U~A1~L~D~e~s~c~r~ip~t~,~o~/~'~o~f~t~h~e~R~e~m~o~t~e~C~o~'~'t~r~o~/_ 
1.4.2.2 Alternate flows 
1.4.2.2.1 Programming baking case 
When the status of the oven is set to be on it is then possible to select the type of baking desired 
for the oven. After choosing the type of backing by using the directional buttons, the user can 
use the plus and minus buttons to set the temperature. After setting the temperature the user can 
set some more parameters which will be displayed blinking on the display of the remote control 
in the following order: selecting the lock, selecting the duration and programming the stop time. 
The diagram for this use case is shown in Figure 1-4. 
Select the reQulr d appliance 
Set the temperature 
Aclil{l to th dlt mode 
include 
Program the stop time 
include 
Program baking 
include 
Choose type of baking 
 include 
include 
Program the lock 
Set the duration 
Exit the edit mode 
Figure 1-4 Use-case (programming baking) 
- 8 -
'-____________________________ A~p~p~e_n_d~i~x_l __ S_t_a_n_d_a __ rd __ U __ ~ __ L_D __ e_s_c_r~ipL_t'_o_,_,_o~[~t_h_e_R __ e_m_o __ le __ C_o_,_,_tr_o_l_ 
1.4.2.2.2 Programming automatic cooking 
If the hob has been selected, and switched on then the user can select the type cooking to 
perform on the hob. After choosing the type of cooking via the directional buttons, the user can 
set the temperature with the plus and minus buttons. When temperature is set the user can set 
some more parameters which will be displayed blinking in the following order: selecting the 
lock, selecting the duration and programming the stop time. The diagram for this use case is 
shown in Figure 1-5. 
Exit the edit mode 
Set the duration 
include 
Select the required appl iance 
include 
include 
Program automatic cooking 
Activate the Edit mode 
include 
include 
include 
Choose the type of cooking 
Program the lock 
Set the temperature 
Figure 1-5 Use-case (programming automatic cooking) 
'-___________________________ ~A~p~p~e~n~d~i=x_l~S~t~a~n~d~a~rd~U~kr~L~D~e~s~c~r~ip~tl~o~n~o~f~th~e~R~e~m~o~te~C~o~n~tr~o~/~ 
1.4.2.2.3 Programming theJuming extractor hood 
When the extractor hood is switched on the user can select the speed (using the plus and minus 
buttons) and the light to be on or off (using the right and left buttons). The diagram for this use 
case is shown in Figure 1-6. 
Exit the edit rrode 
 include 
include Set the speed 
 include 
9-_~>~ __ ~?~ 
A ~ Activate the Edit rrode 
Program the fuming extractor hood 
include 
include 
Turn the la I1'll on and off 
Program the lock 
Figure 1-6 Use-case (programming the hood) 
- 10 -
'-_________________________ ~A~p~p~e~n~d~'=x~l~S~ta~n~d~a~rd~U~~~L~D~e~sc~r~'~p~t~;o~lI~o~f~/=h~e~R~e~m~o~t~e_=C~o~lI~t~r~o~1 
1.4.2.2.4 Programming the timer 
Setting the type of alann and the timer is the same for all of the appliances. Right and left 
buttons are used to choose the type of alann (stop or end), and plus and minus to input the 
amount of time for the duration or the time to stop. The diagram for this use case is shown in 
Figure 1-7. 
Select the required appliance 
include 
Activate the Edit mode 
Q-~~O 
A Program the timer 
include 
Selecting the time 
Exit the edit mode 
Figure 1-7 Use-case (programming the timer) 
- 11 -
'-_________________________ ~A~p~p~e~n~d~'~x~l~S~ta~n~d~a~rd~U~Af~L~D~e~sc~r~'~p~t~;o~"~o~f~t~h~e~R~e=m~o~t~e_=C~o~n~t~r~o~1 
1.4.2.2.5 Programming the lock 
The user can also lock the appliance so that no change to it can be made until unlocked. This is 
done by scrolling through the options with the directional buttons and setting the status of the 
lock icon to on. The diagram for this use case is shown in Figure 1-8. 
Select the required appl iance 
include 
----::7>0 
 ;nclude 0 
~ Acl;vale Ihe Ed;1 mode 
Program the lock 
 include 
include 
Select the lock status 
Exit the edit mode 
Figure 1-8 Use-case (programming the lock) 
- 12 -
'-__________________________ ~ALPLP~e~n~d~;~x~J~S~t~a~n~d~a~r~d~U~Af~L~D~e~s~c~r~;LP~t~;o~/~'~o~f~th~e~R~e~m~o~t~e_C~o~n~t~ro~1 
1.4.2.2.6 Correcting programmed parameters 
The user can modify the parameters which were previously set. To do so, the user needs to 
enter the edit mode for that appliance and change the required values. For example, if the user 
has set the oven to a certain temperature, and then realises that this is too high, it is possible to 
enter again the edit more for the oven and modify the temperature to a lower value. The 
diagram for this use case is shown in Figure 1-9. 
Select the required appliance 
include 1 include 0 
~cli""'elheEdumOde 
--------::>7~ 
Correct programmed parameter 
 include 
include 
Set the required value 
Exit the edit mode 
Figure 1-9 Use-case (modifying parameters) 
1.4.2.2.7 Cancelling a program 
A user can cancel a program for an appliance by switching it off. 
1.4.2.2.8 Programming the time 
A user can also program the time by entering the edit mode and then scrolling to the clock icon 
with the directional buttons. The user can then use the plus and minus buttons to set the time. 
1.4.3 Special requirements 
1.4.3.1 Edit mode 
The user wiJ) always need to enter the edit mode in order to control any of the appliances. 
- 13 -
Appendix 1 Standard UML Description 0/ the Remote Control 
1.4.4 Precondition 
1.4.4.1 Enter the edit mode 
Users need to enter edit mode before attempting to control the appliance. 
1.4.5 Postcondition 
1.4.5.1 Exit edit mode 
After setting the parameters the user can exit the edit mode. Exit from the edit mode is achieved 
by pressing ok after having set all of the parameter for that appliance or by switching the remote 
control off. 
1.4.6 Extension points 
There are no extension points. 
1.5 Use-case: receive messages/rom the remote 
1.5.1 Use case name 
Receive messages from the remote. 
1.5.1.1 Brief descripdon 
The remote control can prompt the user with several messages. For example. the clock icon will 
blink when an alarm is triggered. 
1.5.2 Flow o/events 
1.5.2.1 Basicflow 
All the actions made by the user will provoke a change on the display of the remote control. 
Most of these changes are a consequence of the remote control updating the information sent to 
it by the cooking top. 
1.5.2.2 Alternate flows 
In special circumstances the remote control can display messages to advise the user of changes 
or malfunctioning. 
1.5.3 SpeCial requirements 
The' user can check the manual of the remote control in order to understand the meaning of 
those messages. 
1.5.4 Pre-condition 
The remote control needs to be switched on in order to display messages. 
-14 -
'-_________________________ ~A~p~p~e~n~d~ix~l~S~t~a~n~d~a~r~d~U~~~L_D~e~s~c~r~ip~t~i~o~n~of~t~h~e~R~e~n~'~o~te~C~o~'~'t~r~o~1 
1.5.5 Post-condition 
There are no postconditions. 
1.6 System descriptioll 
1.6.1 Main Packages 
This section shows how UML packages can be used to divide the entire system into smaller, 
more manageable units. 
Figure 1-10 shows the entire system divided into three main packages: 
 The remote control 
 The RF Interface 
 The Cooking Top 
Remote Control RF _Interface Cooking Top 
Figure 1-10 Packages of the system 
1.6.1.1 Remote Control 
The remote control package is subsequently divided into another three packages as shown in 
Figure 1-11. These packages are: 
1. The Behavioural Remote represents the functional description of the remote. It will 
include different classes which might be implemented for example in SystemC4 or 
UML-RT. 
2. The Remote Interface is the communication framework; the Local Communication 
Control Service (Chapter 4). 
3. The Physical Remote represents the graphical model of the virtual prototype of the 
remote control. 
4 Open SystemC Initiative. See http://www. ystcl11c.org/ [accessed: 0111112004] 
- 15 -
'-___________________________ ~ALP~p~e~n~d~'~x~l_=S~t~a~n~d~a~r~d~U~A1~L~D~e~sc~r~'~p~t~;~o~n~of~t~h~e~R~e~m~o~t~e_C~o~n~t~r~o~1 
~ II ~ 
BehaviouralRerrote Rerrotelnterface PhysicalRerrote 
The Behavioral rroOOI can ~ 
be rroOOled in both System 
The Physical model will be ~ 
i~lemented initially as a 2d 
C or UMl. The idea is to 
create a UML rroOOI for it s 
photorea~stic virtual prototype 
e for visualization purposes. 
o to facilitate the 
i~lementation in any 
chosen language. 
Figure 1-11 Packages of the remote control 
1.6.1.1.1 Behavioural Model: 
Figure 1-12 shows a series of example classes that might constitute the behavioural model of the 
remote control. In the example below the classes are set as stereotypes (sc_module). This 
implies that a future implementation will be done in SystemC. 
sc_ rrodule 
MicroController 
sc_rrodule 
UserlnterfaceStateMachine 
sc_rrodule 
BatteryManagment 
sc_rrodule 
RFMacrocellManagment 
Figure 1-12 Classes for the functional model 
- 16 -
sc_rrodule 
DlspiayControl 
sc_rrodule 
RFMacroceM 
'-_______________________ ~A~p~p~e~n=d~ix~l~S~ta~n~d~a~rd~U~A1~L~D~e~s~c~r~ip~t;~o~n~of~t~h~e~R~e~m~o~t~e~C~o~n~tr~o~1 
1.6.1.1.2 Remote Interface: 
Figure 1-13 shows LCCS as the only package for the internal communication interface of the 
remote control. LeeS contains a number of other classes which are not shown in this diagram. 
Refer to Chapter 4 of the thesis for details on LCCS. 
Figure 1-13 Internal Interface 
1.6.1.1.3 Physical Model 
The Physical model is made up of the classes that constitute the graphical model of the virtual 
prototype. The classes of the Physical Model are shown in Figure 1-14 and are: 
 Display 
o Sma117Seg 
o Large7Seg 
o Icon 
 Keypad 
o Button 
 ease 
Small7Seg Icon Large7Seg 
Figure 1-14 Classes for the physical model 
- 17 -
~ _________________________ A~PLP~e~n~d~;x~l~S~ta~n~d~a~rd~U~A1~L~D~e~s~c~r~;p~t,~'o~n~of~t~h~e_R~e~m~o~t~e_C~o~n~tr~o~1 
1.7 Sequence Diagram 
This section will show a UML sequence diagram to describe an example. Sequence diagrams 
allow exploring the interaction of users with the system or subsystems in relation to time. 
Figure 1-15 shows an example of a sequence diagram for turning the remote control on. 
1. 7.1 The user turns the remote control ON: 
I ~ I 
11 ..,-d  tnMNg. 
, 1 2 Mndl. "-Mg  
11212 Mnd'.rn114IIQe 
Figure I-IS Sequence diagram (turning the remote control ON) 
The diagram shows the interaction between the user, the keypad, the behavioural model, the 
display and the cooking stack. 
1.8 Interfaces exploration 
This section will explore the interfaces of the remote control. The section is divided into two 
main subsections. One concentrates on the keypad of the remote control and the other one on 
the display. 
1.8.1 The Keypad 
Figure 1-16 shows the photorealistic graphical model created in YOM for the remote control 
analysed in this appendix. The remote control is made up of seven buttons, a case, and a 
display. As described in Chapters 4, 5 and 6 of this thesis, during a simulation the graphical 
model connects to a functional model which drives its behaviour. When the user presses one of 
the buttons of the graphical model during a simulation, YOM sends a message through the 
TCP/IP socket to the functional model. The message is a string, which can either be "UP" or 
"DOWN". When the button is pressed the remote control sends the message "DOWN", and 
- 18 -
'-_________________________ ~A~PwP~e_"_d~;x~l~S~t~a_n~d~a_r_d __ U_A1 __ L __ D_e_s_c_r~;p~t_;_o_" __ oL/_t_h_e __ R_e_"_,~o~t e~C~O~/~' ~t r~o~1 
when this is released the message is "UP". VDM will attach the message to a tag which 
contains the identity name of the button. Examples of identity tags for the button are shown in 
Figure 1-16. 
1.8.2 The Display 
r------------ _____ _______ _ 
I <Button On/Off> UP or DOWN 
<Button Select> 
<Button Left> 
<Button Right> 
<Button OK> 
I <Button Plus> 
I <Button Minus> 
UP or DOWN 
UP or DOWN 
UP or DOWN 
UP or DOWN 
UP or DOWN 
UP or DOWN 
---------- ---- ------------
Figure 1-16 Keypad 
This section shows the structure of the display of the remote control. Figure 1- 17 shows a 
sketch of the display with all its egments (icons) while Table I hows how the di play might be 
divided into sections and how each section of the display is made of a collection of icons. 
AUTO-COOK ON OFF 
Figure 1-1 7 Display 
- 19 -
~ _______________________ ~A~p~p~e~n~d~i=x~l~S~ta~n~d~a~r~d~U~M~L~D~e~s~c~r~ip~t~io~,~, ~oL/~/~h~e~R~e~n~,~o~/ e~>~C~o~"~tr~o~1 
TAG<> TYPE Values 
APPLIANCE String oven 
f:I EBB ~ 
BATTERY Integer o to 3 
RF Integer o to 4 
STATUS String on 
NJr'O-COOK ON OFF ON 
autoCookOn 
NITO-COOK ON 
FUNCTIONS String r , 
defrosting L. .J 
~uu INvV'l 
tradHeat ~ 
jloorHeat ~ 
- 20 -
~ _______________________ ~A~p~p~e~n~d~;~x~l~S~t~a~n~d~a~rd~U~Af~L~D~e~s~c~r'~'p~t~io~,~,~o~/~t~h~e~R~e~m~o~t~e~C~o~'~'t~r~o~1 
1i'V'-' 
grillGentle L. .J 
grillStrong L. -l 
grill Vent L. -l 
rl"i'\' 
turboHeatFloor ~ 
heat Ventilated ~ 
heat ~.. 
Maintain 
Steam L.JLJ 
noPressure L-J 
I <> .. 
pressure L-J 
speedTurbo P 
r" ~~ 
Lamp ,,~ ~..c< 
LOCKED Boolean True or false 
DURA nON/STOP String 
duration ~ 
stop Time -+1 
SPEEDITEMPERA TURE String speed 
rl . ~ -~ 
- 21 -
'-________________________ ~A~p~p~e~'~ld~'~x~l~S~t~a~n~d~a~r~d~U~M~L~D~e~s~c~r~;p~t~io~/~I~o~f_t~/~/e~R~e~m~o~t~e_C~o~lI~tr~o~1 
--temperature 'e 
CLOCK Boolean True orfalse 
BUZZER Boolean True orfa/se 
SPEEDffEMP _DIGIT Integer o to 999 
TIME_DIGIT Integer o to 9999 
88:88 
Table 1 Icons of the display 
Table 2 shows an example of the messages sent in order to set some parameters of the cooker. 
MESSAGES DISPLAY 
<APPUANCE>oven EI 
<STATUS>on ON 
(r i' 
200011 <FUNCTION>defreezing 
J- -t \; / 
<SPEEDfTEMP _DIGIT>200 (9 
<SPEEDfTEMPERA TURE>temperature 00:00 
<LOCKED>true 
<CLOCK>true 
<T~E_DIGIT>OOOO 
Table 2 Messages to display (example) 
- 22 -
'-_____________________ ~A~p~p~en~d~/~x~l~S~ta~n=d~a~rd~U~M=L~D~e~s=c~r/~p=t/~o~n~o~t~t~h~e~R=e=m~ot~e_C~o~n~t~r~o~1 
1.9 Searching lor Classes 
The next section will briefly describe the remote control and its functionality. This description 
is used to individuate the different classes, attributes and methods. 
1.9.1 Briel Description of the remote control 
The REMOTE CONTROL will be used to CONTROL, MONITOR and PROGRAM the three 
APPLIANCES that make up the COOKING TOP: OVEN, HOB and HOOD. 
One REMOTE CONTROL interacts only with one COOKING TOP and vice versa. 
CONTROL and SUPERVISION are achieved via a KEYPAD and a DISPLAY. 
The different IMAGES and DIGITS on the DISPLA Y provide information about the STATUS 
of the three APPLIANCES, RF ACTIVITY, and BATTERY of the REMOTE CONTROL. 
By pressing the different BUTTONS the user can interact with the REMOTE CONTROL. 
Each APPLIANCE has specific FUNCTIONS. 
The REMOTE CONTROL has two OPERATING MODES: MONITORING and EDITING 
(CONTROL). 
The BUTTONS are: 
 APPLIANCE BUTTON is used to MOVE between the different APPLIANCES and to 
SELECT one. 
 ANTICLOCKWISE (LEFf) BUTTON to move anticlockwise in the menus. 
 CLOCKWISE BUTTON (RIGHT) to move clockwise in the menus. 
 PLUS BUTTON to CHANGE or INCREASE the VALUE of the SELECTED ICON. 
 MINUS BUTTON to CHANGE or DECREASE the VALUE of the SELECTED ICON. 
 OK BUTrON to confirm your SELECTION. 
 ON/OFF BUTTON to switch the REMOTE CONTROL on and off. 
The DISPLAY is made of IMAGES and DIGITS. 
The IMAGES are: 
- 23-
'-______________________ ~A~p~p~e~n~di~x~l~S~t~Gn~d~G~r_d~U~M~L~D~e~s~c~ri~p~ti_o_n~o/~th~e~R_e_m~o_t~e~C~o_n_t~ro~1 
 OVEN image which can either be SELECTED or UNSELECTED. 
 HOB image which can either be SELECTED or UNSELECTED. 
 HOOD image which can either be SELECTED or UNSELECTED. 
 BATfERY INDICATOR image shows the battery level. 
 RF INDICATOR image shows the activity of the RF link. 
 APPLAINCE STATUS image shows the STATUS of the selected APPLIANCE. 
 One APPLIANCE OPERATION image shows the possible OVEN FUNCTIONS. 
 Another APPLIANCE OPERATION image shows the possible COOKING 
FUNCIOTNS and HOOD FUNCTIONS. 
 SPEEDffEMPERA TURE image shows whether the user is changing the speed or the 
temperature. It will be a boolean value. 
 LOCKED image shows if the APPLIANCE is locked or not. 
 DURATION/STOP TIME image shows if the TIME DIGIT is displaying the time to 
stop or the duration of the timer. 
The DIGITS are: 
 SPEEDITEMPERA TURE DIGIT 
 TIMEDIGIT 
Table 3 shows the candidate classes selected from the description illustrated above. Each class 
is associated with a short description and an integer which represent the quantity of instances of 
that class which might be used in a simulation of the remote control. 
Candidate Class Qa.anli1.E Dl,suie.Ii.e.1J 
REMOTE CONTROL 1 It is the Fagor remote control. 
COOKING TOP +1 
It is the unit in the kitchen that contains the 
appliances that are controlled but the remote 
control 
- 24-
Appendix 1 Standard UML Description 0/ the Remote Control 
TIMER I It is a timer. 
CLOCK I It is a clock. 
DISPLAY 1 It is the display of the remote control. 
IMAGE 10 It is an icon on the display. 
DIGIT 2 It is a seven segment display. 
mATTERY 1 It is an image displaying the battery level. 
APPLIANCE 1 It is an image showing the appliance that can be 
supervised or controlled. 
IAPPLIANCE OPERATION 1 It is an image showing the different operations 
which are possible on an appliance. 
ISPEEDffIME 1 It is an image which determines if the values 
shown are in degrees or it is the speed. 
LOCK 1 It is an image showing if the appliance is locked 
or not. 
IDURATION 1 It is an image showing if the time digits are 
displaying the duration or the end time. 
ICLOCK 1 It is an image showing the clock. 
ITIMER 1 It is an image showing the timer. 
ISffDIGIT 3 It is a seven-segment (three units) displays 
showing the speed or the temperature. 
TIME DIGIT 4 It is a seven-segment display (four units) 
showing the time. 
APPLIANCE 3 The appliances are the oven, the hob and the 
hood. 
OVEN 1 It is one of the appliances that belongs to the 
cooling top. 
HOB 1 It is one of the appliances that belongs to the 
cooking top. 
- 2S -
I SICIod< 
I Slamlr 
Appendix 1 Standard UML Description o[ tile Remote COlltro/ 
HOOD 1 It is of the appliances that belongs to the cooking 
Table 3 Candidate classes for remote control 
Figure 1-18 shows a conceptual class diagram of all the classes and their relationship. Some 
attributes and operations for these classes are also shown. 
 ttelttefaa1 
oir6tal1iate>t 0. .1 IJJ..1 ~ 
+~rTLds. ..  It'eIrterfacel 
+~ntJre. .. 
. Cocd4I'llTjl 
~ 94JIt(JAA*raI 
+ ~Iarao> head 
+~Iarao> JirTctet 
 UslaAAlIarces  
+~1T\.JJSI(lIrnar 
Sl8ypad 
+ ~ rn..JUstO[lgilS +~ nt.JlJstOaaxns 
+~() --\ 7 1 1 SWArJpIiInce -0sPa't + otxxJIeiIno stall 
+ oIxlaeaoo IsI..cxled .> 
SIdJit(JJmIgeS 
SIII.AtODgIts 
~ + ..,.,. dntion 
+ &mIge head 
+ t5l(lj1)o head 
+~head 
+~"IiTTctet 
+ ~"IiTTctet + <6ld:UIoo*liTTctet  
-~l \~ -~\ 
SldUton 
SxttIod 
&ftIb SlCIT8ge SIOIen 
I SlOgIt I +~ rTLUstO'Ialns + speed +Irto~ + lInlBalll'e + a.tIai'ressed ( ) 
- 1rraI;J  / ~ I SIChc:tIonIIUto I I 51 S I Ihatton ~ 
+ o5lckxno I'ead 
+ 4\SxkIlrl" fUTctet 
- I..IsIO'Ialni  
I Sdaln J 
Figure 1-18 Class diagram (conceptual) 
Figure 1-19 shows a tree structure of the different objects which can be used to describe the 
remote control. This diagram is used to show the hierarchical structure of the objects within the 
remote control. 
- 26 -
System 
Appendix J Standard UML Description 0/ the R""ole Control 
Remote Control 
Display 
Cooking Top 
1---- Ust of Image 
'--- Image 
t---- Battery 
t---- RF 
t---- Appliance 
t---- Appliance Status 
t--- Appliance Operation 
t--- Speed/Tlme 
t--- Lock 
1---- Duration 
t--- Clock 
"---- Timer 
1---- Ust of Digits 
L-- Digit 
'---- Ust of Buttons 
It---- SIT Digit 
TIme DIgit 
L-- Button 
Clock 
Timer 
Directional Button 
ButtonLeft: 
ButtonRight 
ButtonPius 
ButtonMlnus 
Selection Button 
L ButtonAppliance t= ButtonOk 
ButtonOn/Off 
L...- ust of Appliances 
L...- Appliance 
Temperature 
Status 
Speed 
Duration 
Flaure 1-19 Tree structure for e1asses 
1.10 States and activities 
This section illustrates some state and activity diagrams for the remote control. Details of these 
diagrams will not be given in this section since they will be widely discussed in Appendix 3. 
1.10.1 State diagrams 
Figure 1-20 shows a top level hierarchical state machine for the remote control. The state 
diagram is made only of two states, monitor and control. These are two main states for the 
remote control. When the remote control is switched on it can only be in one of these two 
states. When in the Monitor state the user is only allowed to view the parameters related to one 
- 27-
Appendix 1 Standard UML Description o[ the Remote Control 
of the appliances. If the user enters the control state then, parameters for the appliances can be 
set or modified. 
Monitor 
Press the Appliance 
Button 
Keep the Appliance 
Button pressed until 
blinking 
Figure 1-10 Top-level ,tate machine dlaaram 
Control 
Figure 1-21 shows part of a state machine which can be found inside the control state shown in 
Figure 1-20. This state diagram comprises of three states; Appliance Selection. Appliance 
Status and Appliance Operation. The fist state is entered when the user is changing the selected 
appliance. the second when changing the status (on/om. and the third one when setting the 
operation for that appliance. 
Change Appliance 
Appliance Selection 
Select Appliance 
Appliance Status 
Change or 
appliance 
operation 
Set status 
Figure 1-11 Generic lower-level ,tate diaaram (inside appliance state) 
- 28-
Appendix 1 Standard UML Description of the Re",ote Control 
Figure 1-22 shows another, more complex example. of a hierarchical state machine which 
applies for a remote control for home automation. 
In this example the house Is made of three rooms, a bedroom, a kitchen and a bathroom. 
The bedroom has a controlled light and curtains, the kitchen a controlled light and cooker and 
the toilet a a controlled light. 
Bedroom Bathroom 
Figure 1-22 Example of hierarchical state machine 
1.10.2 Activity diagram 
Figure 1-23 shows an activity diagram for the remote control. The activities are divided in 
relation to whom is carrying them out. In this diagram there are two actors. The actors are the 
remote control and the user. This is a high level activity diagram. The activity of the user is to 
press the buttons on the remote control while the activity of the remote control is to update the 
display. This diagram does not take into consideration the communication between the remote 
control and the cooker. That interaction would be an activity performed by the remote control. 
The cooker might also be used as an actor. whose activity is to give feedback to the remote 
control. A number of smaller activities are listed inside each one of the main activities. 
- 29-
Appendix 1 Standard UML Description 0/ the Relllote Control 
Remote Control User 
which Indudes': 
Update the lmIun Update the DIgits 
whlchhndUdes whiCh:lndudes .. .. 
ol lo 
PreIS a dlrectloNl button PreIS a HIKtIon button 
Update IBattery 
Update IRF 
Update IAppllance 
Update IAppllanceStatul Update SfTOigit 
Update IAppllanceOperatio/1 Update TlmeOIgit 
Update ISpeedfTlme 
Update ILock 
Update IDuration 
Update ICIock 
whlch:lndudes which: Indud  .. .i. 
PreIS ButtonLeft PreIS BultonOniOff 
PreIS ButtonRlght Pre  BultonOk 
PreIS BuItonPlul PreIS ButtonAppllallOl 
PreIS BultonMlnul 
Update ITImer 
Figure 1-23 Acdvlty diagram 
- 30-
Appendix 2 
SxUAfLSocketPackage 
Appendix 2 SxUMLSocket Package 
ApPENDIX 2 
SxUMLSoCKET PACKAGE 
his appendix provides further details on the SxUMLSocket package explored in 
Chapter 5 of this thesis. The SxUMLSocket package is a UML package implemented 
in Rational Rose RealTime
 Its purpose is to allow a functional model implemented 
in UML to communicate with its graphical counterpart during a ViPERS simulation. The 
communication mechanisms implemented in this package are based on standard TCP/LP 
sockets. 
This section explores implementation details of the package. A brief description of the classes, 
diagrams and protocols that make up this package are given. Attributes and operations of each 
class are also described. This appendix in conjunction to Chapter 5 gives a detailed description 
of the UML package. This should allow a designer to use the package in any design and 
customise it where needed. 
2.1 SxUMLSocket package 
2.1.1 Class Diagram 
Figure 2-1 shows the class diagram for the SxUMLSocket Package. The package is made of 
four classes and a capsule. 
5 Rational Rose RealTime, www.ibl11 .coI1l/ oftwarc/rati onall [accessed: 0111112004] 
- 32 -
Appendix 2 SxUMLSo ck e t Package 
Capsule 
Socket 
.s : $ld: : siting 
~epIy : std::string 
.m_sock : int 
~_addr : sockaddrjn 
~st : std: :shing - ''127.0.0.'" 
.const port : int - 3000' 
~_sock : Server 
~Iog : booI - true 
.provastting : std::string 
~gManaget : MsgManaget 
. st : SYSTEM TIME 
~mTine : Tine. 
~: SimpieString 
. lag : booI - rue 
~emoteOn : booI- false 
  / rernote_comm : Comms-
SockExcept 
Server ""'========1 ~m_s : std :string Client 
~ ~ ____ ------------j, .~~:OV:Mo~::int~J-----------____ ~J=======~ 
.  const operatOf () r-
.  const operatOf  () . SockExcept{] 
. accept(] . descripf ) 
. Server(] 
The classes are: 
 Sock Class 
 Server Class 
 Client Class 
 SockExcept Class 
And the capsule is: 
 Socket Capsule 
.hande_sock : SOCKET 
~_sock : int 
.m_addr : sockaddrjn 
. create{) 
. is_ vaIKJ:l 
. isten(] 
. accept(] 
.$e~1 
. connect(] 
. rec 
Figure 2-1 Class Diagram 
- 33 -
Appendix 2 SxUMLSocket Pllckllge 
The dotted arrow between the Socket capsule and the Server and Client class means dependency 
or instantiates. In this case it means that the Socket Capsule, which is the dynamic part of the 
package, will be in control of instantiating objects of these classes (Server and Client). The 
arrow between, both the Server class and the Client class, and the Sock class, is generalisation. 
This means that both classes are a generalisation of the Sock class, which represents the base 
class. Finally the SockExcept class is related with the Server and Client class by a 
unidirectional association. 
2.1.2 Sock Class 
The Sock class is the base class for both the Client and the Server class. All the attributes and 
the operations implemented in this class are inherited by the Client and Server classes. Figure 
2-2 shows the attributes and operations of the Sock Class. 
2.1.2.1 Operlltions (Sock Class) 
 Create. This operation creates a socket and sets some of its options. The handle to the 
socket, which is one of the attributes of this class, is set by this operation. It returns a 
bool which defines if the creation of the socket was successful or not. It takes no 
parameters. 
 is_valid. This method is used to check if an operation was successful or not. It returns 
a bool and takes no parameters. 
 bind. This method binds the handle of a socket with a socket address. It implements 
the bind method. It takes one parameter, an integer, which represents the port number 
and returns a b001. The bool represents the success of the bind operation. 
 listen. This method implements the listen function. It takes no parameters and returns a 
bool which defines the success of the operation. This operation is specific for the server 
objects and does not apply for the clients. Servers need to listen on a network for 
clients to connect. 
 accept. This method implements the accept method. Its parameter is a pointer to a Sock 
object which is wishing to be accepted. It returns a bool which defines if the Sock 
object has been accepted by the server. This method is specific for server objects. 
 connect. It implements the connect function. It takes two parameters; one is a string 
that represents the host name, and the other one is an integer which represents the port 
number. These parameters are the information about the server which clients need to be 
- 34-
Appendix 2 SxUMLSocket Package 
aware of, in order to connect. This method is specific for client objects. It returns a 
boo I which defines if the connection was successful. 
 send. It implements the send function. It takes one parameter, a string. The string is 
the message that needs to be sent. It returns a bool which defines if the message has 
been successfully sent. Both the client and server classes implement this function. 
 recv. It implements the receive function. A constant parameter needs to be set in the 
Sock class to define the size of the receiving buffer. When messages are received they 
are stored into a buffer. This method returns a boo I which defines the success of the 
function. 
2.1.2.2 Attributes (Sock Class) 
 handle_sock. A handle to the socket. Type SOCKET. 
 m_sock. A handle to the socket. Type int. 
 m addr. The address of the socket. Type sockaddrjn. 
r~ ~ S~dfication fOI Sock 
Res I c  I c .. T argetATS I 
General I Detai I Operations AltJWe$ I Relations I COIT(lOOents I D~ams I Nested I 
~ ~howme.ied 
I Ste<eoM>e I N_ I a- I Type I lriilll I 
# hande_sod< Sock SOCKET 
# m_wck Sock i1t 
# m_addt Sock $ockaddr_" 
',;< -- - --~ Class Specification fOI Sock Wf3 
flies I c- I c .. T argetRTS I 
Genelal I Detail Operations I Attributes I Relations I COIT(lOOents I D~arM 1 Nested I 
~ ~how inher~~ 
Irow:e "' 1 I Stereotype I Ret16n type I Name I Parametefl I OMI I  float create U Sock  boo IS_valid () Sock  boo bind (cons ont port) Sock  boo i;ten () Sock  boo accept (Sockt neyuocket) Sock  boo send (COIlSt std :wing s) Sock  boo cOlYleCl (cons std :wing host. con;t int port) Sock  boo recv ( std::sUng& I) Sock 
~row:e "' 1 I OK I Cancel I &>w' 1 
Figure 2-2 Sock Class (attributes and operations) 
- 35 -
Appelldix 2 SxUMLSocket Package 
2.1.3 Client Class 
The client class inherits all the methods from the Sock class. It has an extra three operations but 
no extra attributes in addition to the ones inherited from the base class. Attributes and 
operations are shown in Figure 2-3. 
2.1.3.1 Attributes (Client Class) 
 operator . It implements the send function. It takes one parameter, a string, which 
is the message to be sent. It returns a pointer to a client object, which is the one using 
this function. If the sending is not successful it throws an exception. 
 operator . It implements the receive function. It takes a string. It returns a pointer 
to a Client object, which is the one using this function. If the receive is not successful it 
throws an exception. 
 Client. This method implements the create and connect functions earlier described. 
The parameters are the string for the host name, and an integer for the port number. 
This information is associated to the server to which the client is trying to connect. 
~ Class Sp4ICifkation for Client Ltltf 
Nested I Fief I c .. I C..-lllfgetRl S I 
Genetal I Detail I Ope<abons .A.tbhae. I ReIaIioN I ~ I Diagam: I 
P" ~how me.~ed 
I Stefeot}lPeJ N/IfYIe I CIau I lype l iMa I 
~ . hrde_sock Sock SOCKE l 
ro . m..roc;k Sock nt 
ro . m_addr Sock sockaddr_n 
r~ - -
~ Class Sptelficatlon for Clltnt L?Jt3 
Nested I Files I C ... I C- TllfoetAl S I 
GenellII l Detai Dpealions I AttJb.tes I ReI4Iions I ~ I Diagam. I 
P" t.ow met~ 
I SteleotVPe I Ret .. n t}IPe I Name I PllfometeoS J~. I 
~ . float c,eale () Sock 
ro  booI rs_v~ () Sock. 
1'ow;e 1 ro  booI bind (comt in pori) Sock. 
~ . booI i$en () Sock 
1+ . booI acoept (Sock& new_socket) Sock 
1+ . booI , end (comt sid: sllng .) Sock 
1+ . booI connect (comt std::' II11'lQ host, cons in pori Sock 
It . booI ,et:v ( std: string. s I Sock 
 comt Ctertl. O(lefalOt < < (comt std:sllll'lQ" sl Client  comt Cient" O(lefalOt  (std:tlrir4 sl Client  VCId ClIent (std . sting host. in port] Client 
Drowse  1 I OK I C4nc:eI I ~P" 1 
Figure 2-3 Client Class (attributes and operations) 
- 36-
Appelldix 2 SxUMLSocket Package 
2.1.4 Server Class 
The server class inherits all the methods from the Sock class. It has an extra four operations but 
no extra attributes in addition to the ones inherited from the base class. Attributes and 
operations are shown in Figure 2-4. 
q. Class Specification for Server 
f1es I C.+ 
Genelal I Detai I Opeabons AttrhAes Relations 
c  T argetRTS 
COIJ'Cl()IleflIs I Diagatn$ I Nel led 
~ ~how iileIied 
itr~ ... 1 
twde_rook 
m_rook Sock ~ 
m_addr Sock sockaddrjn 
q. Class Specification for Serve. 
I c  
OpeaIions I AtbhAe; I Relations 
C .. T argetRTS 
Components I Diagarns Nel led 
is_v~ 
boo bnd 
boo isten 
boo accept 
boo send 
boo connect 
boo recv 
consl Server' operator  
 consl boo operator   boo acoept  VOId Server 
itrowse  1 
Parameters 
(cons III poll) 
(Sock' 'leW_socketJ Sock 
(con~1 std: :suing sJ Sock 
(const sld',string heW, consl int porlJ Sock 
( sld:slring&- ;J Sock 
(consl std:: slring & sJ Server 
(Sld': slring&- sJ Server 
(Sockt rookJ Server 
(ont porlJ Server 
OK Cancel 
Figure 2-4 Server Class (attributes and operations) 
2.1.4.1 Attributes (Client Class) 
 operator . It implements the send function. It takes one parameter, a string, which 
is the message to be sent. It returns a pointer to a Server object, which is the one using 
this function. If the sending is not successful it throws an exception. 
 operator . It implements the receive function. It takes a string and it returns a bool. 
If the receiving is not successful it throws an exception. 
- 37 -
Appelldix 2 SxUMLSockel Package 
 accept. It implements the accept function. It takes a pointer to a Sock object which 
wishes to connect to the server and returns a bool which defines the success of the 
operation. 
 Server. This method implements the create, bind and listen functions earlier described. 
The parameter is an integer for the port number. This information refers to the server to 
which the client is trying to connect. 
2.1.5 SockExcept Class 
The SockExcept class is a simple class. It is made up of two operations and two member 
variables. The first method takes a string and stores it into one of the member variables. The 
second method returns the string containing the error message. Operations and attributes are 
shown in Figure 2-5. 
~ Class Specification for SockExcept 
Diagams I Ne~ed I Aes C.+ I C .. T argetATS 
G enef aI I Detail I 0 pel atiom Attributes I R elations I Components 
P ~how inhef~ed 
~ Class Specifkation for SockExcept 
~rowse ... 1 Diagarns I Nested I Fies I C.. I c .. T argetRTS 
Genefal I Detail Opelatiom I Attributes I Relations I Components 
how~~ 
std :stJ ing deSC1iption SockE)(cept 
a rowse ... 1 OK Cancel 
Figure 2-5 SockExcept Class (attributes and operations) 
2.1.6 Communication Protocol 
The communication protocol is where the signals that will be exchanged between the capsules 
in a system are defined. This object has been placed into the SxUMLSocket package but can be 
modified depending on the application. Figure 2-6 shows which signals were set up for the 
communication in the case study of the remote control presented in Chapter 6 of this thesis. In 
that example each button of the remote control was associated with a signal. During a 
- 38-
Appendix 2 SxUMLSockel Package 
simulation if a user presses a button of the graphical remote control a message is sent to the 
socket capsule. The socket capsule translates the message and identifies the button being 
pressed by the field of the tagged message. The socket will send a signal which corresponds to 
the button being pressed to the state machine of the functional model of the remote control. The 
communication protocol needs therefore to be set by the user depending on the system being 
implemented. A suggestion is to associate a signal in the communication protocol with each 
input and output mechanism of the device being prototyped. The signals which are sent from 
the socket capsule are defined into the "In Signals" section while the one that are received are 
defmed into the "Out Signals" section. There are three signals which do not need to be 
modified. The first two are in the " In Signals" section and they are Msg_snt and MsgJcvd. 
~ Protocol Specification for (omms 0ii 
Diagrams I Res I C++ T argetATS I 
Genefal S~$ I Relaliom I Components I 
~ Show jnheIited ~ Showjoca/ r Show ~xcluded 
In5iaW I Data Class I 
MSLlevd void 
MSLsnl void 
on void 
appiarlce void 
light void 
left void 
pk.r$ void 
IIWlU$ void 
ok void 
ionL appliance void 
Oli SiaW I Data Class I 
M$Lsnd 5 impIeS tl irog 
stalttime, Time4 
iIowse 1 I OK I ClCeI I ~np': I 
Figure 2-6 Specification for communication protocol 
These messages are used by the functional state machine of the proto typed device to 
communicate to the socket capsule when messages have been sent or received. The remaining 
signal is in the "Out Signals" section and it is Msg_ Send. This message is sent by the functional 
- 39 -
Appendix 2 SxUM LSockel Package 
state machine of the capsule and carries a string which infonns the socket capsule which 
message has to be sent back to the graphical model. 
2.1.7 Socket Capsule 
A capsule is a stereotyped class. In the SxUMLSocket package the socket capsules is used to 
add behaviour. A capsule is like a thread and this allows the socket to be executed on a separate 
thread from the one containing the functional state machine of the virtual device. The attributes 
of this capsule are shown in Figure 2-7. Most of these attributes are parameters which the user 
can change depending on the application. For example the user will be able to change the port 
number and the host address of the socket capsule. 
The capsule has a state diagram and a structure diagram which are discussed III the next 
sections. 
~ Capsule Specification for Socket LilJa' 
ConnedOl$ I Rel4tiom I COfl1)Orlerts I D~<Wll$ I Files I C++ I Geneta' J Opeabons AttrWes I C~psUe Ro\e:s 1 POlis 
P' ~how i'Vwted 
I Stereotype I Name I Clan I Type I Initial I 
# $ Socket $td::string 
# reply Socket std:: string 
# m_sock Socket int 
# m_addr Socket sockaddljn 
# host Socket ~d: string '127.QO.'" 
# const port Socket int 30001 
# new_sock Socket Server 
~ flag Socket bool true 
# plOvllstling Socket ~d: : string 
# m:sgM anager Sock.et M~lloager 
# tt Socket SYS TE MTI ME 
# clIIarm T ine Socket Time4 
~ ""'ag Socket booI hue 
~ remoteOn Socket bOO false 
erowse .. I I. OK I Cancef I we] I 
Figure 2-7 Socket Capsule (attributes) 
2.1.7.1 State Diagram 
The state diagram of the capsule is what adds behaviour to it. The state diagram for the 
SxUMLSocket Package is shown in Figure 2-8. This state diagram is made of only one state 
and two transitions. One transition is the initial one, which is only executed when the capsule is 
- 40 -
Appe"dix 2 SxUMLSocket Package 
instantiated. After initialisation, the socket capsule will be between the socket_waiting state and 
the send_msg transition. When in the socket_waiting state, the server waits for incoming 
messages from the graphical model. When the state machine goes through the send _msg 
transition, it sends a message to the graphical model. This message is the output of the 
functional state machine. More details on the functioning of the socket capsule and on its state 
machine are glven in the thesis in the Chapter 5. 
Sockel.,.waMo 
Figure 2-8 Socket Capsule (state diagram) 
2.1.7.2 Structure Diagram 
Figure 2-9 shows the structure diagram for the socket capsule. The capsule has one port which 
is a conjugate, wired end-port. This port is the means by which this capsule communicates with 
the functional capsule during simulations . 
 , .emot,_COtI"m 
Figure 2-9 Socket Capsule (structure diagram) 
- 41 -
Appendix 3 
Remote Control in 
Rational Rose RealTime 
A.ppendlx 3 Remote Control In Rlltlonlll Rose RealTime 
ApPENDIX 3 
REMOTE CONTROL IN 
RATIONAL ROSE REALTIME 
he first part of this appendix describes the design of the remote control, in UML using 
the realtime profile. The design was implemented using Rational Rose RealTime. 
The remote control is the one which was discussed in Appendix I and in Chapter 6 of 
this thesis. The second part of this appendix illustrates a virtual prototyping simulation which 
includes the graphical model of the remote control interacting with its UML counterpart 
described in this appendix. Screenshots of both the graphical model and the state machine of 
the functional model will be provided in order to further investigate the functionality of the 
remote control. The state diagram of the remote control was implemented hierarchically. This 
appendix illustrates the structure of the state diagram. Another contribution to this appendix is 
the description of some features offered by Rational Rose RealTime to aid designers. One of 
the features which will be illustrated is the processor specification. This feature allows 
designers to choose the target processor from a list of available ones. The aim of this feature is 
to automatically generate code for specific processors. Further considerations about the 
automatic generation of code are illustrated in Appendix S. 
This appendix should be read in combination with Appendix 1, where the design of the remote 
control is discussed in details. The design of the UML model presented here is based on the 
considerations made in Appendix 1. 
3.1 The state diagram 
This section explores the design of the state diagram for the remote control. The state diagram 
explored in this section describes the behaviour of the remote control which combined with the 
-43 -
Appendix 3 Remote Control in Rational Rose RealTime 
socket capsule is a UML Executable Functional Model as discussed in Chapter 5. The state 
machine is implemented hierarchically. This section starts from the top level state diagram. 
Remote Control Top State 
Figure 3-1 Remote control top state diagram 
Figure 3-1 shows the top level state diagram for the functional description of the remote control. 
This state diagram is made up of two states, Switched_off and Switched_on . The Switched_off 
state is attached to the initial transition. This transition is the first transition of the state machine 
and it is performed every time the capsule is instantiated. As it is suggested by their names the 
two states are entered when the remote control is switched off or on. The Switched_on state is 
implemented hierarchically while Switched_off is primitive and does not contain any internal 
states. The two transitions, on and off, between the two states are determined by the power 
button. When the user presses the power button the remote control goes from the Switched_Oil 
to the Switched_oJstate. 
When the remote control is switched on it enters the Switched_on state, and also the Monitor 
state as show in Figure 3-2. The Monitor state is implemented inside the Switched_on state 
(hierarchical state). The internal structure of the hierarchical Switched_on state is shown in 
Figure 3-2. Again, this state diagram is made up of two states, the Monitor and the Edit states. 
The Monitor state is a primitive state, and it is entered when the user is using the remote control 
to monitor the different appliances for the cooking stack. 
- 44-
Appendix 3 Remote COlltrol ill Ratiollal Rose RealTime 
others 
Monitor appliance 
off ok appliance_long 
Edit j 
-------" 
Figure 3-2 Inside the Switched_oil state diagram 
The Edit state instead is a hierarchical state and it is entered whenever the user wants to edit 
some parameter of an appliance of the cooking stack (control the appliances). If the remote 
control is in the Monitor state, the user will need to press the appliance button for an amount of 
time set by the designer in order to enter the Edit state. If the button is not pre ed for long 
enough then the remote control will stay in the Monitor state and move to the next appliance in 
the list. To exit the Edit state the user can press the ok button. This operation triggers the tate 
machine to store the information about that appliance and go back to the MOllitor state. At any 
time inside the Switched_on state the user can press the power button (off) and the process will 
exit whichever state it is in and move back to the Switched_ojJstate. 
- 45 -
Appelldix 3 Remote COlltrol i/l Ratiollal Rose R ealTilll e 
appliance_long 
false 
t;/~se true 
HOb_ j HOOdJ 
Figure 3-3 Inside the Edit state diagram 
The internal state diagram for the Edit state is made up of three states. Figure 3-3 hows the 
internal state diagram for the Edit state. Each of the three states speci fi es one of the appliances 
belonging to the cooking stack. The three states are Oven, Hob, and Hood. They are 
implemented hierarchically and present a very similar internal structure as shown in Figure 3-4, 
Figure 3-5, and Figure 3-6. For this reason this section will only explore the internal structure 
of one of them (Oven state). 
- 46 -
Appelldix 3 Remote COlltrol III Ratlollal Rose RealTime 
right/lett others 
oven_status p 
~ false 
right left 
~ n n 
oven_action 
Uothers 
n nmlnus 
oven_value 
off others ok 
right/lett 
oven_lock 
others 
right/left 
oven_duration 
others 
n nmlnus 
off duration_stop I ok 
others 
Figure 3-4 Inside the Ovell state diagram 
The internal hierarchy of the Oven state is made of six states; these states are: 
 oven_status state. This state is entered when the user enters the Edit state for the oven. 
In this state the user is able to set the oven on and off. The current state (on or off) of 
the oven is provided by the cooker on request of the remote control. Once the remote 
control is in this state the user can press the right or left button to move between the on 
and off icons of the status section of the display of the remote control. Other buttons 
- 47 -
Appendix 3 Remote Control In Rational Rose RealTime 
except for the ok and power button will have no effect on this state. When the user 
presses ok the remote control exits this state. If the remote control status is set to off 
then it goes back to the Monitor state, otherwise it moves inside this state diagrams and 
enters the oven_action state. 
 oven_action state. When the remote control exits the oven_status state the state 
machine enters the oven_action state. In this state the user will be able to set what type 
of action the oven should perform. The user can press the right and left button to scroll 
between the different styles of cooking available for that appliance. Other buttons, 
except for the power, the appliance, and the ok button, will have no affect on this state. 
Once the user has decided on an action for the oven and pressed ok, the state machine 
will exit the oven_action state and enter the oven_value state. 
 oven_value state. In the oven_ value state the user can set a value (temperature or 
speed) for the specific action that has been set in the previous state. In the case of the 
oven, the value is the temperature. This will be different for example in the hood_value 
state where this value will represent the speed of the hood fan. The user can press the 
plus and minus buttons in order to increase or decrease the temperature of the oven. 
Once the user has set the temperature by pressing the ok button the state machine will 
move from this state to the oven_lock state. 
 oven_lock state. Once the state machine has entered the oven_lock state the user can set 
a lock on the oven. The lock means that the parameters for this appliance cannot be 
changed until the lock is disabled. The user can press the right and left buttons in order 
to move between the looking and unlocking options for the oven. When the user 
presses ok, the state machine moves from the current ovenJock state to the 
oven_duration state. 
 oven_duration state. Once in the oven_duration state the user can set an alarm for the 
oven. In this state the user can set which kind of alarm to set. 
- 48-
Appelldix 3 Remote COlltrol ill Ratiollal Ro se RealTllll e 
right/left others 
hob_status 
~ false 
right left 
hob_action 
Uothers 
n nmlnus 
hob_value 1 
others 
right/left 
hob_lock 
others 
right/left 
hob_dutarlon 
others 
n nmlnus 
off duration_stop ) ok 
others 
Figure 3-5 Inside the Hob state diagram 
Two types of alarm are provided in this remote control. One alarm, duration, is set by 
defining an integer which refers to the duration of the cooking independently of the current 
time. The second type, stop, is set by defining the exact time when the alarm needs to be 
triggered. The user can use the right and left button to scroll between the two different 
options. 
- 49 -
Appendix 3 Remote Control III Ratiollal Rose RealTime 
right/left others 
hood_status tJ 
false 
right left 
~ n n 
hood_action 
LJQtL 
j plus n nmlnus 
hood_value 
j- U off others ok 
right/left 
hood_lock 
others 
right/left 
hood_dutarlon 
others 
n nmlnus 
off duration_stop I ok 
others 
Figure 3-6 Inside the Hood state diagram 
Once the user has set the alarm type, the ok button can be pressed to move from the 
oven_duration state to the duration_stop state. 
 duration_stop state. In the duration_stop state the user sets the time or duration of the 
alarm. The plus and minus buttons are used to increase and decrease the time or the 
duration of the alarm. Once the user presses the ok button the state machine will exit 
the Edit state and go back to the Monitor state. 
- 50 -
A.ppendlx 3 Remote Control In Rlltlon," Rou RuITI"u 
The tree structure below shows the hierarchy of the state machine for the remote control: 
 Switched_off 
 Switched_on 
0 Monitor 
0 Edit 
 Oven 
 oven_status 
 oven_action 
 oven_value 
 ovenJock 
 oven_duration 
 duration_stop 
 Hob 
 hob _status 
 hob _action 
 hob value 
 hob Jock 
 hob _duration 
 duration _stop 
 Hood 
 hood_status 
 hood _action 
 hood _value 
 hood Jock 
 hood _duration 
 duration_stop 
- 51 -
Appendix 3 Remote COlltrol ill Ratiollal ROH R ealTime 
3.2 Structure 
Figure 3-7 shows the structure diagram for the remote control capsule. As for the socket 
capsule the remote control only has one communicating port. This is a wired end port. 
Figure 3-7 Structure diagram for the remote control 
3.3 Classes 
This section explores some (the most significant) classes of the RemoteControl capsule by 
providing some details about their attributes and operations. 
3.3.1 RemoteControl Capsule 
The RemoteControl capsule is a class stereotype and it is the most important class of the 
functional model. The state diagram described above is contained within this capsule. 
~ Capsule Specification fo r R_l.Control WEt 
C~. I Diagams I ne. I Coo I G_.I Opelations I AttriUes I Caps'" Role. I POIts I ConnectOlS I RoLoIicns 
~ S.how me.i ecj 
I Stefeo\Yl)e I Re(lAn Iype] Name I PaI_efl J Cbsl I 
std. sting WlleM sg (i-oI~No) RemoieCOI'llloi 
nt ObtMl7Segl Int no) RemoteCOI'llloi 
nt Obta,,7Seg2 I""no) RemoteCOI'llloi 
nt Obtaon7Seg3 Int no) RemoieCOI'llloi 
... nt ~enele7Seg (i-oI . egl . nt seg2. "" . eg3) RemoieCOI'llloi 
r-;:: -- -
C\ Capsule Speciflcalion fOI RemoleConlrol l.?Jt31 
COIf4)OnenIs I Diagams I Fie. I Coo I illowse  1 G_aI I Opelalions AtbWel I CapsUe Roles I POlis I CoMeetOlI I ReIat,olll 
~how me.ied 
1 Stef~ I Name J Oats I Type l initial I 
~ .oIect~ RemoieCOI'llloi int 1 
# oven RemoieCOI'llloi Appioance 
# hob RemoieCOI'llloi Appioance 
 hood RemoieCOI'llloi Appiance 
~ msg/.lanaoer RemoieCOI'llloi M, gManageo 
 lemoIeSlling RemoieCOI'llloi SinpleStlng 
~ tomeFollnal RemoieCOI'llloi Time. 
ill""".  1 1 OK I C4ncel I topiy 1 
Figure 3-8 RemoteControl capsule (operations and attributes) 
- 52 -
Appendix 3 Remote Control In Rtltlontll Rose RealTime 
Figure 3-8 shows the attributes and operations of this capsule. Among the various attributes, it 
will be mentioned the selectedAppliance attribute. This attribute is used by the remote control 
to keep track of which appliance is selected on the remote control at all times. Other attributes 
include the three appliances, the oven, the hob and the hood. 
3.3.2 Appliance Class 
Figure 3-9 shows the attributes and operations of the Appliance class. The attributes of the 
Appliance class are: 
 id. This attribute is an integer representing the id number of the appliance. In the 
specific case of the remote control, the id of the oven is one, the hob two, and the hood 
three. 
 state. This attribute is an integer relating to the state of the appliance. The possible 
states are on (1) and off (0). 
 minTemp. This attribute is an integer that determines the minimum temperature for a 
defined type of cooking style. When a user selects a type of cooking on the remote 
control, the value of the temperature automatically sets itself to the minimum 
temperature. This applies only when the appliance has just been switched on; otherwise 
the temperature previously set by the user will be displayed. 
 maxTemp. This attribute is an integer that determines the maximum temperature for a 
defined type of cooking style. This allows the remote control to stop on that maximum 
temperature when the user is trying to set a temperature which is above that value. 
 temp. This attribute is an integer used to store the temperature set by the user for that 
appliance. 
 action. This attribute is an integer. Each different style of cooking for a specific 
appliance is related to an identity number. 
 noOfAction. This attribute is an integer which determines the number of cooking 
styles available for that specific appliance. 
- S3 -
Appendix 3 Remote Control in Rational Ros e R ealTim e 
 lock. This attribute relates to the status of the lock. If the appliance is looked then this 
attribute is one, otherwise it is zero. 
 duration. This attribute is an integer which determines which type of alarm has been 
selected by the user. This could be the duration of the cooking or the time at which it is 
supposed to stop. 
 durationValue. This attribute is an integer which determines the duration for the alarm 
that has been set by the user. 
 time. This attribute is of class Time4 and it is used to store the current time which 
should be displayed by the remote control. 
r~ Cl4ss SfMKification for Appliance W~ 
Diagams I Nested I Fkt I c- I c- T4IgetRTS I Genelal I Det~ Operalicm I Atllwes I R~iom I Compclf'lMts 
~ ~ 'ilhet~e<j 
J Stereot~ J Relun type J Name I Parametett I OatS I 
~ void seUD (~ identity) App~nce 
 void checkS tale (J Appliance 
~ ClMS Specification fo r Appliance llJ&f 
Diagams I Nesl.ed I F'ies I CH I C .. T 4IgetRTS I General I Det~ I Opelalions Altrb..te$ I Aef.o6ons 1 COl,.~()uer.$ 
W ~how riletled 
I StmeotYOe I Name I Class I Type I inlial I 
# id Appliance int 1 
# slate Appli~ int 0 
~rowse 1 # 
minTemp Appliance int SO 
# rnaxTeJl'lp Appliance int 200 
# temp Appliance int SO 
# action Appliance int 1 
# noOlAction Appliance int 0 
# lock Appliance "'1 1 
# ciJr~ion Appliance "'1 1 
# dur alionValue Appliance "'t 
# tine Appliance T ime4 
jlrowi$& .1 I OK I C4nc~ 1 cor;/y I 
Figure 3-9 Appliance class (operations and attributes) 
- 54 -
Appendix 3 R emote Control in Rational Ro se R ealTim e 
3.3.3 MsgManager Class 
Figure 3-10 shows the attributes and operations of the MsgManager class. The MsgManager 
class is in charge of managing all the messages that are received or sent from/to the display of 
the remote control. The MsgManager is based on the message exchange mechanism explored in 
this thesis in chapter 4. All the attributes are constant parameters which contain the strings 
which have to be concatenated in order to be sent to the display. The operations of this class are 
mainly concerned with concatenating messages in order to be sent and understood by the 
graphical model in VDM. 
0 __ 10.0 
.. ~ R.-.n N P.ttNtef  10 ... 
S ... ~ N4t'I'It 0. .. T ,-
""., ,,"1111$.;2 M'OManao- ud tllong '(SlMtO)'~I (ISIMIO)( <<;to'I) r~ReotnCIf. O"~ SfNIIIlS~ ... ~e OI~~ 
~ """ 
"'"' ""'" M'oM~ .. d ttlrog "(S I"'ID)ttflIQl.l (ISIMIO)(tct.or\) fto;JOlR-ote~SPHd Vlltlo.le ~~" ~ ~ MsoM<W*JeI ffif dr.-.g "(SlMtO)~.l (ISIMIO)C~rtQOlR~~1S~--'''Ot~ .. 
nfOllfte ... 1 CEJ c..,,, 1-1 
Figure 3-10 MsgManager class (operations and attributes) 
- 55 -
Appendix 3 Remote COlltro/ ill Ratiolla/ Rose RealTime 
3.3.4 Time4 Class 
Figure 3-11 shows the attributes and operations of the Time4 class. The Time4 class is in charge 
of dealing with the time in the remote control model. This involves displaying the time and also 
managing the alarm in the remote control. The only operation in this class is checkAlarm . This 
method allows the remote control to know when to trigger the alarm. The evaluation is based 
on the current time. Four of the attributes (primo, secondo, terzo, and quarto) represent the four 
digits that make up the time. i.e. two digits for the minutes and two for the hours, 
~ Class Specification for Time4 
Component$ I D~<YI'ls 
Genesal I Detai 
Nested I Files I C .. 
Oper~tions 1 Altribut~ 
~ ~h?w imefi~ 
checkAliarm 
q Class Specification for Time4 
~oneri,$ 1 Diagrams Nested I 
C.+ T ~getRT S 
I Rela600s 
files I C ... 
Gener61 I Det~ OpeJations Altrbut~ 
W ~how mesited 
# p1imo 
~row~ # secondo 
# elzo Tirne4 inl 
QUarto Tirne4 in 
dur_end Tirne4 in 
C++ T algetRTS 
Relbliom 
.arowse  1 OK Cancel tv 
Figure 3-11 Time4 class (operations and attributes) 
- 56-
Appelldix 3 Remote COlltrol ill Ratiollal Rose RealTime 
3.3.5 MainSystem Capsule 
The MainSystem Capsule is a capsule combines the remote control capsule with the socket 
capsule. This section illustrates its structure, a sequence diagram and the proces or 
specification. 
3.3.5.1 Structure diagram 
Figure 3-12 shows the structure diagram for the MainSystem capsule. This capsule is made of 
two internal components which communicate through an interface at simulation time. The two 
capsules that are found within the MainSystem are the remoteContTol and the socket cap ules. 
I remoteCorl.lol I $OCke( 
: RemoteCorl.lol  I \U:ef COfM\ + I remote_comm : Socke( 
: cOOms : COIT'ITlS-
Figure 3-12 Main system Structure diagram 
- 57 -
A pp e lldix 3 R emote COlltrol ill Ratiollal Ro se Re al Ti m e 
3.3.5.2 Sequellce diagram 
Figure 3-13 shows a typical sequence diagram where the remoteControl capsule and the socket 
capsule communicate with each other through their communication protocol. The exchange of 
signals between the two capsules is very simple. The socket sends the message received form 
the graphical model to the remote control capsule. The remote control capsule processes the 
message and then sends a message back to the socket which will instruct the graphical model on 
how to update the display. The socket capsule sends a message back to the remote control 
socket to acknowledge the updating of the display. 
l sockm ; ~~~ l remoteComd 
 R fmOt~ontrd 
 , , 
1: forced ,  , , , 
1.1: M sq Icvd  ,  
   1 .U : M~md  -" 
1-;:- . 
1.1 .1.1: M~ sot  ,  
:- L,.J 
       "                   ,  ,.  ,.    I  ,   
Figure 3-13 Main system sequence diagram 
3.3.6 Processor specification 
Figure 3-1 4 shows the processor specification that was set for the MainSystem capsule. This 
capability offered by Rational Rose RealTime allows the automatic generation of code for a 
target processor. 
- 58 -
App endix 3 R emote COlltrol ill Ratiollal Ro se R ealTim e 
q. Processor Specification fo r loca lhOST Wit1 
General Detail I Fie.s I I 
,cpu: II86 
.:J I 
QS: l\lfiiiowt-N T .:J I 
Agdress: 1127.110.1 I I 
~ervet: 1 
Load s~ 1 $TARGET _SCRIPTS\win32 I 
B ro~$e ... I I 
'" Instances I I 
I III remo(eComponerll nstance I 
ilrowse ., 1 I OK I C<VICe I 8PPy ,I 
Figure 3-14 Processor specification 
Figure 3-15 shows a set of different options offered by Rational Rose RealTime for different 
CPUs and different Operating Systems. 
~ Processor Spffkation for locathOST ? 
G_aI DeI:'.I Files I 
~ /~.~------------------, 
I ~M~m~--------------~; 
QS: I two 
~./~ m68k 
S~ :$ 
load~ 11\3 
G..,..aI Deiail ~I I 
QS I \tI1\doWifln , 
~olll ~PUX1 0 " 
l OSE 
~ .. v.. r~s I 
load I~'" VA rx I 
VxYJOIk l I 
\ ~~ I 
C ns onco. 
Figure 3-15 CPU and OS options 
- 59 -
Appelldix 3 Remote COlltrol ill Ratiollal Rose RealTillle 
3.4 Simulation 
This section will explore the simulation of the system explored in this appendix , in conjunction 
with the graphical model of the remote control. Screenshots of both the state machine and the 
graphical model of the remote control during the simulations are shown. 
Figure 3-16 shows the remote control off. The state machine for the remote control is in the 
Switched_off state and the socket capsule is in the Socket_waiting state, waiting for messages 
from the graphical model. The graphical remote control is switched off and therefore no icon is 
highlighted on the display. 
~ r-----=-_= ...:.2 r,. , ... .,.. il t't., . II ', ~ 
n o q, 
:B .  , jo q, 
~~--l c 
 ~ "--. .. . 'oO 
Figure 3-16 Remote control switched off 
Figure 3-17 shows the remote control being switched on and going into the Switched_on state. 
The Switched_on state is a hierarchical state. As shown in Figure 3-17, the state machine inside 
the Switched_on state is into the Monitor state. The oven icon is switched on in the graphical 
model of the remote control, and the status icon is highlighting (off). This means that the user is 
- 60 -
A ppelldix 3 Remote COlltrol ill Ratiollal Ros e R ealTim e 
monitoring the oven which is currently switched off. The display is also showing the current 
time . 
~ " . 
-]I - . ... . . , 
r:: '" "" 'J.~ 1'( '- ... :: .. c t 'I '" 
"Ir=======~~~----------------~ 
. . ... 
., --... - ~- - .. .. ,.-
Figure 3-17 Remote control switched on 
Figure 3-18 shows the transition of the state machine from the Monitor state to the Edit state. 
Once this transition takes place the status icon will start blinking to prompt the user to et the 
status (on or off) for that appliance. 
 ~ l _ 
. ... -
~---- ~ 
Figure 3-18 Remote control in the Edit state 
- 61 -
A pp e lldix 3 Remote COlltrol ill Ratiollal Ro se R e alTilll e 
Figure 3-19 shows the state machine in the Oven state. The state diagram shown in this picture 
is an internal state machine of the Edit state. Once the user enters the Edit state the state 
machine can only go into one of the three states shown in Figure 3-19. The three pos ible tates 
are Oven , Hob, and Hood. 
. . --- -
C"--, 
Figure 3-19 Remote control in oven state 
Figure 3-20 shows the internal state machine of the Oven state. lnside this oven state machine 
the current state will be status. This means that the user is setting the status (on or o ff) of that 
appl iance. If the user sets the status to off the remote control will exit the Edit state and go back 
to the Monitor state. If the user switches the oven on then it will be possible to set the di fferent 
styles of cooking for the oven. The graphical model shows the status icon blinking. 
..   
. . , 
- ",,,, ,.. ,,,, ... ,. "' "' '' 
-5 .. 
1"-___ 1-
r"  -_ .. 
Figure 3-20 Remote control in oven_status state 
- 62 -
Appelldix 3 Remote COlltrol ill Ratio"al Ros e R e alTim e 
Figure 3-21 shows the state machine in the hob _lock state. This means that the user has set the 
hob on, set a style of cooking, set a temperature and is now setting the lock. The icon of the 
lock on the display of the remote control will blink to show to the user which function is 
selected. 
(0"   
tatofol ___ I~~~-
D~-.- .. I L .. ~ 
Figure 3-21 Remote control in hob_lock state 
Figure 3-22 shows the state machine in the hood value state. The behaviour of the Oven, Hob 
and Hood state machines is very similar. Therefore as described in the previous example, in 
order for the state machine to be in this state it means that the user has previously set the tatus 
and the action of the hood. The icon for the value of the hood will be blinking to prompt the 
user with the selected function of the hood . 
- 63 -
A pp elldix 3 Relllote COl/lrol iI/ Buliol/u/ RO j 'e R eulTilll e 
o ~  
Q.-. 1>" .. _ _ 
;I:JI -'"---
I~ __ . 
Figure 3-22 Remote control in the hood_value state 
Figure 3-23 shows the state machine in the duration_stop state of the oven . 
D " g  
. . -.. ->1'\ ._--
et~-
' .. '-
- 1-..1 _0._------1 
;I:JI"'-"--
Figure 3-23 Remote control in duration_stop state 
Figure 3-24 shows a trace window with the strings exchanged between the graphical and 
functional models. This window can be used to follow the simulation and study its result. 
Designers can check if the messages exchanged between the two models are correct. 
- 64 -
Appel/dix 3 Remote COl/trol ill Ratiollal Rose R e alTime 
... --, a - . 
.'-:' 
.,. t . , Q" 
080'<:3 
"" ~' ."''' '- '' '''''' I ~_ ''''''. ' 
Figure 3-24 Remote control trace window 
Figure 3-25 shows the exchange of signals between the remote control and the socket cap ule . 
This window can be used to control the functioning of the communication framework between 
the two capsules. 
o ,. g   .,. 0 c ra A :1 ..- W 11 ~ til.. 'J ., 
-----  L_ 
=--".,.-,1_ . ,-.-. ,~ --
:= w..-
QJ,el 1> .ojHl  .bL.'- . , ... . '''''': ,.",... 
.. ..  .. ..  , . ..  .. ..   ...  -...  ... ...  
Figure 3-25 
- 65 -
I".. T 
Signals 
Appendix 4 
Remote Control in 
Co Centric 
Appendix 4 Remote Control III CoCelltrlc 
ApPENDIX 4 
REMOTE CONTROL IN COCENTRIC 
his section describes the SystemC model implemented for the functional model of the 
remote control. This model was implemented and simulated using CoCentric System 
Studi06 The remote control is the same as the one which was discussed in Appendix 
I and in Chapter 6 of this thesis. The SystemC model was implemented hierarchically taking 
advantage of the graphical user interface offered by CoCentric System Studio. CoCentric allow 
designers to graphically implement a system while automatically generating the corresponding 
SystemC code. This approach enables designers to easily define an architecture for the system 
by dividing it into subsystems. 
This appendix describes the hierarchy of the system with some details on the main blocks that 
make up the system. Screenshots of the schematics of the SystemC blocks from CoCentric are 
provided to aid the illustration of the hierarchy of the system. Screenshots of the symbols of the 
blocks are also provided, to illustrate the interfaces of some of the blocks. These diagrams 
show the input and output signals of each discussed block. 
This appendix should be read in combination with Appendix I, where the design of the remote 
control is discussed in details. The design of the SystemC model presented here is based on the 
considerations made in Appendix 1. 
Considerations on the overheads generated by CoCentric System Studio are explored in the 
Appendix 5. 
6 CoCentric System Studio Reference Manual, Synopsys, v2002.05-SPl, December 2002 
- 67-
Appendix 4 Remote Control ill CoCelltric 
4.1 Hierarchy of the remote control model 
The SystemC model of the remote control was implemented hierarchically. Figure 4-1 shows 
the hierarchy of the model. At the top level there is the FA GOR _Entire_System model. Inside 
this hierarchical block there are all the other blocks that make up the functional model of the 
remote control. The entire system is made up of eight hierarchical models and twenty-four 
primitive models. Only the major blocks will be described in this appendix. 
FAGOR_ut.e_S~em 
W Cooker 
DispiaySirk 
FAGOR_BeMviou'aI_ModeI 
W ActionJlllI'lklnQ_Devlce 
App/wlce8utton Tmer 
~nce6utonDeclsoo 
8 W dockhelp 
c1od<helper 
S Control_States 
Control_Action 
Control_Appliance 
U Control_lock 
Control_Status 
Control_StopEnd 
Control_Value 
Control_ VaiueStopEnd 
Cooker _COIIVnS_ControUe,' 
Display _Controller 
lock_~~_Devke 
W Main_StateJ~tlChine 
Proortlm_Store 
Q Status_BIO:inQ_Device 
StopE.nd_BlinkhQ_Devlce 
VtllueSE_BlinI<ln9_Device 
ValueTS_~_Device 
Keypad 
8 Source 
Q remote_adapter 
W remote_socket 
Figure 4-1 Hierarchical view of remote control models 
4.2 FAGOR_Entire_System 
The top level block of the model of the remote control is the FAGOR_Enlire_Syslem block. 
This block is made up of four hierarchical models as shown in the schematic in Figure 4-2 and 
in the diagram in Figure 4-3. 
- 68 -
A pp endix 4 R emote COlltr o l ill COCC lltriC 
1"' ... ...,T, .. 3 -' ~ 
. , (U'U"'1It 
I : " =:~ -
il ,~._. - f-< 
r -S)I_' ~ '--r-< '- =: ~ '-t 
~ --- ~ ~ .- '----' 
W--J ..I.LJ ..I 
l5IIM.'~ 
 twOI'IJ n Oft t. 1 nry - ' ya.llu r ucl:ucal ' \.~') d ~ 1 tb.M?u rrL"- i t. tf 
~na. .. w, ' sy._o.~ . ~t..J "lth 1 cb~," ~h L ... It _upd,.l. 
j  ... ~ 104n~ J...2B~~iiOrt KCOJeGifOlWiiift J luLJ 
II -"iOU. lIM ' 'f ' 
Figure 4-2 FAGOR_Entire_System schematic 
The internal blocks of FA GOR_Entire_System are : 
2. Cooker 
3. Keypad 
4. DisplaySink 
One of the blocks within this hierarchical block is the Cooker model. The Cooker block does 
not belong to the remote control but it is only used for simulation purposes. 
The FAGOR_Entire_System model does not have any input or output ports since it is the top 
level block and the mechanism to communicate (inputs/outputs) with the external graphical 
model are implemented as TCPIIP sockets. 
- 69 -
Appendix 4 Remote COlllrol III CoCelltrlc 
Figure 4-3 FAGOR_Entire_System hierarchical view 
4.2.1 FA GOR_BehaviouraCMode/ 
The FAGOR_Behavioural_Model is the most important block of the remote control. All the 
functionality of the remote control is implemented within this model. In the refinement process 
suggested in the SystemC methodology and explored in Chapter 2 of this thesis, thi is the block 
which will be refined to RTL. Figure 4-4 is a screenshot taken from oCentric nnd di play the 
symbol of this block. The symbol of the block shows all the input and output ports of this 
block. The inputs of this block are connected to the Keypad and the Cooker models while the 
outputs connect to the Cooker and to the Disp/aySink models. 
The internal structure of this model is fairly complex. This model is mnde up of thirteen 
internal components of which six blocks are used to control the blinking within the display. 
These blocks will not be described within this section. They are very simple blocks which 
allow selected icons on the display to blink. Figure 4-5 is the schematic diabTfam of the 
FAGOR_BehaviouratMode/ and shows all the internal blocks and how they are connected 
together. 
-70 -
r .. (,(~IIl._ 
. , ~~ 
 r,." ' _ , _ ... 
sysn ... , "'-' 
Appelldix 4 Remote COlltrol ill CoCclllric 
LJMff .,... i2J*Int tOOft ~ ~9 
P ~ jliI " ,. 
3 A O / ~O'" 
-<:J_ 
~~--~--~--~~~----------------------~ 
~~~7T.~~wn~--------------------'IUL-J 
Figure 4-4 FAGOR_Behavioural_Model symbol 
Figure 4-5 FAGOR_Behavioural_Model schematic 
The internal blocks of the FAGOR_Behavioural_Model are shown in Figure 4-6 and are: 
- 71 -
Appendix 4 R.",ot. COlltrol III CoC'II,rle 
 Action_BlinkinLDevice. This block enables the Action icon of the display to blink 
when it has been selected by the user 
 Status_BlinkinLDevice. This block enables the Status icon of the display to blink 
when it has been selected by the user 
 StopEnd_BlinkinLDevice. This block enables the StopEnd icon of the display to blink 
when it has been selected by the user 
 ValueSE_BlinkinLDevice. This block enables the ValueStopEnd icon of the display to 
blink when it has been selected by the user 
 ValueTS_BlinkinLDevice. This block enables the Valuenme icon of the display to 
blink when it has been selected by the user 
 Lock_BlinkinLDevice. This block enables the Lock icon of the display to blink when 
it has been selected by the user 
 Display_Controller. This block is the display controller 
 Cooker_Comms_Controller. This block controls the internal communications of the 
remote control with the cooker model 
 ApplianceButtonTimer. This is a hierarchical block; it calculates the lenath of time that 
the appliance button of the remote control has been kept pressed by the user 
 ClockHelp. This block is the clock of the remote control. 
 Control_States. This is a hierarchical block; it is the state machine that controls the 
remote control once it goes into the control state 
 Main_State_Machine. This is a hierarchical block and is the main state machine of the 
remote control. 
 Program_Store. This block is a storage unit for the remote control. 
-72 -
Appelldlx 4 Remote COlltTol /11 CoCelllr/c 
ValueTS_Blinking_Device 
Program_Store 
Figure 4-6 FAGOR_Behavioural_Model hierarchical view 
4.2.1.1 COlltrotSlales 
The Control_States block is an internal hierarchical block of the FAGOR_Behavioural Model. 
This block acts as a state machine that defines all the states of the remote control once the user 
is in the Edit state. Figure 4-7 shows the symbol of this block. All the inputs and outputs ports 
of this block are shown in this diagram. Figure 4-8 shows the schematic for the COllll'Oi_ lales 
block. This schematic shows all the internal primitive blocks and how they are all connected 
together. 
- 73 -
Appell dix 4 Remote COlltro l ;11 CoCelltri c 
~ E __ ~ ___ I- __ 
11~ t [ 3 " O/ H or ~~ o <t(EC' . " "IC"'---~3 
= ..o..J M 10 Sys.~_S\OMlM IfAGO". II,". sy."""""' etMll 
l~f l-3 ~ 
.. , $'fSfE'" . -
, $Nt.1 
. , .c"" 
FA , "  ," __ ,t.:" 
,-~ . ~-
d SVITi" 
~J4IW8I~ 
""'fI." " 
"-"1 (...~. 
". "" 
~ ... ", . ~.(WI 
l .. ",.I ... ,. f r,..",..,... 
Figure 4-7 Control_States symbol 
Figure 4-8 Control_States schematic 
Figure 4-9 shows all the internal block of the Control_States model. The internal blocks are 
- 74 -
Appe"dix " Re mote COl/trol /" 
 Control_Appliance. The process of this block is activated when the r 'mote control 
enters the appliance state, i.e. when the user is electing the different uppliall eli. 
 Control_Status. The process of this block is ac tivated when the remole conlr I 'nl ' I'  
the status state, i.e. when the user is selecting the tatu of an appliance (on or fI). 
 Control_Action. The process of this block is activated when the rem te conlr l ent 'ra 
the action state, i.e. when the user is selecting the different cooking sty le for n 'p 'cifi ' 
appliance. 
 Control_Value. The process of this block is ac tivated when the remote conlrol nl -I ' 
the value state, i.e. when the user is setting the value for a pccific IIclion or un 
appliance; this can be a temperature or a speed value, 
 Control_Lock. The process of this block is activated when the remole control ent ' th 
lock state, i.e. when the user is setting the lock for an appliancc. 
 Control_ StopEnd. The process of this block is activated when the remote c ntrol'nl 'r ' 
the stopEnd state, i.e. when the user is setting the alarm to be on durat/oll or SlOp tillle. 
 Control_ ValueStopEnd. The process of this block is ac tivated wh '11 th ' r 'mot ' . tltt 
enters the stopEnd value state, i.e. when the user is electing th ' time or duration tim 
for a specific appliance. 
ControLAppll ance Control_Stop End 
Figure 4-9 ControtStatcs hicrarchh:al view 
- 75 -
Appendix 4 Remote Control ill CoCelltric 
4.2.1.2 AppliallceButtonTimer 
Another hierarchical component within the FA GOR_Behavioural_Mode/ is the 
ApplianceBu/tonTimer block. This component is in charge of timing for how long the 
Appliance button has been kept pressed in by the user. If the button is kept pressed in long 
enough by the user then the remote control exits the Monitor state and enters the Edit state. 
Otherwise when the Appliance button is pressed it simply moves between the different 
appliances in the Monitor state. The hierarchical structure of this component is shown in Figure 
4-10. This block is made of two primitive blocks. These blocks are: 
 ApplianceButtonDecision. This block is in charge of starting the timer when the 
Appliance button is pressed and retrieve the time when it is depressed. Based on the 
length of time and a parameter set by the user the ApplianceBut/onTimer block will 
send two different signals. 
 Timer. This block enables the ApplianceButtonDecision block to retrieve the time 
when the appliance button is pressed and depressed. 
AppllanceButtonTlmer 
Figure 4-10 ApplianceButtonTimer 
4.2.2 Cooker 
The Cooker block was only built for simulation purposes. It stores al1 the information relative 
to the cooker and feeds it to the FAGOR_Behavioural_Mode/ when requested. The symbol for 
this block with al1 its input and output ports is show in Figure 4-11. The Cooker model is a 
primitive block. 
-76 -
Appendix 4 Remote Control ill CoCeiltric 
.toll: ~ 
o tIC It , '. 10 OJ 
. SetA.cti . 
SetValueT. 
$et$topE . 
Figure 4-11 Cooker symbol 
4.2.3 Disp/aySink 
The Disp/aySink block is a hierarchical model which is in charge of sending the messages to the 
graphical model in order to update the display. As it is shown in Figure 4-12 from the symbol 
of the DisplaySink, this model only has input ports and no outputs. This is because all the 
outputs are feed through socket components to the graphical model. 
Figure 4-13 shows the schematic for the Disp/aySink model. This model is made up of thirteen 
sink socket blocks. The sink blocks are primitive sockets components and they are described in 
details in Chapter 5 of this thesis. The adapter components which are usually used in 
conjunction with the sinks are omitted since the incoming signals are already in string format 
and therefore do not need a translation mechanism. 
-77 -
App endix 4 Remote COlltrol III CoCelltrlc 
~"' 2JIOM lOO1t~ ~ 
"" g Q :.r t"{, .. JIil I ~ .. . ... *' . .  to ,.. ~~ ' Q ., ,I.. : ~ 
J~  ~ I 3 iI A O / ~or \ t\ () GtEt, , BJolfi 3 1J.I 10 s~ 1~"JUI..-vlM* "AGOM I ","tyt~ 
... AGOf\..l,*-.. 
 f~~ 
,00::_..-
r.r ~ Slo&o-... s.c 
. k r .. .;.oIt...u. 
- : ~ CCC'''l~i '' ~ 
il ','.I 
b ht.J v. "T>W , 
-1 ValIA ~il Par'lHollS. \I 'fC',H.:' 
v~SH ' 3 
5hortilfiCilllllOl 
I~: ':~~'" 'sv'_""'''" ",w
' ~u' . ' ."-,. '''-'' ' '~ " .. .:J , =:: tWr:; : ~::::~tbt'~ ;~t~c;'~~ c:~:4~~1.~;ow",~,. 
Figure 4-12 DisplaySink symbol 
 UOl'tlU 
Figure 4-13 DisplaySink schematic 
- 78 -
A pp elldix 4 R emote COlltr o l ill CoCe illri c 
4.2.4 Keypad 
The Keypad block is a hierarchical block and it is in charge of receiving all the inputs from the 
graphical model. Figure 4-14 shows the schematic for the Keypad component. The keypad 
block is made of seven hierarchical blocks. These blocks are the sources blocks. Each internal 
block is connected through TCPIIP sockets with a button on the graphical model. Figure 4- 15 
shows the hierarchical structure of the Keypad block and its internal Sources blocks. More 
details on the source components are given in Chapter 5 of this thesis. 
i _~.., gGII J e - c a; ~ t:"'i. ~ .. . . . .~ ~01\ '" , ,I.. J.: .f' 
-.J.JJlo IWtwr:Nt~ 1I111C.oH I ntlrw Xy,""WlI: 
IW~1("tf"M ::J --;;; 
~ ,J~~ 
.'ii M69 ". er.::... 
e. l.=:.v " $l4-f " SU. __ 
f . * w ... L" 
 P - M70 - "" '" ~""""" "-. , , tlIG -.1t Sou", , -
. ' YPf" "'.-"". " M71 " ~ "". 
I ... c_ OlI L::V 
M72 " ~, ~",\ Sou,. 
M73 " ~." Sou.-
,I M74 e~ IQ-. 
Sou \..::>' "", 
W.l M75 ,. ,~ 
. --I ~ " 
, Co , i< 
) . 1 
l::il __ 
Ill-TO", ""'"_'~UM ... ". .., ~urq I b __ l ui .. ~_l N.,u .~IIh .," ... ~j(u. 'tlat~_l 
or_,,,,,"~1IC ) - 'YU I~ s. ( - un .jl t ) I I 
Figure 4-1 4 Keypad schematic 
Keypad 
Source 
remote_adapter 
Figure 4-1 5 Keypad hierarchical view 
- 79 -
Appendix 5 
Overheads in CoCentric 
and Rational Rose 
RealTime 
Appendix 5 Overheads In CoCentrlc and Rational Rose 
ApPENDIX 5 
OVERHEADS IN COCENTRIC AND 
RATIONAL ROSE REALTIME 
his appendix explores the overheads of the automatically generated code from 
CoCentric System Studio and Rational Rose RealTime in the models described in 
these appendices. For CoCentric two models will be taken into consideration, a 
hierarchical block and a primitive one. For Rational Rose RealTime, two classes will be 
explored, a standard class and a capsule. The source code shown in the next sections focuses on 
the code which is automatically generated from these tools. The quality of the code 
automatically generated by tools is important because developers might need to understand it 
and modify it when necessary. If the code has to be ported to a different compiler or tool then 
overheads and proprietary code need to be translated in order to be processed. Excessive 
overheads might also slow down simulations. These tools (Rational Rose RealTime and 
CoCentric System Studio) enable designers to implement systems graphically. The code 
describing the structure of that system is automatically generated by the tool, while the rest of 
the code is usually written by the designer and does not change. In the case of CoCentric, for 
example, the tool generates the code for the ports, signals and blocks which the user implements 
graphically. In Rational Rose this applies for example to state machines. 
5.1 CoCentrlc Overheads 
This section explores the overheads generated by CoCentric System Studio for two blocks 
which were implemented for the remote control model described in Appendix 4. One is a 
hierarchical model (FAGOR_Entire_System) and one is a primitive model (Sink). 
- 81 -
Appendix 5 Overheads in CoCelltric alld Ratiollal Rose 
5.1.1 FA GOR _Entire_System 
Figure 5-I[a] shows a section of the code of the FAGOR_Entire_System.h file. The code 
marked in bold is proprietary to CoCentric. The rest of the code is also generated by CoCentric 
but it is standard SystemC code and is understood by any C++ compiler. The proprietary code 
generated by CoCentric always has the CCSS_ or ccss_ prefix. 
Hifndef FAGOR sntire System h 
.define --FAGOR-Intire-System-h 
_include-;.yatemc.h> - -
hfnde S~BSIS 
.include <cc  _.y.t.-c.h~ 
'cleHoe CCSS 17" SC C'l'OR 
II fo rward d; cla; ati ons 
class PAGaR Behavioura l Model ; 
class keypad ; -
.Hclef CCS'_I7A_SC_C'l'OR 
'clefine CCSS_IMIT_CBAKKlLS_PRRFI% , 
.unclef CCSS_I7SS_SC_C'l'OR 
 1  
'define CCSI_IMIT_CBAKKlLS_PRRFI% 
Ufndd S~BSIS 
'define CCSI_IMIT_CBAKKBLS CCSS_lNIT_CKAKNBLS_PRSFIX \ 
C10 ("C10" ) \ 
Cll ("Cll" ) \ 
'deUoe CCSS_IMIT_CIIAJIJIBLS 
Hendi 
class FAGOR Entire Syot ... 
, public ac:module-
public . 
II ch nnels 
ac a i gnalc:: int> C10; 
ac:a i gnalcac_string> Cll, 
1/ modul e 1ns t anCes 
FAGOR Behavioural Model "M10 ; 
keypad "M16 ; -
I I defaul t const l "Ucto r 
SC_CTOR (FAGOR_Intire_Syatem) 
cess_IMIT _ CBAKKlLS 
FAGOR Entire System" InitParametera () , 
II proces s d; clarat1ons 
FAGOR_EnUre_System , ,InitInstancea () ; 
Hfndef S~ESIS 
/ destructor 
virtual - FAGOR_Entire_System() 
Hendi 
}, 1/ e nd modu l e FAGOR_EntHe_System 
.unclef CCSS_IMIT_CBAKKlLS_PRRrU 
'unclet CClI_IMIT_CBAKKlLS 
Hendi 
[a] - FAGOR_Entire_System.h 
1/ Sink.h, he de , file 
HHnde f Sink h 
Ndefine ==Sink:h 
.inc lude <8Y8temc . h> 
Hifndef SYNTHESIS 
'include ccca. ayat.-c . b> 
Hendif -
'itdet CCSS_I7SS_SC_CTOR 
'clefine CCSI IMIT KEKlER. PasFII I 
.undef CCSS_VSI_SC_CTOR -
Helse 
'detine CCS'_ lMIT_KEKlS.I_ PasFll 
Hendif 
NUndef SYNTHESIS 
'cletine CCSS INIT KEKlERS CCSI_lNIT_KEKlS"_PasFII \ 
input (" i;jput ') 
Helse 
'cletina CCSS_INIT_KEKlSaS 
Hendif 
c l ass Sink 
, public 8c_module 
public I 
II parame e r o 
cess PARAXETER( int . portNo), 
CCSS:PARAXETEa(.c_.tring. aocketname), 
II porto 
ac_incac_.tring> input, 
II i nitial i ze pa r me t e 18 
virtual void InitParameten() ( 
int _tlllpJlOrtNo " 30000 , 
Bc_string _tq>_iPAddrell " "139.184 .100.139", 
II d fault conot, uc 0 ' 
SC_CTOR(Sink) 
ce'I_IMIT_KEKlERR 
Sink"lnitParametera(), 
SC_MII'I1IOD("yProc) , 
.enlitive cc input, 
void myProc () , 
void SetParameteraSink (.c_et r in9- ) 
}; II e nd modu l e Sink 
'unclef CCII INIT KEKlS., PRRrIX 
'uncle r ceS.:IMIT: KEKlSaS-
[b] - Sink.h 
Figure 5-1 FAGOR_Entire_System.h (CoCentric overhead) 
- 82 -
Appendix 5 Overheads in CoCelltric alld Ratiollal Rose 
Figure 5-1 [b] shows the overhead generated by CoCentric for the primitive model Sink.h. As 
shown in Figure 5-1 [b] there are little differences between overheads for hierarchical and 
primitive blocks in CoCentric. 
5.2 Rational Rose RealTime Overheads 
This section explores the overheads generated by Rational Rose RealTime for two classes which 
were implemented for the remote control model described in Appendix 3. One is the Sock class 
and one is the Socket capsule (class stereotype). All the proprietary elements generated In 
Rational Rose RealTime are shown with the prefixes RT or rt. 
5.2.1 Sock Class 
5.2.1.1 Sock.cpp 
This section shows the overheads generated by Rational Rose RealTime for the source file 
(.cpp) of the Sock class. Figure 5-2 and Figure 5-3 show fragments of the code automatically 
generated which are proprietary to Rational Rose RealTime. Figure 5-3 for example shows how 
the member variables are defined by Rational Rose. 
11/ {{{ RME classif~er 'Logica l V~ew :: Socket packag : :Sock ' 
#if defined ( PRAGMA ) && I defined ( PRAGMA_ IMPLEMENTED ) 
#pragma implementation Sock.h" 
#endif 
#include <RTSystem/remoteComponent.h> 
#include <Sock . h> 
2// {{{ RME class~ fi er 'Log ~ ca l Vi e w: :Soc ke t Package : :Sock' 
11001 'OT: :Cpp' property 'ImplementationPreface' 
/ 1 {{{USR too ' OT : :Cpp ' prope rty 'Implementa i onPre face ' 
// }} }USR 
1/ }}} RME 
static void rtg_Sock_init ( const RTObject_class * type, Sock * target) 
(void )new ( target ) Sock; 
static void rtg_Sock_ copy( const RTObject_class * type, Sock * target, const Soc k * source ) 
(void )new ( target) Sock ( *source ); 
static void rtg_Sock_destr oy ( const RTObject_class * type, Sock * target ) 
target - >-Sock ( ) ; 
Figure 5-2 Sock.cpp (overhead 1 in Rational Rose RealTime) 
- 83 -
Appendix 5 Overheads ill CoCelltric alld Ratiollal Rose 
( onst RTPieldOeacriptor rtg_Sock_fields]  I 
II {{{RME claSSlfle, 'Loglcal vie~"Socket.~p~a~c~k~a~g~e~,~, :sO~Ck~' ~c:l:la:,s:s:A:\t:'l:r:i~b~u:t~e~':h=a:n=d=l~r~.=o=c=k~' ~~ ____ ~~~ __ , 
{ /I {{{RME claSSlfler 'Log l C I Vie~" Sock t P~ck g., "Sock , 
*handle sock* /I 001 ' OT, 'CPP' propelty 'GenN lOt III COliS r il e o . ' 
RTOffaetOf( SOck, handle lock) Sock"Sock( void ) 
/I {{{RME classifie l' 'Logical vi ( 
I/ tool 'OT, ,CppTargetRTS' ) 
(const RTObject_claal *)0 II )RME 
/I )RME 
/I {{ {RME classifier 'Logical V' 
Iitool 'OT"CppTarg RTS' 
(const RTTypeModifier *)0 
/I ) RME 
II {{{RME classifier 'Logical View" Sock~ P ckag "Sock' 
I/tool 'OTIICpp' pcope lly 'G n("1C'1t{'O" tu e O t ' 
Sock".Sock( void ) 
" I) }RME 
I I  )RME II {{{RME classifier 'Loglcal Vie~, ,Socke 
-Ill lock-
RTOffaetOf( Sock, m_80ck ) 
II {{{RME classifier ' Logical v 
Iltool OT"CppTargetRTS' 
~TType int 
II {{{RME classifier 'LoglC. Vi w" Socke P ck ~" Sock' 
I/tool ' OT"Cpp' propelLy 'Celle"\lCCO yConotluC 0,' 
Sock,.Sock( conot Sock ~ rtg_arg ) 
, handle lock ( rtg arg.handle .ock ) 
m_.ock( rtg_arg.m_"OCk) -
m_addr( rtg_arg.m_addr ) i l )RME 
II {{{RME classltier Logical V'  
/I tool 'OT" CppTnge t RTS' L----------------------------------------------------r ----' 
(const RTTypeModifier *) 0 
/I } RME const RTObject_cla  RTType_Sock  
II )RME 
(const RTObject_cla .. *) 0 
(RTSuperAcc  Punctlon)0 I I {{{RME classifier 'Logical View:t Socket package'l 
-Ill add,-
RTOffaetOf ( Sock, m addr ) 
II {{{RME cla; sifier 'Logical View, ,Socket 
Iltool 'OT"CppTargetRTS' property 
(conot RTObject_cla  *)0 
II ) RME 
/I {({ RME elasslElel 'Logical View"SockeL 
1/ 001 'OT"CppTargetRTS' property 
(const RTTypeModifier *) 0 
II }}} RME 
/I })}RME 
Sock-
(RTVeraionld)0 
(RTPieldOff.et) oizeof ( Sock) 
(RTlnitPunctlon)rtg_Sock_lnlt 
(RTCopyPunctlon)rtg_Sock_copy 
Hf OBJICT DECODE 
RTatruct_decode 
Hendi 
*if OBJECT ENCODE 
RTatruct_encode 
Hendi 
(RTDe.troyPunction) rtg_sock_d  troy 
rtg_Sock_field. 
Figure 5-3 Sock.cpp (overhead 2 in Rational Rose RcalTimc) 
- 84-
Appendix 5 Overheads in CoCelltric alld Ratiollal Rose 
5.2.1.2 Sock.h 
Figure 5-4 shows the proprietary code generated by Rational Rose RealTime for the header file 
of the Sock class. Compared to the source file of the same class the generated code is less. 
scruc t RTTypedv~lue_Sock 
const void  data, 
const RTObject_cl  type; 
inline R'M'ypedValue_Sock( const Sock" rtg_value ) 
, datal ,rtg_value ) , type I 'RTType_Sock ) 
, data I "rtg_value ), type I rtg_type ) 
inli.ne -RTTypedValue_Sock ( void ) 
/1 ({( RME class ifier 'Logic J Vi f'l'WllflO(' k .. t P c k. fJ 11r.()Ck ' 
U tndet Sock_H 
.defi ne Sock_H 
Hfdef PRAGMA 
II ({{RME classifiel" 'Logical View : :Socklt pack"'ge : : Sock , tfpr gma interl ce Sock.h-
IItool 'OT"Cpp' property ' HeaderEnding '  ndif 
/I {{{USR 001 'QT , ,cp , prope rty 'HeadHEnding' 
1/ }} }USR Unc lude cRTSy.te .. /relllOteC"""",nent.h. 
1/ }l} RME 
. endif  Sock_H . / 
1/ }}}RME 
extern const RTObject_cl  R'M'yptI_ Sock, 
1/ ))} RM'~ 
I I ({(RME cl tlo if i e l 'LogiC 1 Vi wl lGock e t fl ~jtJ r ll nOC" k ' 
I itool 'OTIICpP ' p r o pe l y 'e 1\ l tl t eCopyCon o rttlc r Ol ' 
Sock I conat Sock " rt9_arg ) I 
II }}}RME 
I I ( {{RME dasBHier ' I,ogic I Vi " "" , Soc kc l v Ok "So<: k ' 
11 001 ' OT II CpP' pl 0 I Y ' e ne t ~"II.t nm nl O J l O t' 
Sock " operator. I conlt Sock " rtg_arg ) I 
Figure 5-4 Sock.h (overhead in Rational Rose RealTime) 
5.2.1.3 SockeLCpp 
This section shows the proprietary code generated by Rational Rose RealTime for the source 
file of the Socket capsule. Figure 5-5, Figure 5-6 , and Figure 5-7 show the code segments. 
Compared to the Sock class previously illustrated, the Socket capsule contains a lot more 
overheads. The Socket capsule is a more complex element since it contains a structure, a port 
and a simple state machine. Figure 5-5, for example, shows the definition of the RTAclor, the 
SUPER RTActor and of the socket_wailing state while Figure 5-6 shows some code of the state 
machine functionality. 
- 85 -
Appendix 5 Overheads in Co Centric and Rational Rose 
int Socket_Actor   _followlnV( RTBindinglnd ~ rtg_end, int rtg-portld, i nt rtg_replndex I 
s~itch ( rtg-POrt1d I 
case 0 I 
default I 
II r emote comm 
if ( rtg_replndex < 1 I 
break ; 
break. ; 
rtg_end,port  ~remote_comml 
rtg_end,index  rtg_replndexl 
return 1; 
return RTActor  _followlnV( rtg_end, rtg-portld, rtg_replndex II 
II ({lRME class>f ~er 'Log~cal V~ew"socke t Package "Socket , enter '.TOp.Socket w i i n 
INLIHB METHODS void Socket_Actor  enter2_Socket_waiting( void I 
II {{{ USR enter' ,TOP ,Socket_wa iti ng ' 
II {{{RME classifier 'Logica l Vi~w : :Socket Package :Sockel ' 
Iltool 'OT, ,Cpp ' prope rty ' Impl ementatlonP,efAce' 
II {({USR tool OT, ,Cpp' property 'Implement lonp,ef.ce' 
II }}}USR 
II }}}RME 
static const RTRelayDeacriptor rtg_relayal)  
"remote_conn-
~Comma  Conjugate"rt cla.a 
1 II card ina l ity -
static RTActor  new_Socket_Actor( RTController  _rta, RTActorRer  _rar I 
return ne~ SOcket_Actor( _rta, _rer II 
const RTActorClaaa Socket  
(const RTActorclara=a __ '~I~O ______________________________________ ~ 
Socket-
(RTVeraionldlO 
rtg_relaya 
new_Socket_Actor 
static const char . const rtg_.tate_namee()  
-TOp 
Socket_waiting-
I ; II 
.define SUPBR RTActor 
Socket_Actor I 1 Socket_Actor ( RTController  rtg_rte , RTActorRet  rtg_ref ) 
, RTActor ( rtg_rta, rtg_ref I 
host ( " 127,0,0,1" 
port ( 30001 I 
flag ( true I 
aHlag ( true I 
remoteOn ( false I 
socket_Actorl.-Socket_Actor( void I 
II {RME classi fier 'Logical View " Socket Package ,. Socket ' 
INLIHB METHODS void Socket Actorl . tranaitionl Initial ( const 
{ - - -
II ({ {USR transition ' , TOP: Initia l ,I nitial' 
ra n a  ion' I TOP I Initi l l ln1 t a l' 
void  rtdata , RTProtocol  rtport 
II {{{ RME c l ass l. ier 'Lo9~ cal View : :$ocket package : : Socket' t t'ansition ' ITOPISock e _wa1ti ng lJ un iOnl loend ,m"  
IHLIHB METHODS voi d Socket_Actorl.tranlition2_aend_mag ( canst SimpleSt ring  rtdata, C0mm8  Conjugate  rtport I 
II {{{USR rans tion  :TOP :Sockct_ wait 1ng: Junctionl: se nd_ msg' 
Figure S-S Socket.cpp (overhead 1 in Rational Rose RealTime) 
- 86-
Appendix 5 Overheads in CoCelltric alld Ratiollal Ro se 
vold SOCket Actor: : rtsBehavior I l.nt signalIndex. lnt port Index ) 
for e lot etatelnde.x  getCurrentState() i i etatelndex  rt9-parent_ state( .tatelndex  1 ) ) 
sWltch ( statelndex ) 
case 1: 
case 2; 
t{{ P..'-IF rl.~sslftpr 'Loglrll \' ll'w:I~rx:lN PK'kJ P.:lt-Q..:k~f' ~l j ' " T01" 
8wl. tch ( port Index ) 
case 0: 
Bwltch ( signalIndex ) 
case 1 : 
default : 
break : 
def ault : 
break : 
unexpectedMes8age () : 
return ; 
}} \ P>lF. 
chainl_I n itial () : 
return ; 
break ; 
1wltch { port I ndex ) 
case 0: 
Bwltch ( ligna1 Index 
case 1: 
return ; 
defaul , 
break : 
Another 20/30 lines 
(conse RTAetor_cl.l   ) 0 
rtg_Ieate_name. 
Socket_Actor I I rtg..,Parent_ Itate 
'Socket 
INLlNE OiAINS vold Socket_Actor: :chalnl_lnltial vOld ) o 
(const RTComponentoeacriptor  )0 
on T r: nltl l :1111[;1.11' 
rtgChainBegin( 1 . "Initial " ); 
rtgTransitionBeginO; 
transitionl_lnitial( msg>daea. m8g - )o84PO ) ; 
rtgTraneitionEnd () ; 
enterState ( 2 ) i 
Socket_Actor I ortgJlOrt I 
(co nsl RTLocolBlndjngDelcrlptor . ) 0 
Socket_Actor I I ttg_Socket_tteldl 
INLINE CHAINS vold SOcket_Actor: : chain2_send_mBg ( void ) 
const RTStateld Socket_Actor" tt9-P6t nt_It ate II  
t t- lIliUt 100 ' :TOP:S(IC"~~(t WHI 1ng:J\In't 1001 : l3f nd _mfl" 
rtgChainBegin ( 2. -send_mag- ); 
exitState ( ngyarent_state ); \ ; 
rtgTran8itionBegin () ; I 
tran8itl.on2_8end_mag( (const SimpleString . )""'9 ~ "'data . (Comn8"Conjugate  ) m8g-,..apO ) , 
rtgTran8itlonEnd () ; _ 
enterState ( 2 ); 
const RTPOrtoe8criptor Socket_Actor I ,rtgJlOrtl II " 
-remote convn-
(const c h r  )0 
'Conwne: ,Conjugate ll rt_clala 
RTOffeetOf ( Socket_Actor . Socket_ACtOr I I r mote_comm I 
1 ttrhn'llny 
RTPortDescri ptor : : End 
RTPortOeac r i pto r : : NOt i l icat ionOi . bl d 
RTPortDescri ptor : : Reg 18terNOtPernu t t e d 
RTPortDescriptor, ,PubllcV( sibillty 
RTPortDeBcriptor: ,Wired 
Figure 5-6 Socket.cpp (overhead 2 in Rational Rose RealTime) 
- 87 -
Appendix 5 Overheads in CoCelllric alld Raliollal Rose 
const RTFieldDescriptor Socket_Actor :: rtg_Socket_ fields[]  
II (( (RME class if i er ' Logica l View:: Soc ket Package :: Sockel' c l assAtlribu t e 'm_Bock' 
-m_sock 
RTOffsetOf ( Socket Actor , m sock ) 
II {({RME cl ~ssitler 7Logical Vie w: 'Socke Packagp : :Socke t ' c l a ssA t tr i but 'm_s ock' 
Iltool 'OT: :Cp pTargetRTS ' pro perly 'TypeDescr 'ptor' 
&RTType i nt 
17 )} }RME 
II ({(RM> claSSlfier 'Lo l ca l View" Sock e t Pack age :: Sock t ' c l sSAtt r ibu e 'm_ sock ' 
Iitool 'OT: 'CppT r RTS ' pro pe rty ' G lIe r a t e Type Modifler' 
, (const RTTypeModifier * ) 0 
/I I I I RME 
II III RME 
II (((RME classifie r 'L l c al Vi e w: : Socke Packag: :Soc ke ' cl BsA lribute ' hOB ' 
-host-
RTOffsetOf( Socket Actor, host) 
II ({(RME cl ; s s ifie r ' Logi c al Vie w:: Socke Pa c ka e :: Sock t ' classA tribu e ' hos ' 
II 001 ' OT::CppTarg t RTS ' pro p r y 'Ty peDe s crlp or ' 
(const RTObject_clasa * ) 0 
I I I I IRME 
II ( ((R~lE classifie r 'Logi ca l Vie w:: Sock t Package "Socket , classAtt>lbut 'host ' 
/I 001 ' OT: :CppTarg RTS ' property ' G n rateTyp ModiCi'r' 
(canst RTTypeModifier * ) 0 
I I I I IRNE 
Over 100 lines of which more than 50% are comments 
Figure 5-7 Socket.cpp (overhead 3 in Rational Rose RealTime) 
- 88 -
Appendix 5 Overheads in Co Centric and Rational Rose 
5.2.1.4 Socket" 
As for the Sock class the header of the Socket capsule contains less overhead compared to its 
source file . Figure 5-8 shows the code segments which are proprietary to Rational Rose 
RealTime. 
protected , 
prIvate ; 
pub 11 c , 
protected : 
pUbllC I 
publlC I 
SOcke t_Actor ( RTController  rtg_rtB , RTActo r Ref  rtg_ ref ) ; 
vIrtual - SOcket Actor ( VOId ); 
vIrtual lnt _followtnV( RTBindingEnd & rtg_ end. lnt r tg_ part I d . lnt rt9_ repl ndex ) I 
INLlNE ME'rnODS vOId ente r2 Socke t waiting ( vOI d ); 
tl :::-""F. --
vIrtual VOId e n terStateV( VOId ) j 
~.j~:.'t :lel 'r~'ll <)1  e: : ~(1'k(' t PV'k,J'1e: .S' 'J.CI {cm It 01 r ~ JOlt J1 Inl 1\  
INLlNE_METHOOS VOid t r ansltionl_Ini t ial ( con s t voi d  rtdata. RTPrOtocol  r tport ) t 
~F o~c;:_fler ' frIC1IC'..t V1C:W: :SOCh.C"t P lckaqe:I-j()("I'ct.' tr t-ln'l'lnn 1')11, .. ') k l \Io. ll1ll1'1I,11U\(tICH1\1f4('l\d III .. ,, ' 
INLINB_MEniOOS vOld trans i t ion 2_Send_m&g ( const Simpl eSt ring  rtdata, COlTl11sllConjug te  rtport ) I 
~ .. E' 
i"'F ~1~5S1 ler  I..o-)l('~l Vl e ... : : ~Y ct f'ac\t:"'1c::$oc-kc 1 ' r"Hl:Htl,r1" I<t';t w, l lt lnql.l11rl 11~t1jl l ll 
INLlNE_METIlOOS vO ld t r ans l t ionl_allarm( can s t T i me4  rtdata , Comna, ICOn j ug8te  rtport ) I 
)} }Pt:E 
I NLINE CHAI NS vo.d chai nl In i tiall void I I 
INLINE -CHAINS vo.d cha i n 2 - send In8g ( vOld I , 
INLINl(CHAI NS VOId Chai n3=allar m( vOId ) t 
vlrtual vOld r tsBehavior( 1n s i gna lI ndex, lnt port Ind ex ) : 
vlrtual const RTActor_c l ass  ge tActo r Data ( VOid ) const : 
statlC const RTActor_class r t g_class : 
sta lC canst RTState l d rtg_parent_state l) : 
statlc canst RTPOr tDescr i pto r rtgJ>Ort a [J I 
staue conSt RTFi e ldDesc r ipt or rtg_SOCket_fie l ds (]: 
. under SUPER 
I ({ {"_'IE 
/ I {Ii U;:p 
1/ II }'-'SP 
, l 'tP ... E 
/I )}}p,1E 
la~~.lll er ' Legl dl \ne ... : :Sockct Pacl,.)'1C: : Socl-.et' tool ' OT : : e n' property 'tc..lr1crt-;nrho' , ' 
t,>~l 'OT : :CPP' ro crty 'Hc'lderEndlnq' 
Figure 5-8 Socket.h (overhead in Rational Rose RealTime) 
- 89-
Appendix 5 Overheads ill CoCelltric alld Ratiollai Rose 
5.3 COllsideratiolls of Overheads 
The code generated by CoCentric does not contain a lot of overheads and is easy understand. 
Experiments conducted at the University of Sussex, in the Centre for VLSI and Computer 
Graphics showed that the manual translation of CoCentric models into standard SystemC 
models is fairly easy and fast. Additionally, source files do not contain overheads. The ease of 
translation of automatically generated code into standard code can determine the quality of the 
automatically generated code. 
II channels 
II module 1nstances 
II default cons ructot 
II process declarat10ns 
II destructor 
II end module FAGOR_EnLlre_System 
Figure 5-9 CoCentric - comments 
The code generated by CoCentric contains a very limited amount of comments, but the ones 
provided are understandable and intuitive as shown in Figure 5-9. 
Rational Rose RealTime generated code is extremely hard to understand. The automatically 
generated code contains a very large number of comments but as it is for the code they are hard 
to understand; an example is shown in Figure 5-10. 
II {{{RME classifier 'Logical View: :Socket Package: :Socket ' cl ssAt 
Iltool 'OT: :CppTargetRTS' property ' Ge nerateTypeModifier' 
Figure 5-10 Rational Rose RealTime - comment 
The consideration is that the code generated by Rational Rose RealTime is much harder to 
understand or translate in a standard language as compared to CoCentric System Studio. This 
implies that the quality of the automatically generated code by Rational Rose is not as good as 
the one generated by CoCentric. However, Rational Rose provides the advantage that the code 
is described through UML standard diagrams and this allows easy reimplementation of the 
model in different programming languages. In addition the models can be understood through 
the use of the standard UML diagrams and therefore do not rely on the knowledge of any 
programming language. 
- 90-
